# Session Puzzling

> **Summary**: Session puzzling (also called session variable overloading) occurs when an application uses the same session variable for multiple purposes across different flows, allowing an attacker to manipulate one flow to influence another.
> **Impact**: Authentication bypass, privilege escalation, access control circumvention, account takeover.
> **Typical Severity**: High

## Detection

### Indicators
- Same session variable name used in different application flows (e.g., login, password reset, registration)
- Session state is checked without verifying which flow populated it
- Application allows unauthenticated access to flows that set session variables also used in authenticated contexts
- Multi-step workflows that store intermediate state in session variables

### Automated Detection
- Map all endpoints that read/write session variables using a proxy (Burp Suite session tracking)
- Use Burp Logger or custom extensions to track session variable assignments across flows
- Compare session cookies before and after interacting with different features

### Manual Detection
1. Identify endpoints that set session variables (login, registration, password reset, 2FA, etc.)
2. Complete one flow partially (e.g., start password reset but do not finish)
3. Navigate to a different feature that reads the same session variable (e.g., admin dashboard)
4. Check if the session state from flow A grants access in flow B

## Exploitation

### Prerequisites
- The application reuses the same session variable across different logical flows
- At least one flow that sets the variable is accessible without full authentication
- The application checks the session variable but not the context in which it was set

### Step-by-Step

1. **Map session-dependent flows**: Identify all endpoints that create or modify session state. Focus on:
   - Login / authentication
   - Password reset
   - Registration / email verification
   - 2FA / MFA verification
   - Profile update
   - Admin workflows

   **Success**: You have a list of endpoints and the session variables they read/write.

2. **Identify shared session variables**: Look for variables that are set in one flow and checked in another. Common examples:
   - `session['user']` set during registration and checked in admin panel
   - `session['authenticated']` set during password reset and checked at login
   - `session['role']` or `session['is_admin']` set via a public flow

   **Success**: You find at least one variable used in two different contexts.

3. **Trigger the variable via the weaker flow**: Complete the flow that sets the target session variable without requiring full authentication. For example:
   - Start a password reset for an admin account (sets `session['user'] = 'admin'`)
   - Register a new account (sets `session['authenticated'] = true`)
   - Complete a partial login step (sets `session['user_id']`)

   **Success**: The session variable is now populated with a controlled value.

4. **Access the protected feature**: Navigate to the endpoint that reads the session variable, expecting it to have been set by the proper (authenticated) flow:
   ```
   GET /admin/dashboard HTTP/1.1
   Cookie: PHPSESSID=<SESSION_FROM_STEP_3>
   ```

   **Success**: You gain access to the protected feature without completing the required authentication flow.

5. **Escalate**: Use the bypassed access to perform privileged actions, extract data, or chain with other vulnerabilities.

### Payloads

#### Password Reset to Authentication Bypass
```
1. POST /forgot-password  (body: email=admin@target.com)
   -> Server sets session['user'] = 'admin'
2. GET /admin/dashboard
   -> Server checks session['user'] exists -> grants access
```

#### Registration Flow to Admin Access
```
1. POST /register  (body: username=admin&email=attacker@evil.com)
   -> Server sets session['username'] = 'admin' (name already taken, but session set before validation)
2. GET /profile/edit
   -> Server uses session['username'] to load profile -> loads admin profile
```

#### 2FA Bypass via Session Overloading
```
1. POST /login  (body: user=admin&pass=admin_password)
   -> Server sets session['pending_2fa'] = true, session['user_id'] = 1
2. POST /login  (body: user=attacker&pass=attacker_password)  [attacker has no 2FA]
   -> Server sets session['authenticated'] = true but session['user_id'] still = 1
3. GET /dashboard
   -> Logged in as admin (user_id=1) without completing 2FA
```

#### Cancellation / Incomplete Flow Abuse
```
1. Start a sensitive workflow that sets session variables
2. Cancel or navigate away before completion
3. Session variables remain set
4. Access a different feature that relies on those variables
```

### Proof of Concept

```python
import requests

target = "http://<TARGET>"
s = requests.Session()

# Step 1: Trigger password reset for admin (sets session['user'] = 'admin')
s.post(f"{target}/forgot-password", data={"email": "admin@target.com"})

# Step 2: Access admin panel using the same session
r = s.get(f"{target}/admin/dashboard")
if "Admin Dashboard" in r.text:
    print("[+] Session puzzling successful - admin access gained")
else:
    print("[-] Session variable not reused or flow differs")
```

## Bypasses

- If the application clears session variables after flow completion, try aborting the flow mid-way
- If session is regenerated on login, check if password reset or registration preserves the old session
- Try interleaving steps from different flows in unexpected orders
- Race condition: trigger two flows simultaneously that both write to the same variable

## Escalation

- **Authentication bypass to account takeover**: Access admin features, change passwords, exfiltrate data
- **Privilege escalation**: Set admin role via a public flow, then access privileged endpoints
- Chain with [Account Takeover](account-takeover.md) techniques
- Chain with [Cookie-Based Attacks](cookie-based-attacks.md) for session manipulation

## Tools

| Tool | Usage |
|------|-------|
| Burp Suite | Track session variables across requests using Logger and Session Handling Rules |
| Burp Autorize | Test access control by replaying requests with different session states |
| Custom scripts | Automate flow interleaving to test session variable reuse |
| OWASP ZAP | Passive scanning for session management issues |

## References

- [OWASP - Session Puzzling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/)
- [Session Puzzling and Session Race Conditions](https://medium.com/@maheshba1u/session-puzzling-attack-bypassing-authentication-29f4ff2fd4f5)

## Agent Workflow
> Step-by-step instructions for an AI agent to test for session puzzling.

### Phase 1: Discovery
1. Map all endpoints that create, modify, or read session variables. Focus on:
   - Login / authentication (`POST /login`)
   - Password reset (`POST /forgot-password`, `GET /reset-password`)
   - Registration (`POST /register`)
   - 2FA/MFA verification (`POST /verify-2fa`)
   - Profile update (`PUT /profile`)
   - Admin workflows (`POST /admin/*`)
2. For each endpoint, observe which session cookies or variables change after interaction (use Burp Suite session tracking or compare `Set-Cookie` headers).
3. Identify endpoints that check session state for authorization (e.g., `GET /admin/dashboard` checks `session['user']` or `session['authenticated']`).

### Phase 2: Validation
1. Identify shared session variable names by testing cross-flow behavior:
   - Start a password reset for an admin account (`POST /forgot-password email=admin@target.com`).
   - Without completing the reset, navigate to a protected endpoint (e.g., `GET /admin/dashboard`).
   - Check if the session variable set during password reset (e.g., `session['user'] = 'admin'`) grants access.
2. Test registration flow to auth bypass:
   - Register with `username=admin` (even if the name is taken, the session variable may be set before validation).
   - Navigate to a protected endpoint that reads `session['username']`.
3. Test 2FA bypass:
   - Login as admin (sets `session['user_id']`), stop before completing 2FA.
   - Login as attacker with no 2FA (sets `session['authenticated'] = true`), but `session['user_id']` still holds the admin's ID.
4. Test incomplete/cancelled flows: start a sensitive workflow, cancel mid-way, then check if session variables persist.

### Phase 3: Exploitation
1. Trigger the weaker flow that sets the target session variable:
   ```python
   s = requests.Session()
   s.post("http://<TARGET>/forgot-password", data={"email": "admin@target.com"})
   ```
2. Access the protected feature using the same session:
   ```python
   r = s.get("http://<TARGET>/admin/dashboard")
   ```
3. If access is granted, perform privileged actions: change passwords, exfiltrate data, modify settings.
4. For 2FA bypass: interleave login steps from two different accounts to inherit the authenticated state of one while retaining the user_id of the other.

### Phase 4: Escalation
1. Use bypassed access to perform account takeover: change the admin's email/password.
2. Chain with race conditions: trigger two flows simultaneously that both write to the same session variable.
3. Access and exfiltrate all data available through the admin panel.
4. Document the specific flow sequence that leads to the bypass for the report.

## Decision Tree

```
Start: Map all endpoints that set/read session variables
  |
  +---> Same session variable used in multiple flows?
  |       +---> Yes: Identify the weaker flow (no full auth required)
  |       |       +---> Password reset sets session['user']? --> Access protected endpoints
  |       |       +---> Registration sets session['username']? --> Access profile as another user
  |       |       +---> Partial login sets session['user_id']? --> Bypass 2FA
  |       +---> No shared variables: Test incomplete flow persistence
  |
  +---> Incomplete flow leaves session variables set?
  |       +---> Cancel/abort a workflow --> Check if variables persist
  |       +---> Navigate to a different feature that reads those variables
  |
  +---> Session state confusion between flows?
          +---> Interleave steps from different flows in unexpected order
          +---> Race condition: trigger two flows writing same variable simultaneously
```

## Success Criteria
- [ ] Shared session variable identified across at least two different application flows
- [ ] Session variable set via weaker flow (e.g., password reset) grants access to protected feature
- [ ] Protected endpoint accessible without completing the intended authentication flow
- [ ] Privileged actions performed (data access, role change, ATO) using session state from a different flow

## Cross-References

- [Cookie-Based Attacks](cookie-based-attacks.md) -- Session manipulation and fixation techniques
- [Account Takeover](account-takeover.md) -- Session puzzling as a path to ATO
- [Race Conditions](race-conditions.md) -- Concurrent session variable modification
