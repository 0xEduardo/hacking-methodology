# Account Takeover

> **Summary**: Account takeover (ATO) encompasses a range of techniques that allow an attacker to gain unauthorized access to another user's account by exploiting weaknesses in authentication, session management, password reset flows, or business logic.
> **Impact**: Full control of the victim's account, including access to personal data, ability to perform actions as the victim, and potential lateral movement.
> **Typical Severity**: High | Critical

## Detection

### Indicators

- Password reset flow is present (check for token predictability, host header reflection)
- OAuth/social login integration exists
- Email or password change endpoints do not require re-authentication
- API responses differ between valid and invalid accounts (user enumeration)
- IDOR patterns visible in profile/account management URLs
- Session tokens do not rotate after privilege changes

### Automated Detection

```bash
# Nuclei -- account takeover related templates
nuclei -u <TARGET_URL> -tags takeover,auth -o <OUTPUT_FILE>

# Burp Suite -- test password reset flow
# Send reset request to Repeater, manipulate Host header, check token in response

# ffuf -- user enumeration via response differences
ffuf -w <USERNAME_WORDLIST> -u <TARGET_URL>/api/user/FUZZ -mc 200 -o <OUTPUT_FILE>
```

### Manual Detection

1. Trigger a password reset and inspect the reset link structure (token length, predictability, expiration).
2. Check if the `Host` header value is reflected in the reset email link.
3. Test if email/password change requires current password or re-authentication.
4. Look for IDOR in user profile endpoints (`/api/user/123` vs `/api/user/124`).
5. Check if OAuth `redirect_uri` validation is strict or allows open redirects.
6. Test response manipulation by intercepting and modifying authentication responses.

## Exploitation

### Prerequisites

- Target application has user accounts with authentication
- Access to at least one low-privilege test account (for most techniques)
- Ability to intercept and modify HTTP requests (Burp Suite or similar)

### 1. Password Reset Poisoning (Host Header Injection)

**How it works**: The password reset email is generated using the `Host` header value. By manipulating it, the reset link points to an attacker-controlled domain, leaking the reset token when the victim clicks it.

**Steps**:
1. Intercept the password reset request for the victim's email.
2. Modify the `Host` header to `<ATTACKER_DOMAIN>`.
3. Alternatively, add `X-Forwarded-Host: <ATTACKER_DOMAIN>`.
4. The victim receives a reset email with a link like `https://<ATTACKER_DOMAIN>/reset?token=<TOKEN>`.
5. When the victim clicks the link, the token is sent to the attacker's server.
6. Use the captured token on the legitimate reset endpoint.
   - Success: You can set a new password for the victim's account.

```http
POST /forgot-password HTTP/1.1
Host: <ATTACKER_DOMAIN>
Content-Type: application/x-www-form-urlencoded

email=victim@example.com
```

Alternative headers to try:
```
Host: <ATTACKER_DOMAIN>
X-Forwarded-Host: <ATTACKER_DOMAIN>
X-Forwarded-For: <ATTACKER_DOMAIN>
X-Original-URL: https://<ATTACKER_DOMAIN>
Referrer: https://<ATTACKER_DOMAIN>
```

See: [Host Header Injection](host-header-injection.md)

### 2. OAuth Account Takeover

**Scenarios**:

#### Redirect URI Manipulation
1. Identify the OAuth flow and the `redirect_uri` parameter.
2. Test for open redirect in the `redirect_uri` (e.g., `redirect_uri=https://legitimate.com/callback/../attacker.com`).
3. If the provider allows a lax match, the OAuth code/token is sent to the attacker.
   - Success: Capture the authorization code and exchange it for an access token.

#### Missing State Parameter (CSRF in OAuth)
1. Start an OAuth flow and capture the authorization URL.
2. Remove or reuse the `state` parameter.
3. Send the crafted URL to the victim; when they click it, their account links to the attacker's identity provider account.
   - Success: The attacker can now log in via their own OAuth account to access the victim's application account.

#### Pre-Account Takeover via OAuth
1. Register on the target platform using the victim's email address (set a password).
2. Do not verify the email (or verification is not enforced).
3. Wait for the victim to sign up via OAuth (Google, Facebook, etc.) with the same email.
4. The OAuth flow confirms the email and merges/links with the existing account.
5. The attacker can now log in with the password set in step 1.
   - Success: Access the victim's account using the pre-registered credentials.

See: [OAuth](../authentication/oauth.md)

### 3. Email Change Without Verification

1. Log in to a test account.
2. Change the email to `victim@example.com` via the profile settings or API.
3. Check if a verification email is sent to the NEW address or if the change is immediate.
4. If immediate: the account is now associated with the victim's email.
5. Trigger a password reset for `victim@example.com` and take over.
   - Success: The password reset email goes to the attacker-controlled original email, or no verification is needed.

#### Email Change Confirmation Link Exploit
1. Attacker requests an email change on their own account and receives a confirmation link.
2. Attacker sends the confirmation link to the victim (via phishing, chat, etc.).
3. When the victim clicks it, their session confirms the email change to the attacker's email.
   - Success: The victim's account email is changed to the attacker's email.

### 4. Session Fixation Leading to ATO

1. Obtain a valid session token from the application (e.g., by visiting the login page).
2. Force the victim to use this session token (via XSS, URL parameter, cookie injection on a subdomain).
3. Wait for the victim to authenticate.
4. If the session token is not regenerated after login, the attacker's pre-set token is now authenticated.
   - Success: The attacker uses the same session token to access the victim's authenticated session.

See: [Cookie Based Attacks](cookie-based-attacks.md)

### 5. IDOR in User Profile Endpoints

1. Log in as a low-privilege user and capture API requests for profile operations.
2. Identify user identifiers in requests (e.g., `/api/user/1001/email`).
3. Change the identifier to another user's ID and replay the request.
   - Success: You can modify another user's email, password, or profile data.

See: [IDOR](idor.md)

### 6. Race Conditions in Email/Password Change

1. Identify the email or password change endpoint.
2. Send multiple concurrent requests to change the email (one to the attacker's email, one to keep the original).
3. The race condition may result in the email being changed while the verification is sent to the old address, or the change bypasses validation logic.
   - Success: Email is changed without proper verification completing.

```python
import requests
import threading

def change_email(session, url, email):
    session.post(url, data={'email': email})

s = requests.Session()
s.cookies.set('session', '<SESSION_TOKEN>')

threads = []
for _ in range(20):
    t = threading.Thread(target=change_email, args=(s, '<CHANGE_EMAIL_URL>', 'attacker@evil.com'))
    threads.append(t)
for t in threads:
    t.start()
```

See: [Race Conditions](race-conditions.md)

### 7. Response Manipulation

1. Intercept the login response or authentication check.
2. If the response is a simple boolean or status code, modify it:
   - Change `{"success": false}` to `{"success": true}`
   - Change HTTP status `403` to `200`
   - Change `{"role": "user"}` to `{"role": "admin"}`
3. Check if the client-side relies on this response without server-side enforcement.
   - Success: Access to the account or elevated privileges.

### 8. Token Prediction / Brute Force

1. Request multiple password reset tokens and analyze their structure.
2. Look for patterns: sequential numbers, timestamps, weak random generation.
3. If tokens are short or predictable, brute-force the token space.
   - Success: Valid reset token found for the victim's account.

```bash
# Brute force short reset tokens
ffuf -w <TOKEN_WORDLIST> -u "<RESET_URL>?token=FUZZ" -mc 200 -fs <ERROR_RESPONSE_SIZE>
```

### 9. Unicode Normalization Attack

1. Identify that the target normalizes Unicode characters during account lookup.
2. Register an account with a Unicode-equivalent email: e.g., `vićtim@example.com` (with a Unicode 'c').
3. The system normalizes this to `victim@example.com` during lookup.
4. The attacker can now authenticate as the victim through the Unicode variant.
   - Success: Access the victim's account through Unicode normalization confusion.

This also works via third-party identity providers:
- Create an account on the IdP with a Unicode-variant email.
- Log in via the IdP to the target platform, which normalizes the email and matches the victim.

### 10. CORS Misconfiguration to ATO

1. Identify a CORS misconfiguration that allows arbitrary origins or reflects the `Origin` header.
2. Host a malicious page on the attacker's domain that makes cross-origin requests to sensitive endpoints.
3. Steal session tokens, API keys, or personal data from the response.
   - Success: Exfiltrate credentials or session data to take over the account.

See: [CORS](cors.md)

### 11. CSRF to Account Takeover

1. Identify that the email or password change endpoint lacks CSRF protection.
2. Craft a CSRF payload that changes the victim's email or password.
3. Host the payload and trick the victim into visiting it.
   - Success: The victim's email/password is changed to the attacker's values.

See: [CSRF](csrf.md)

### 12. XSS to Account Takeover

1. Find a stored or reflected XSS vulnerability.
2. Craft a payload that steals session cookies, localStorage tokens, or makes API calls to change the email/password.
3. Deliver the XSS payload to the victim.
   - Success: Session hijacking or credential change via JavaScript execution.

See: [XSS](xss.md)

### 13. Security Question Overwrite (IDOR)

1. Log in as a low-privilege user.
2. Find the security question update endpoint.
3. If it accepts a `username` parameter, change it to the victim's username.
4. Overwrite the victim's security questions with known answers.
5. Authenticate via the security question flow using the injected answers.
   - Success: Bypass authentication and access the victim's account.

```http
POST /reset-security-questions HTTP/1.1
Cookie: session=<LOW_PRIV_SESSION>
Content-Type: application/x-www-form-urlencoded

username=<VICTIM_USERNAME>&answer1=AAA&answer2=BBB&answer3=CCC
```

## Bypasses

### Token Reuse
- Check if password reset tokens can be used multiple times (no invalidation after use).
- Check historical URLs via Wayback Machine or `gau` for leaked reset tokens:
```bash
gau <TARGET_DOMAIN> | grep -i "reset\|token\|forgot" | sort -u
```

### Old Cookies Still Valid
- After a password reset or session invalidation, test if old session cookies still work.
- Some applications fail to invalidate previous sessions after credential changes.

### 2FA Bypass for ATO
- If the account has 2FA, check if the password reset flow bypasses it.
- Test if backup codes are predictable or brute-forceable.
- See: [2FA](../authentication/2fa.md)

## Escalation

- **ATO to Privilege Escalation**: After taking over a regular user account, check if it can be escalated to admin via IDOR or role manipulation.
- **ATO to Data Exfiltration**: Access the victim's private data, messages, files, or payment information.
- **ATO to Lateral Movement**: Use the compromised account to pivot to other integrated services (SSO, linked accounts).
- **ATO to Organization Compromise**: If the taken-over account is an admin, gain control of the entire organization.
- **Chain with Subdomain Takeover**: If a subdomain is taken over, use it for cookie theft or OAuth redirect to enable ATO. See: [Subdomain Takeover](subdomain-takeover.md)

## Tools

| Tool | Usage |
|------|-------|
| [Burp Suite](https://portswigger.net/burp) | Intercept and manipulate auth flows, test reset tokens |
| [ffuf](https://github.com/ffuf/ffuf) | `ffuf -w <WORDLIST> -u <URL>/FUZZ -mc 200` for user enumeration and token brute force |
| [gau](https://github.com/lc/gau) | `gau <DOMAIN> \| grep token` to find leaked reset tokens in archives |
| [waybackurls](https://github.com/tomnomnom/waybackurls) | `waybackurls <DOMAIN> \| grep reset` for historical token leaks |
| [Autorize](https://github.com/PortSwigger/autorize) | Burp extension for automated authorization testing (IDOR detection) |
| [JWT Tool](https://github.com/ticarpi/jwt_tool) | `jwt_tool <TOKEN> -T -S hs256 -p ""` for JWT manipulation |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for account takeover vulnerabilities.

### Phase 1: Discovery
1. Map all account-related endpoints on `<TARGET>`:
   - Login: `POST /login`, `POST /api/auth/login`
   - Registration: `POST /register`, `POST /api/auth/signup`
   - Password reset: `POST /forgot-password`, `GET /reset-password?token=<TOKEN>`
   - Email change: `POST /account/email`, `PUT /api/user/email`
   - Password change: `POST /account/password`, `PUT /api/user/password`
   - OAuth linking: `GET /auth/google`, `GET /auth/facebook`, `POST /api/auth/link`
   - Profile update: `PUT /api/user/profile`, `PATCH /api/user/<USER_ID>`
2. Check if email/password change requires re-authentication (current password prompt)
3. Test for user enumeration: submit valid vs. invalid emails to login/register/reset endpoints and compare responses (status codes, timing, error messages)
4. Identify IDOR patterns in profile URLs: `/api/user/<USER_ID>`, `/profile/<USERNAME>`
5. Check for OAuth/social login providers and map the OAuth flow parameters

### Phase 2: Validation
1. **Password reset poisoning**: Trigger a password reset for `<VICTIM_EMAIL>` with a modified Host header:
   ```http
   POST /forgot-password HTTP/1.1
   Host: <ATTACKER_SERVER>
   Content-Type: application/x-www-form-urlencoded
   email=<VICTIM_EMAIL>
   ```
   Also try: `X-Forwarded-Host: <ATTACKER_SERVER>`, `Forwarded: host=<ATTACKER_SERVER>`
   Check the reset email: does the link point to `<ATTACKER_SERVER>`?
2. **Token predictability**: Request 10+ reset tokens for your own account, analyze entropy with Burp Sequencer
3. **IDOR in profile endpoints**: Access `/api/user/<VICTIM_ID>` with your own session token
4. **Email change without verification**: Change your email to a new address and check if it takes effect immediately without confirmation
5. **OAuth linking CSRF**: Check if the OAuth link/unlink flow validates the `state` parameter

### Phase 3: Exploitation
1. **Password reset poisoning** (if Host header reflected): Victim clicks the poisoned link, token leaks to `<ATTACKER_SERVER>`, use token on legitimate reset endpoint to set new password
2. **IDOR account modification**: Modify `/api/user/<VICTIM_ID>/email` or `/api/user/<VICTIM_ID>/password` using your session
3. **OAuth account linking**: Exploit missing state validation to CSRF-link attacker's OAuth identity to victim's account
4. **Pre-account takeover via OAuth**: Register with victim's email (no verification), victim later signs up via OAuth, accounts merge, attacker still has password access
5. **Race condition on email change**: Send concurrent requests to change email to attacker-controlled address, exploiting TOCTOU
6. **Response manipulation**: Intercept login/auth response, change `{"success": false}` to `{"success": true}` or `{"role": "user"}` to `{"role": "admin"}`

### Phase 4: Escalation
1. Demonstrate full account compromise: log in as victim, read private data, change credentials
2. If victim account is admin: access admin panel, enumerate all users, exfiltrate data
3. Chain with lateral movement: use compromised account to pivot to other linked services (SSO, OAuth)
4. Chain with subdomain takeover: use taken-over subdomain for cookie theft or OAuth redirect to enable ATO
5. Test if password change invalidates other sessions -- if not, victim remains unaware

## Decision Tree

```
Account Takeover Testing
├── Password reset flow
│   ├── Host header poisoning → token leaks to attacker server?
│   ├── Token predictable/short? → brute-force token
│   ├── Token reusable after password change? → replay attack
│   └── Referer leakage? → token in third-party logs
├── IDOR in user endpoints
│   └── Change <USER_ID> → modify another user's email/password?
├── OAuth flow
│   ├── Redirect URI manipulation → steal authorization code?
│   ├── Missing state → CSRF link attacker's identity?
│   └── Pre-registration → merge accounts?
├── Email/password change
│   ├── No re-authentication required? → change victim's email
│   ├── Race condition? → concurrent email change
│   └── Verification bypass? → immediate email change
├── Response manipulation
│   └── Client trusts server response → modify success/role values
└── Unicode normalization
    └── Register with homoglyph email → system normalizes to victim?
```

## Success Criteria
- [ ] Full access to victim's account using one of the attack vectors
- [ ] Victim's credentials changed to attacker-controlled values (password or email)
- [ ] Attacker can log in as victim persistently (via OAuth linking, password change, or stolen token)
- [ ] Private user data accessed (messages, files, payment info) from the victim's account
- [ ] Admin account compromised, granting organizational-level access

## References

- https://book.hacktricks.wiki/en/pentesting-web/account-takeover.html
- https://infosecwriteups.com/firing-8-account-takeover-methods-77e892099050
- https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/04-Authentication_Testing/
- https://dynnyd20.medium.com/one-click-account-take-over-e500929656ea
- https://portswigger.net/web-security/host-header/exploiting/password-reset-poisoning
- https://www.youtube.com/watch?v=CiIyaZ3x49c (Unicode Normalization talk)
