# Race Conditions

> **Summary**: Race conditions occur when an application processes concurrent requests in a way that leads to unintended behavior due to timing conflicts in shared resource access.
> **Impact**: Bypass business logic limits, duplicate financial transactions, escalate privileges, bypass authentication, corrupt data integrity.
> **Typical Severity**: High

## Detection

### Indicators

- Coupon or discount code redemption endpoints
- Balance transfer / withdrawal operations
- Voting, rating, or like functionality
- Gift card or reward point redemption
- Account registration with email verification
- Password reset token generation
- File upload and processing workflows
- Anti-brute-force rate limiting mechanisms
- CAPTCHA validation and reuse
- 2FA enforcement during login sequences
- OAuth authorization code exchange
- Any endpoint that reads a value, checks it, then writes based on the check (TOCTOU)

### Automated Detection

- Use Burp Suite Repeater with "Send group in parallel (single-packet attack)" on candidate endpoints
- Turbo Intruder with `race-single-packet-attack.py` template
- Monitor for duplicate entries in database results (e.g., coupon applied twice)
- Look for inconsistent state in responses when identical requests are sent concurrently

### Manual Detection

1. Identify endpoints that enforce a limit (e.g., "apply coupon once") or involve multi-step state changes
2. Send two or more identical requests simultaneously using single-packet attack
3. Compare responses -- if the limit was bypassed or state is inconsistent, a race condition exists
4. For hidden substates: test endpoints that modify critical data (profiles, tokens, permissions) by sending one state-changing request alongside a second that depends on the new state

## Exploitation

### Prerequisites

- An endpoint where concurrent access to shared state can produce unintended results
- Ability to send multiple requests simultaneously (HTTP/2 support preferred)
- For session-based targets: different session tokens for each request (to avoid session-level locking in frameworks like PHP)

### Step-by-Step

**1. Identify the target operation**

Find operations that enforce limits or involve multi-step state transitions: coupon redemption, money transfers, email verification, password resets, 2FA enforcement.

**2. Choose a synchronization technique**

| Protocol | Technique | Description |
|---|---|---|
| HTTP/2 | Single-Packet Attack | Send all requests in a single TCP packet. Removes network jitter entirely. Limit ~1,500 bytes per packet (extendable to ~65KB with IP fragmentation). |
| HTTP/1.1 | Last-Byte Synchronization | Pre-send all request data except the final byte, then send all final bytes at once. Works with 20-30 concurrent requests. |
| HTTP/3 | Last-Frame Synchronization (QUIC) | Coalesce multiple QUIC stream-final DATA frames into the same UDP datagram. Requires specialized libraries like H3SpaceX. |

**3. Execute the attack**

- **Burp Repeater**: Add the same request multiple times to a group tab, then use "Send group in parallel (single-packet attack)". For limit-overrun, add the same request 50 times.
- **Turbo Intruder**: Send the request to Turbo Intruder, select `examples/race-single-packet-attack.py`, and use gate-based synchronization.
- **Connection warming**: Add a few harmless requests at the beginning of the group to stabilize connection timing.

**4. Analyze results**

- Check if the limit was exceeded (e.g., coupon applied multiple times)
- Look for state inconsistencies in responses
- Negative timestamps in Turbo Intruder indicate the server responded before the request was fully sent, confirming request overlap

### Limit Overrun (Most Common in Bug Bounty)

The most basic and most commonly found type. Vulnerabilities appear where the application limits the number of times an action can be performed:

- Redeeming a gift card or coupon multiple times
- Rating or voting on a product multiple times
- Withdrawing or transferring more money than the account balance
- Reusing a single CAPTCHA solution
- Bypassing anti-brute-force rate limits
- Applying referral bonuses multiple times

### Time-of-Check to Time-of-Use (TOCTOU)

Exploits the gap between when a condition is checked and when the result of that check is used:

- Application checks if a coupon has been used, then marks it as used -- concurrent requests pass the check before the write completes
- Balance is checked, then deducted -- concurrent withdrawals can exceed the balance
- Email verification token sent to email A, but a race condition during profile update sends it to email B

### Hidden Substates

Exploit brief windows where server-side data is in a partially-written state:

- **Confirmation bypass**: When creating a user, the username/password may be written before the confirmation token. Sending requests with an empty token (`token=` or `token[]=`) during this window can confirm uncontrolled accounts.
- **2FA bypass**: A session may be created before the MFA enforcement flag is set. Concurrent requests during this window can access the account without completing 2FA.
- **Email verification race**: Change email and trigger verification simultaneously -- the verification token for the new email may be sent to the old email.

### Timing Attacks for Information Inference

Use response time differences to extract hidden information:

- Send concurrent requests using single-packet attack to eliminate network jitter
- Compare server-side processing time differences
- Discover hidden parameters or headers (integrated into Burp Param Miner)
- Detect scoped SSRFs via time differences when allowed vs. disallowed domains are queried
- Generate password reset tokens simultaneously -- matching tokens reveal timestamp-based generation

### Payloads

**Turbo Intruder -- Single-Packet Attack (single endpoint, limit overrun)**

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=1,
                           engine=Engine.BURP2
                           )
    for i in range(30):
        engine.queue(target.req, gate='race1')

    engine.start(timeout=10)
    engine.openGate('race1')
    engine.complete(timeout=60)

def handleResponse(req, interesting):
    table.add(req)
```

**Turbo Intruder -- Multi-Endpoint Attack (trigger state then exploit it)**

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=1,
                           engine=Engine.BURP2
                           )

    confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: target.com
Cookie: session=abc123
Content-Length: 0

'''

    for attempt in range(20):
        currentAttempt = str(attempt)
        username = 'user' + currentAttempt

        engine.queue(target.req, username, gate=currentAttempt)

        for i in range(50):
            engine.queue(confirmationReq, gate=currentAttempt)

        engine.openGate(currentAttempt)
```

**HTTP/1.1 Legacy Approach (Turbo Intruder)**

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=5,
                           requestsPerConnection=1,
                           pipeline=False
                           )
    for i in range(30):
        engine.queue(target.req, gate='race1')

    engine.start(timeout=10)
    engine.openGate('race1')
    engine.complete(timeout=60)

def handleResponse(req, interesting):
    table.add(req)
```

**Python asyncio (Quick PoC)**

```python
import asyncio
import httpx

async def send_request(client):
    resp = await client.post(
        'http://target.com/apply-coupon',
        cookies={"session": "SESSION_VALUE"},
        data={"code": "DISCOUNT20"}
    )
    return resp.status_code, resp.text

async def main():
    async with httpx.AsyncClient() as client:
        tasks = [asyncio.ensure_future(send_request(client)) for _ in range(20)]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        for r in results:
            print(r)

asyncio.run(main())
```

### Proof of Concept

1. Identify a coupon redemption endpoint: `POST /apply-coupon` with body `code=SAVE20`
2. Create a group of 30 identical requests in Burp Repeater
3. Use "Send group in parallel (single-packet attack)"
4. If the discount is applied more than once, the race condition is confirmed
5. Document the financial impact (e.g., 100% discount achieved by stacking)

## Bypasses

- **Session-level locking** (PHP): Use different session tokens for each concurrent request
- **Server concurrency limits** (`SETTINGS_MAX_CONCURRENT_STREAMS`): Apache limits to 100, Nginx to 128, Go to 250. NodeJS and nghttp2 are unlimited. For low limits, open multiple TCP/QUIC connections.
- **Rate limiting**: Use connection warming with dummy requests to trigger server-side delays that actually help synchronize your race requests
- **1,500-byte single-packet limit**: Use IP-layer fragmentation (First Sequence Sync) to extend to 65,535 bytes, enabling up to 10,000 concurrent requests
- **Front-end routing**: Warm connections by sending inconsequential requests first to normalize routing behavior

## Escalation

- **Limit overrun to financial impact**: Stack coupons/discounts for free purchases
- **Race condition to account takeover**: Exploit email verification races to verify attacker-controlled email
- **Race to 2FA bypass**: Access accounts by exploiting the gap before MFA enforcement
- **OAuth persistence**: Race the authorization_code exchange to generate multiple refresh tokens that survive permission revocation
- **Race in WebSockets**: Use parallel WebSocket messages to exploit server-side state (see WS_RaceCondition_PoC or Burp WebSocket Turbo Intruder)
- **Timing attacks to SSRF**: Discover scoped open proxies via response time analysis, then chain for firewall bypass or internal subdomain discovery

## Tools

| Tool | Usage |
|---|---|
| Burp Suite Repeater | "Send group in parallel (single-packet attack)" -- built-in HTTP/2 single-packet support |
| Turbo Intruder | Burp extension for advanced race condition exploitation with gate-based synchronization |
| h2spacex | Python library for HTTP/2 single-packet attacks outside of Burp |
| H3SpaceX | Go library for HTTP/3 last-frame synchronization over QUIC |
| First Sequence Sync | IP fragmentation technique to extend single-packet attack beyond 1,500 bytes |
| PacketSprinter | Burp extension simplifying HTTP/2 single-packet testing |
| WS_RaceCondition_PoC | Java PoC for WebSocket race conditions |
| WebSocket Turbo Intruder | Burp extension for racing WebSocket messages using THREADED engine |
| Param Miner | Burp extension with timing-based hidden parameter discovery |

## References

| URL | Description |
|---|---|
| https://portswigger.net/research/smashing-the-state-machine | James Kettle's original research on single-packet attack technique |
| https://portswigger.net/research/listen-to-the-whispers-web-timing-attacks-that-actually-work | PortSwigger research on web timing attacks for information inference |
| https://portswigger.net/web-security/race-conditions | PortSwigger race condition labs and methodology |
| https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/ | First Sequence Sync -- extending single-packet attack to 65KB |
| https://hackerone.com/reports/759247 | HackerOne race condition bug bounty report |
| https://github.com/nxenon/h3spacex | H3SpaceX -- HTTP/3 last-frame synchronization library |
| https://github.com/Ry0taK/first-sequence-sync | First Sequence Sync implementation and examples |
| https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine | WebSocket Turbo Intruder research |
