# Race Conditions

> **Summary**: Race conditions occur when an application processes concurrent requests in a way that leads to unintended behavior due to timing conflicts in shared resource access.
> **Impact**: Bypass business logic limits, duplicate financial transactions, escalate privileges, bypass authentication, corrupt data integrity.
> **Typical Severity**: High

## Detection

### Indicators

- Coupon or discount code redemption endpoints
- Balance transfer / withdrawal operations
- Voting, rating, or like functionality
- Gift card or reward point redemption
- Account registration with email verification
- Password reset token generation
- File upload and processing workflows
- Anti-brute-force rate limiting mechanisms
- CAPTCHA validation and reuse
- 2FA enforcement during login sequences
- OAuth authorization code exchange
- Any endpoint that reads a value, checks it, then writes based on the check (TOCTOU)

### Automated Detection

- Use Burp Suite Repeater with "Send group in parallel (single-packet attack)" on candidate endpoints
- Turbo Intruder with `race-single-packet-attack.py` template
- Monitor for duplicate entries in database results (e.g., coupon applied twice)
- Look for inconsistent state in responses when identical requests are sent concurrently

### Manual Detection

1. Identify endpoints that enforce a limit (e.g., "apply coupon once") or involve multi-step state changes
2. Send two or more identical requests simultaneously using single-packet attack
3. Compare responses -- if the limit was bypassed or state is inconsistent, a race condition exists
4. For hidden substates: test endpoints that modify critical data (profiles, tokens, permissions) by sending one state-changing request alongside a second that depends on the new state

## Exploitation

### Prerequisites

- An endpoint where concurrent access to shared state can produce unintended results
- Ability to send multiple requests simultaneously (HTTP/2 support preferred)
- For session-based targets: different session tokens for each request (to avoid session-level locking in frameworks like PHP)

### Step-by-Step

**1. Identify the target operation**

Find operations that enforce limits or involve multi-step state transitions: coupon redemption, money transfers, email verification, password resets, 2FA enforcement.

**2. Choose a synchronization technique**

| Protocol | Technique | Description |
|---|---|---|
| HTTP/2 | Single-Packet Attack | Send all requests in a single TCP packet. Removes network jitter entirely. Limit ~1,500 bytes per packet (extendable to ~65KB with IP fragmentation). |
| HTTP/1.1 | Last-Byte Synchronization | Pre-send all request data except the final byte, then send all final bytes at once. Works with 20-30 concurrent requests. |
| HTTP/3 | Last-Frame Synchronization (QUIC) | Coalesce multiple QUIC stream-final DATA frames into the same UDP datagram. Requires specialized libraries like H3SpaceX. |

**3. Execute the attack**

- **Burp Repeater**: Add the same request multiple times to a group tab, then use "Send group in parallel (single-packet attack)". For limit-overrun, add the same request 50 times.
- **Turbo Intruder**: Send the request to Turbo Intruder, select `examples/race-single-packet-attack.py`, and use gate-based synchronization.
- **Connection warming**: Add a few harmless requests at the beginning of the group to stabilize connection timing.

**4. Analyze results**

- Check if the limit was exceeded (e.g., coupon applied multiple times)
- Look for state inconsistencies in responses
- Negative timestamps in Turbo Intruder indicate the server responded before the request was fully sent, confirming request overlap

### Limit Overrun (Most Common in Bug Bounty)

The most basic and most commonly found type. Vulnerabilities appear where the application limits the number of times an action can be performed:

- Redeeming a gift card or coupon multiple times
- Rating or voting on a product multiple times
- Withdrawing or transferring more money than the account balance
- Reusing a single CAPTCHA solution
- Bypassing anti-brute-force rate limits
- Applying referral bonuses multiple times

### Time-of-Check to Time-of-Use (TOCTOU)

Exploits the gap between when a condition is checked and when the result of that check is used:

- Application checks if a coupon has been used, then marks it as used -- concurrent requests pass the check before the write completes
- Balance is checked, then deducted -- concurrent withdrawals can exceed the balance
- Email verification token sent to email A, but a race condition during profile update sends it to email B

### Hidden Substates

Exploit brief windows where server-side data is in a partially-written state:

- **Confirmation bypass**: When creating a user, the username/password may be written before the confirmation token. Sending requests with an empty token (`token=` or `token[]=`) during this window can confirm uncontrolled accounts.
- **2FA bypass**: A session may be created before the MFA enforcement flag is set. Concurrent requests during this window can access the account without completing 2FA.
- **Email verification race**: Change email and trigger verification simultaneously -- the verification token for the new email may be sent to the old email.

### Timing Attacks for Information Inference

Use response time differences to extract hidden information:

- Send concurrent requests using single-packet attack to eliminate network jitter
- Compare server-side processing time differences
- Discover hidden parameters or headers (integrated into Burp Param Miner)
- Detect scoped SSRFs via time differences when allowed vs. disallowed domains are queried
- Generate password reset tokens simultaneously -- matching tokens reveal timestamp-based generation

### Payloads

**Turbo Intruder -- Single-Packet Attack (single endpoint, limit overrun)**

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=1,
                           engine=Engine.BURP2
                           )
    for i in range(30):
        engine.queue(target.req, gate='race1')

    engine.start(timeout=10)
    engine.openGate('race1')
    engine.complete(timeout=60)

def handleResponse(req, interesting):
    table.add(req)
```

**Turbo Intruder -- Multi-Endpoint Attack (trigger state then exploit it)**

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=1,
                           engine=Engine.BURP2
                           )

    confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: target.com
Cookie: session=abc123
Content-Length: 0

'''

    for attempt in range(20):
        currentAttempt = str(attempt)
        username = 'user' + currentAttempt

        engine.queue(target.req, username, gate=currentAttempt)

        for i in range(50):
            engine.queue(confirmationReq, gate=currentAttempt)

        engine.openGate(currentAttempt)
```

**HTTP/1.1 Legacy Approach (Turbo Intruder)**

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=5,
                           requestsPerConnection=1,
                           pipeline=False
                           )
    for i in range(30):
        engine.queue(target.req, gate='race1')

    engine.start(timeout=10)
    engine.openGate('race1')
    engine.complete(timeout=60)

def handleResponse(req, interesting):
    table.add(req)
```

**Python asyncio (Quick PoC)**

```python
import asyncio
import httpx

async def send_request(client):
    resp = await client.post(
        'http://target.com/apply-coupon',
        cookies={"session": "SESSION_VALUE"},
        data={"code": "DISCOUNT20"}
    )
    return resp.status_code, resp.text

async def main():
    async with httpx.AsyncClient() as client:
        tasks = [asyncio.ensure_future(send_request(client)) for _ in range(20)]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        for r in results:
            print(r)

asyncio.run(main())
```

### Proof of Concept

1. Identify a coupon redemption endpoint: `POST /apply-coupon` with body `code=SAVE20`
2. Create a group of 30 identical requests in Burp Repeater
3. Use "Send group in parallel (single-packet attack)"
4. If the discount is applied more than once, the race condition is confirmed
5. Document the financial impact (e.g., 100% discount achieved by stacking)

## Bypasses

- **Session-level locking** (PHP): Use different session tokens for each concurrent request
- **Server concurrency limits** (`SETTINGS_MAX_CONCURRENT_STREAMS`): Apache limits to 100, Nginx to 128, Go to 250. NodeJS and nghttp2 are unlimited. For low limits, open multiple TCP/QUIC connections.
- **Rate limiting**: Use connection warming with dummy requests to trigger server-side delays that actually help synchronize your race requests
- **1,500-byte single-packet limit**: Use IP-layer fragmentation (First Sequence Sync) to extend to 65,535 bytes, enabling up to 10,000 concurrent requests
- **Front-end routing**: Warm connections by sending inconsequential requests first to normalize routing behavior

## Escalation

- **Limit overrun to financial impact**: Stack coupons/discounts for free purchases
- **Race condition to account takeover**: Exploit email verification races to verify attacker-controlled email
- **Race to 2FA bypass**: Access accounts by exploiting the gap before MFA enforcement
- **OAuth persistence**: Race the authorization_code exchange to generate multiple refresh tokens that survive permission revocation
- **Race in WebSockets**: Use parallel WebSocket messages to exploit server-side state (see WS_RaceCondition_PoC or Burp WebSocket Turbo Intruder)
- **Timing attacks to SSRF**: Discover scoped open proxies via response time analysis, then chain for firewall bypass or internal subdomain discovery

## Tools

| Tool | Usage |
|---|---|
| Burp Suite Repeater | "Send group in parallel (single-packet attack)" -- built-in HTTP/2 single-packet support |
| Turbo Intruder | Burp extension for advanced race condition exploitation with gate-based synchronization |
| h2spacex | Python library for HTTP/2 single-packet attacks outside of Burp |
| H3SpaceX | Go library for HTTP/3 last-frame synchronization over QUIC |
| First Sequence Sync | IP fragmentation technique to extend single-packet attack beyond 1,500 bytes |
| PacketSprinter | Burp extension simplifying HTTP/2 single-packet testing |
| WS_RaceCondition_PoC | Java PoC for WebSocket race conditions |
| WebSocket Turbo Intruder | Burp extension for racing WebSocket messages using THREADED engine |
| Param Miner | Burp extension with timing-based hidden parameter discovery |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for this vulnerability.

### Phase 1: Discovery
1. **Identify race-condition-prone features**:
   - Map all endpoints that enforce a **limit** or involve **state transitions**:
     - Coupon/discount redemption: `<COUPON_ENDPOINT>` (e.g., `POST /apply-coupon`)
     - Money transfers/withdrawals: `<TRANSFER_ENDPOINT>` (e.g., `POST /transfer`)
     - Voting/rating/like: `<VOTE_ENDPOINT>` (e.g., `POST /like`)
     - Gift card redemption: `<REDEEM_ENDPOINT>`
     - Follow/unfollow: `<FOLLOW_ENDPOINT>`
     - Password reset token generation: `<RESET_ENDPOINT>`
     - Email verification: `<VERIFY_ENDPOINT>`
     - 2FA enforcement during login: `<LOGIN_ENDPOINT>`, `<MFA_ENDPOINT>`
     - CAPTCHA validation: `<CAPTCHA_ENDPOINT>`
     - OAuth authorization code exchange: `<OAUTH_TOKEN_ENDPOINT>`
   - For each endpoint, record: `<URL>`, `<METHOD>`, `<BODY_PARAMS>`, `<SESSION_TOKEN>`, `<EXPECTED_LIMIT>`.
2. **Determine HTTP protocol support**:
   - Check if the target supports HTTP/2 (preferred for single-packet attack).
   - **IF** HTTP/2 supported --> use single-packet attack technique.
   - **IF** HTTP/1.1 only --> use last-byte synchronization technique.
   - Check `SETTINGS_MAX_CONCURRENT_STREAMS` value (Apache: 100, Nginx: 128).

### Phase 2: Validation
1. **Set up the synchronization technique**:
   - **HTTP/2 single-packet attack** (Burp Repeater):
     - Add the target request to a Burp Repeater group tab.
     - Duplicate the request 20-50 times within the group.
     - Add 1-2 harmless "connection warming" requests at the beginning of the group.
     - Select "Send group in parallel (single-packet attack)".
   - **HTTP/1.1 last-byte sync** (Turbo Intruder):
     - Send request to Turbo Intruder.
     - Select `examples/race-single-packet-attack.py` template.
     - Set `concurrentConnections=1`, `engine=Engine.BURP2`, and gate-based synchronization.
   - **IF** session-level locking is suspected (PHP) --> use a **different session token** for each concurrent request.
2. **Test with a small batch first**:
   - Send 5 identical requests simultaneously to `<TARGET_ENDPOINT>`.
   - **IF** all 5 succeed when only 1 should --> race condition confirmed.
   - **IF** only 1 succeeds --> increase to 20-50 requests and retry.
   - **IF** still only 1 succeeds --> check for session locking, try different sessions, or try last-byte sync.

### Phase 3: Exploitation
1. **Limit Overrun attack**:
   - Prepare 30-50 identical requests to `<TARGET_ENDPOINT>` with the same `<ACTION_PARAMS>` (e.g., coupon code, transfer amount).
   - Execute single-packet attack.
   - **IF** the action was performed more times than the limit allows --> limit overrun confirmed.
   - Record: how many times the action succeeded vs. the expected limit.
2. **TOCTOU (Time-of-Check to Time-of-Use)**:
   - Identify operations where a value is checked then modified (e.g., balance check then deduction).
   - Send concurrent withdrawal/transfer requests for the full balance amount.
   - **IF** total withdrawn exceeds the balance --> TOCTOU race confirmed.
3. **Hidden Substates**:
   - **2FA bypass**: Send login request and simultaneously send requests to authenticated endpoints.
     - Gate the login request and a direct-access request together.
     - **IF** direct access succeeds without 2FA --> hidden substate exploited.
   - **Email verification bypass**: Trigger account creation and simultaneously send empty-token confirmation requests (`token=` or `token[]=`).
     - **IF** account confirmed without valid token --> hidden substate exploited.
   - **Password reset race**: Generate two password reset tokens simultaneously for the same account.
     - **IF** tokens are identical --> timestamp-based token generation confirmed.

### Phase 4: Escalation
1. **Verify state inconsistency**:
   - Check the account/database state after the race attack.
   - **Duplicate coupon**: Verify the discount was applied `<N>` times instead of once. Calculate financial impact: `<DISCOUNT_VALUE> x <N>`.
   - **Double spend**: Verify the total transferred exceeds the original balance. Document: `<ORIGINAL_BALANCE>` vs. `<TOTAL_WITHDRAWN>`.
   - **Duplicate rewards**: Verify referral bonuses, loyalty points, or credits were awarded multiple times.
2. **Chain with other attacks**:
   - Race in OAuth --> generate multiple refresh tokens that persist after permission revocation.
   - Race in email verification --> account takeover by verifying attacker email.
   - Race in file upload --> bypass upload-then-delete validation to achieve RCE (see [File Upload](file-upload.md)).

## Decision Tree

```
Start: State-changing endpoint identified
|
|--> Classify the race condition type
|    |
|    |--> [Endpoint enforces a numeric limit] --> LIMIT OVERRUN
|    |    |--> Send 30-50 identical requests via single-packet attack
|    |    |--> IF action performed > limit --> confirmed
|    |    |--> IF only 1 succeeds --> try different sessions, increase concurrency
|    |
|    |--> [Endpoint checks then modifies a value] --> TOCTOU
|    |    |--> Send concurrent requests that each consume the full resource
|    |    |--> IF total consumed > available --> confirmed
|    |    |--> Example: transfer full balance simultaneously from two sessions
|    |
|    |--> [Multi-step state transition] --> HIDDEN SUBSTATES
|         |--> Identify the brief window between state writes
|         |--> Send exploiting request during the substate window
|         |--> Techniques:
|              |--> 2FA bypass: access account before MFA flag is set
|              |--> Email verification: confirm with empty token during creation
|              |--> Password reset: generate simultaneous tokens to detect timestamp seeding
|
|--> IF single-packet attack fails
|    |--> Check for session-level locking --> use different sessions per request
|    |--> Check SETTINGS_MAX_CONCURRENT_STREAMS --> open multiple connections
|    |--> Try HTTP/1.1 last-byte sync if HTTP/2 unavailable
|    |--> Try First Sequence Sync (IP fragmentation) for >1500 byte requests
```

## Success Criteria

- **Minimum PoC**: Demonstrated that a limited action (coupon, vote, transfer) was performed more times than intended in a single concurrent batch.
- **Confirmed Impact**: Quantified the business impact (e.g., "$100 discount applied 5 times = $500 loss" or "withdrew $1000 from a $500 balance").
- **Escalation Confirmed**: Achieved 2FA bypass, account takeover via email verification race, or OAuth token persistence.
- **Evidence Required**: Screenshots or HTTP logs showing: (1) the concurrent requests sent, (2) the multiple success responses, (3) the resulting inconsistent state (database record, account balance, applied discounts).

## References

| URL | Description |
|---|---|
| https://portswigger.net/research/smashing-the-state-machine | James Kettle's original research on single-packet attack technique |
| https://portswigger.net/research/listen-to-the-whispers-web-timing-attacks-that-actually-work | PortSwigger research on web timing attacks for information inference |
| https://portswigger.net/web-security/race-conditions | PortSwigger race condition labs and methodology |
| https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/ | First Sequence Sync -- extending single-packet attack to 65KB |
| https://hackerone.com/reports/759247 | HackerOne race condition bug bounty report |
| https://github.com/nxenon/h3spacex | H3SpaceX -- HTTP/3 last-frame synchronization library |
| https://github.com/Ry0taK/first-sequence-sync | First Sequence Sync implementation and examples |
| https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine | WebSocket Turbo Intruder research |
